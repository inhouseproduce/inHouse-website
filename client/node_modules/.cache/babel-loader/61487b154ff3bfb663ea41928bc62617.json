{"ast":null,"code":"/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar _config = require(\"../../config\");\n\nvar __DEV__ = _config.__DEV__;\n\nvar _model = require(\"../../util/model\");\n\nvar makeInner = _model.makeInner;\nvar getDataItemValue = _model.getDataItemValue;\n\nvar _referHelper = require(\"../../model/referHelper\");\n\nvar getCoordSysDefineBySeries = _referHelper.getCoordSysDefineBySeries;\n\nvar _util = require(\"zrender/lib/core/util\");\n\nvar createHashMap = _util.createHashMap;\nvar each = _util.each;\nvar map = _util.map;\nvar isArray = _util.isArray;\nvar isString = _util.isString;\nvar isObject = _util.isObject;\nvar isTypedArray = _util.isTypedArray;\nvar isArrayLike = _util.isArrayLike;\nvar extend = _util.extend;\nvar assert = _util.assert;\n\nvar Source = require(\"../Source\");\n\nvar _sourceType = require(\"./sourceType\");\n\nvar SOURCE_FORMAT_ORIGINAL = _sourceType.SOURCE_FORMAT_ORIGINAL;\nvar SOURCE_FORMAT_ARRAY_ROWS = _sourceType.SOURCE_FORMAT_ARRAY_ROWS;\nvar SOURCE_FORMAT_OBJECT_ROWS = _sourceType.SOURCE_FORMAT_OBJECT_ROWS;\nvar SOURCE_FORMAT_KEYED_COLUMNS = _sourceType.SOURCE_FORMAT_KEYED_COLUMNS;\nvar SOURCE_FORMAT_UNKNOWN = _sourceType.SOURCE_FORMAT_UNKNOWN;\nvar SOURCE_FORMAT_TYPED_ARRAY = _sourceType.SOURCE_FORMAT_TYPED_ARRAY;\nvar SERIES_LAYOUT_BY_ROW = _sourceType.SERIES_LAYOUT_BY_ROW;\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\nvar inner = makeInner();\n/**\n * @see {module:echarts/data/Source}\n * @param {module:echarts/component/dataset/DatasetModel} datasetModel\n * @return {string} sourceFormat\n */\n\nfunction detectSourceFormat(datasetModel) {\n  var data = datasetModel.option.source;\n  var sourceFormat = SOURCE_FORMAT_UNKNOWN;\n\n  if (isTypedArray(data)) {\n    sourceFormat = SOURCE_FORMAT_TYPED_ARRAY;\n  } else if (isArray(data)) {\n    // FIXME Whether tolerate null in top level array?\n    if (data.length === 0) {\n      sourceFormat = SOURCE_FORMAT_ARRAY_ROWS;\n    }\n\n    for (var i = 0, len = data.length; i < len; i++) {\n      var item = data[i];\n\n      if (item == null) {\n        continue;\n      } else if (isArray(item)) {\n        sourceFormat = SOURCE_FORMAT_ARRAY_ROWS;\n        break;\n      } else if (isObject(item)) {\n        sourceFormat = SOURCE_FORMAT_OBJECT_ROWS;\n        break;\n      }\n    }\n  } else if (isObject(data)) {\n    for (var key in data) {\n      if (data.hasOwnProperty(key) && isArrayLike(data[key])) {\n        sourceFormat = SOURCE_FORMAT_KEYED_COLUMNS;\n        break;\n      }\n    }\n  } else if (data != null) {\n    throw new Error('Invalid data');\n  }\n\n  inner(datasetModel).sourceFormat = sourceFormat;\n}\n/**\n * [Scenarios]:\n * (1) Provide source data directly:\n *     series: {\n *         encode: {...},\n *         dimensions: [...]\n *         seriesLayoutBy: 'row',\n *         data: [[...]]\n *     }\n * (2) Refer to datasetModel.\n *     series: [{\n *         encode: {...}\n *         // Ignore datasetIndex means `datasetIndex: 0`\n *         // and the dimensions defination in dataset is used\n *     }, {\n *         encode: {...},\n *         seriesLayoutBy: 'column',\n *         datasetIndex: 1\n *     }]\n *\n * Get data from series itself or datset.\n * @return {module:echarts/data/Source} source\n */\n\n\nfunction getSource(seriesModel) {\n  return inner(seriesModel).source;\n}\n/**\n * MUST be called before mergeOption of all series.\n * @param {module:echarts/model/Global} ecModel\n */\n\n\nfunction resetSourceDefaulter(ecModel) {\n  // `datasetMap` is used to make default encode.\n  inner(ecModel).datasetMap = createHashMap();\n}\n/**\n * [Caution]:\n * MUST be called after series option merged and\n * before \"series.getInitailData()\" called.\n *\n * [The rule of making default encode]:\n * Category axis (if exists) alway map to the first dimension.\n * Each other axis occupies a subsequent dimension.\n *\n * [Why make default encode]:\n * Simplify the typing of encode in option, avoiding the case like that:\n * series: [{encode: {x: 0, y: 1}}, {encode: {x: 0, y: 2}}, {encode: {x: 0, y: 3}}],\n * where the \"y\" have to be manually typed as \"1, 2, 3, ...\".\n *\n * @param {module:echarts/model/Series} seriesModel\n */\n\n\nfunction prepareSource(seriesModel) {\n  var seriesOption = seriesModel.option;\n  var data = seriesOption.data;\n  var sourceFormat = isTypedArray(data) ? SOURCE_FORMAT_TYPED_ARRAY : SOURCE_FORMAT_ORIGINAL;\n  var fromDataset = false;\n  var seriesLayoutBy = seriesOption.seriesLayoutBy;\n  var sourceHeader = seriesOption.sourceHeader;\n  var dimensionsDefine = seriesOption.dimensions;\n  var datasetModel = getDatasetModel(seriesModel);\n\n  if (datasetModel) {\n    var datasetOption = datasetModel.option;\n    data = datasetOption.source;\n    sourceFormat = inner(datasetModel).sourceFormat;\n    fromDataset = true; // These settings from series has higher priority.\n\n    seriesLayoutBy = seriesLayoutBy || datasetOption.seriesLayoutBy;\n    sourceHeader == null && (sourceHeader = datasetOption.sourceHeader);\n    dimensionsDefine = dimensionsDefine || datasetOption.dimensions;\n  }\n\n  var completeResult = completeBySourceData(data, sourceFormat, seriesLayoutBy, sourceHeader, dimensionsDefine); // Note: dataset option does not have `encode`.\n\n  var encodeDefine = seriesOption.encode;\n\n  if (!encodeDefine && datasetModel) {\n    encodeDefine = makeDefaultEncode(seriesModel, datasetModel, data, sourceFormat, seriesLayoutBy, completeResult);\n  }\n\n  inner(seriesModel).source = new Source({\n    data: data,\n    fromDataset: fromDataset,\n    seriesLayoutBy: seriesLayoutBy,\n    sourceFormat: sourceFormat,\n    dimensionsDefine: completeResult.dimensionsDefine,\n    startIndex: completeResult.startIndex,\n    dimensionsDetectCount: completeResult.dimensionsDetectCount,\n    encodeDefine: encodeDefine\n  });\n} // return {startIndex, dimensionsDefine, dimensionsCount}\n\n\nfunction completeBySourceData(data, sourceFormat, seriesLayoutBy, sourceHeader, dimensionsDefine) {\n  if (!data) {\n    return {\n      dimensionsDefine: normalizeDimensionsDefine(dimensionsDefine)\n    };\n  }\n\n  var dimensionsDetectCount;\n  var startIndex;\n  var findPotentialName;\n\n  if (sourceFormat === SOURCE_FORMAT_ARRAY_ROWS) {\n    // Rule: Most of the first line are string: it is header.\n    // Caution: consider a line with 5 string and 1 number,\n    // it still can not be sure it is a head, because the\n    // 5 string may be 5 values of category columns.\n    if (sourceHeader === 'auto' || sourceHeader == null) {\n      arrayRowsTravelFirst(function (val) {\n        // '-' is regarded as null/undefined.\n        if (val != null && val !== '-') {\n          if (isString(val)) {\n            startIndex == null && (startIndex = 1);\n          } else {\n            startIndex = 0;\n          }\n        } // 10 is an experience number, avoid long loop.\n\n      }, seriesLayoutBy, data, 10);\n    } else {\n      startIndex = sourceHeader ? 1 : 0;\n    }\n\n    if (!dimensionsDefine && startIndex === 1) {\n      dimensionsDefine = [];\n      arrayRowsTravelFirst(function (val, index) {\n        dimensionsDefine[index] = val != null ? val : '';\n      }, seriesLayoutBy, data);\n    }\n\n    dimensionsDetectCount = dimensionsDefine ? dimensionsDefine.length : seriesLayoutBy === SERIES_LAYOUT_BY_ROW ? data.length : data[0] ? data[0].length : null;\n  } else if (sourceFormat === SOURCE_FORMAT_OBJECT_ROWS) {\n    if (!dimensionsDefine) {\n      dimensionsDefine = objectRowsCollectDimensions(data);\n      findPotentialName = true;\n    }\n  } else if (sourceFormat === SOURCE_FORMAT_KEYED_COLUMNS) {\n    if (!dimensionsDefine) {\n      dimensionsDefine = [];\n      findPotentialName = true;\n      each(data, function (colArr, key) {\n        dimensionsDefine.push(key);\n      });\n    }\n  } else if (sourceFormat === SOURCE_FORMAT_ORIGINAL) {\n    var value0 = getDataItemValue(data[0]);\n    dimensionsDetectCount = isArray(value0) && value0.length || 1;\n  } else if (sourceFormat === SOURCE_FORMAT_TYPED_ARRAY) {}\n\n  var potentialNameDimIndex;\n\n  if (findPotentialName) {\n    each(dimensionsDefine, function (dim, idx) {\n      if ((isObject(dim) ? dim.name : dim) === 'name') {\n        potentialNameDimIndex = idx;\n      }\n    });\n  }\n\n  return {\n    startIndex: startIndex,\n    dimensionsDefine: normalizeDimensionsDefine(dimensionsDefine),\n    dimensionsDetectCount: dimensionsDetectCount,\n    potentialNameDimIndex: potentialNameDimIndex // TODO: potentialIdDimIdx\n\n  };\n} // Consider dimensions defined like ['A', 'price', 'B', 'price', 'C', 'price'],\n// which is reasonable. But dimension name is duplicated.\n// Returns undefined or an array contains only object without null/undefiend or string.\n\n\nfunction normalizeDimensionsDefine(dimensionsDefine) {\n  if (!dimensionsDefine) {\n    // The meaning of null/undefined is different from empty array.\n    return;\n  }\n\n  var nameMap = createHashMap();\n  return map(dimensionsDefine, function (item, index) {\n    item = extend({}, isObject(item) ? item : {\n      name: item\n    }); // User can set null in dimensions.\n    // We dont auto specify name, othewise a given name may\n    // cause it be refered unexpectedly.\n\n    if (item.name == null) {\n      return item;\n    } // Also consider number form like 2012.\n\n\n    item.name += ''; // User may also specify displayName.\n    // displayName will always exists except user not\n    // specified or dim name is not specified or detected.\n    // (A auto generated dim name will not be used as\n    // displayName).\n\n    if (item.displayName == null) {\n      item.displayName = item.name;\n    }\n\n    var exist = nameMap.get(item.name);\n\n    if (!exist) {\n      nameMap.set(item.name, {\n        count: 1\n      });\n    } else {\n      item.name += '-' + exist.count++;\n    }\n\n    return item;\n  });\n}\n\nfunction arrayRowsTravelFirst(cb, seriesLayoutBy, data, maxLoop) {\n  maxLoop == null && (maxLoop = Infinity);\n\n  if (seriesLayoutBy === SERIES_LAYOUT_BY_ROW) {\n    for (var i = 0; i < data.length && i < maxLoop; i++) {\n      cb(data[i] ? data[i][0] : null, i);\n    }\n  } else {\n    var value0 = data[0] || [];\n\n    for (var i = 0; i < value0.length && i < maxLoop; i++) {\n      cb(value0[i], i);\n    }\n  }\n}\n\nfunction objectRowsCollectDimensions(data) {\n  var firstIndex = 0;\n  var obj;\n\n  while (firstIndex < data.length && !(obj = data[firstIndex++])) {} // jshint ignore: line\n\n\n  if (obj) {\n    var dimensions = [];\n    each(obj, function (value, key) {\n      dimensions.push(key);\n    });\n    return dimensions;\n  }\n} // ??? TODO merge to completedimensions, where also has\n// default encode making logic. And the default rule\n// should depends on series? consider 'map'.\n\n\nfunction makeDefaultEncode(seriesModel, datasetModel, data, sourceFormat, seriesLayoutBy, completeResult) {\n  var coordSysDefine = getCoordSysDefineBySeries(seriesModel);\n  var encode = {}; // var encodeTooltip = [];\n  // var encodeLabel = [];\n\n  var encodeItemName = [];\n  var encodeSeriesName = [];\n  var seriesType = seriesModel.subType; // ??? TODO refactor: provide by series itself.\n  // Consider the case: 'map' series is based on geo coordSys,\n  // 'graph', 'heatmap' can be based on cartesian. But can not\n  // give default rule simply here.\n\n  var nSeriesMap = createHashMap(['pie', 'map', 'funnel']);\n  var cSeriesMap = createHashMap(['line', 'bar', 'pictorialBar', 'scatter', 'effectScatter', 'candlestick', 'boxplot']); // Usually in this case series will use the first data\n  // dimension as the \"value\" dimension, or other default\n  // processes respectively.\n\n  if (coordSysDefine && cSeriesMap.get(seriesType) != null) {\n    var ecModel = seriesModel.ecModel;\n    var datasetMap = inner(ecModel).datasetMap;\n    var key = datasetModel.uid + '_' + seriesLayoutBy;\n    var datasetRecord = datasetMap.get(key) || datasetMap.set(key, {\n      categoryWayDim: 1,\n      valueWayDim: 0\n    }); // TODO\n    // Auto detect first time axis and do arrangement.\n\n    each(coordSysDefine.coordSysDims, function (coordDim) {\n      // In value way.\n      if (coordSysDefine.firstCategoryDimIndex == null) {\n        var dataDim = datasetRecord.valueWayDim++;\n        encode[coordDim] = dataDim; // ??? TODO give a better default series name rule?\n        // especially when encode x y specified.\n        // consider: when mutiple series share one dimension\n        // category axis, series name should better use\n        // the other dimsion name. On the other hand, use\n        // both dimensions name.\n\n        encodeSeriesName.push(dataDim); // encodeTooltip.push(dataDim);\n        // encodeLabel.push(dataDim);\n      } // In category way, category axis.\n      else if (coordSysDefine.categoryAxisMap.get(coordDim)) {\n          encode[coordDim] = 0;\n          encodeItemName.push(0);\n        } // In category way, non-category axis.\n        else {\n            var dataDim = datasetRecord.categoryWayDim++;\n            encode[coordDim] = dataDim; // encodeTooltip.push(dataDim);\n            // encodeLabel.push(dataDim);\n\n            encodeSeriesName.push(dataDim);\n          }\n    });\n  } // Do not make a complex rule! Hard to code maintain and not necessary.\n  // ??? TODO refactor: provide by series itself.\n  // [{name: ..., value: ...}, ...] like:\n  else if (nSeriesMap.get(seriesType) != null) {\n      // Find the first not ordinal. (5 is an experience value)\n      var firstNotOrdinal;\n\n      for (var i = 0; i < 5 && firstNotOrdinal == null; i++) {\n        if (!doGuessOrdinal(data, sourceFormat, seriesLayoutBy, completeResult.dimensionsDefine, completeResult.startIndex, i)) {\n          firstNotOrdinal = i;\n        }\n      }\n\n      if (firstNotOrdinal != null) {\n        encode.value = firstNotOrdinal;\n        var nameDimIndex = completeResult.potentialNameDimIndex || Math.max(firstNotOrdinal - 1, 0); // By default, label use itemName in charts.\n        // So we dont set encodeLabel here.\n\n        encodeSeriesName.push(nameDimIndex);\n        encodeItemName.push(nameDimIndex); // encodeTooltip.push(firstNotOrdinal);\n      }\n    } // encodeTooltip.length && (encode.tooltip = encodeTooltip);\n  // encodeLabel.length && (encode.label = encodeLabel);\n\n\n  encodeItemName.length && (encode.itemName = encodeItemName);\n  encodeSeriesName.length && (encode.seriesName = encodeSeriesName);\n  return encode;\n}\n/**\n * If return null/undefined, indicate that should not use datasetModel.\n */\n\n\nfunction getDatasetModel(seriesModel) {\n  var option = seriesModel.option; // Caution: consider the scenario:\n  // A dataset is declared and a series is not expected to use the dataset,\n  // and at the beginning `setOption({series: { noData })` (just prepare other\n  // option but no data), then `setOption({series: {data: [...]}); In this case,\n  // the user should set an empty array to avoid that dataset is used by default.\n\n  var thisData = option.data;\n\n  if (!thisData) {\n    return seriesModel.ecModel.getComponent('dataset', option.datasetIndex || 0);\n  }\n}\n/**\n * The rule should not be complex, otherwise user might not\n * be able to known where the data is wrong.\n * The code is ugly, but how to make it neat?\n *\n * @param {module:echars/data/Source} source\n * @param {number} dimIndex\n * @return {boolean} Whether ordinal.\n */\n\n\nfunction guessOrdinal(source, dimIndex) {\n  return doGuessOrdinal(source.data, source.sourceFormat, source.seriesLayoutBy, source.dimensionsDefine, source.startIndex, dimIndex);\n} // dimIndex may be overflow source data.\n\n\nfunction doGuessOrdinal(data, sourceFormat, seriesLayoutBy, dimensionsDefine, startIndex, dimIndex) {\n  var result; // Experience value.\n\n  var maxLoop = 5;\n\n  if (isTypedArray(data)) {\n    return false;\n  } // When sourceType is 'objectRows' or 'keyedColumns', dimensionsDefine\n  // always exists in source.\n\n\n  var dimName;\n\n  if (dimensionsDefine) {\n    dimName = dimensionsDefine[dimIndex];\n    dimName = isObject(dimName) ? dimName.name : dimName;\n  }\n\n  if (sourceFormat === SOURCE_FORMAT_ARRAY_ROWS) {\n    if (seriesLayoutBy === SERIES_LAYOUT_BY_ROW) {\n      var sample = data[dimIndex];\n\n      for (var i = 0; i < (sample || []).length && i < maxLoop; i++) {\n        if ((result = detectValue(sample[startIndex + i])) != null) {\n          return result;\n        }\n      }\n    } else {\n      for (var i = 0; i < data.length && i < maxLoop; i++) {\n        var row = data[startIndex + i];\n\n        if (row && (result = detectValue(row[dimIndex])) != null) {\n          return result;\n        }\n      }\n    }\n  } else if (sourceFormat === SOURCE_FORMAT_OBJECT_ROWS) {\n    if (!dimName) {\n      return;\n    }\n\n    for (var i = 0; i < data.length && i < maxLoop; i++) {\n      var item = data[i];\n\n      if (item && (result = detectValue(item[dimName])) != null) {\n        return result;\n      }\n    }\n  } else if (sourceFormat === SOURCE_FORMAT_KEYED_COLUMNS) {\n    if (!dimName) {\n      return;\n    }\n\n    var sample = data[dimName];\n\n    if (!sample || isTypedArray(sample)) {\n      return false;\n    }\n\n    for (var i = 0; i < sample.length && i < maxLoop; i++) {\n      if ((result = detectValue(sample[i])) != null) {\n        return result;\n      }\n    }\n  } else if (sourceFormat === SOURCE_FORMAT_ORIGINAL) {\n    for (var i = 0; i < data.length && i < maxLoop; i++) {\n      var item = data[i];\n      var val = getDataItemValue(item);\n\n      if (!isArray(val)) {\n        return false;\n      }\n\n      if ((result = detectValue(val[dimIndex])) != null) {\n        return result;\n      }\n    }\n  }\n\n  function detectValue(val) {\n    // Consider usage convenience, '1', '2' will be treated as \"number\".\n    // `isFinit('')` get `true`.\n    if (val != null && isFinite(val) && val !== '') {\n      return false;\n    } else if (isString(val) && val !== '-') {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nexports.detectSourceFormat = detectSourceFormat;\nexports.getSource = getSource;\nexports.resetSourceDefaulter = resetSourceDefaulter;\nexports.prepareSource = prepareSource;\nexports.guessOrdinal = guessOrdinal;","map":{"version":3,"sources":["/Users/eduardjacobs/Desktop/files/inHouse-website/client/node_modules/echarts/lib/data/helper/sourceHelper.js"],"names":["_config","require","__DEV__","_model","makeInner","getDataItemValue","_referHelper","getCoordSysDefineBySeries","_util","createHashMap","each","map","isArray","isString","isObject","isTypedArray","isArrayLike","extend","assert","Source","_sourceType","SOURCE_FORMAT_ORIGINAL","SOURCE_FORMAT_ARRAY_ROWS","SOURCE_FORMAT_OBJECT_ROWS","SOURCE_FORMAT_KEYED_COLUMNS","SOURCE_FORMAT_UNKNOWN","SOURCE_FORMAT_TYPED_ARRAY","SERIES_LAYOUT_BY_ROW","inner","detectSourceFormat","datasetModel","data","option","source","sourceFormat","length","i","len","item","key","hasOwnProperty","Error","getSource","seriesModel","resetSourceDefaulter","ecModel","datasetMap","prepareSource","seriesOption","fromDataset","seriesLayoutBy","sourceHeader","dimensionsDefine","dimensions","getDatasetModel","datasetOption","completeResult","completeBySourceData","encodeDefine","encode","makeDefaultEncode","startIndex","dimensionsDetectCount","normalizeDimensionsDefine","findPotentialName","arrayRowsTravelFirst","val","index","objectRowsCollectDimensions","colArr","push","value0","potentialNameDimIndex","dim","idx","name","nameMap","displayName","exist","get","set","count","cb","maxLoop","Infinity","firstIndex","obj","value","coordSysDefine","encodeItemName","encodeSeriesName","seriesType","subType","nSeriesMap","cSeriesMap","uid","datasetRecord","categoryWayDim","valueWayDim","coordSysDims","coordDim","firstCategoryDimIndex","dataDim","categoryAxisMap","firstNotOrdinal","doGuessOrdinal","nameDimIndex","Math","max","itemName","seriesName","thisData","getComponent","datasetIndex","guessOrdinal","dimIndex","result","dimName","sample","detectValue","row","isFinite","exports"],"mappings":"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","sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\nvar _config = require(\"../../config\");\n\nvar __DEV__ = _config.__DEV__;\n\nvar _model = require(\"../../util/model\");\n\nvar makeInner = _model.makeInner;\nvar getDataItemValue = _model.getDataItemValue;\n\nvar _referHelper = require(\"../../model/referHelper\");\n\nvar getCoordSysDefineBySeries = _referHelper.getCoordSysDefineBySeries;\n\nvar _util = require(\"zrender/lib/core/util\");\n\nvar createHashMap = _util.createHashMap;\nvar each = _util.each;\nvar map = _util.map;\nvar isArray = _util.isArray;\nvar isString = _util.isString;\nvar isObject = _util.isObject;\nvar isTypedArray = _util.isTypedArray;\nvar isArrayLike = _util.isArrayLike;\nvar extend = _util.extend;\nvar assert = _util.assert;\n\nvar Source = require(\"../Source\");\n\nvar _sourceType = require(\"./sourceType\");\n\nvar SOURCE_FORMAT_ORIGINAL = _sourceType.SOURCE_FORMAT_ORIGINAL;\nvar SOURCE_FORMAT_ARRAY_ROWS = _sourceType.SOURCE_FORMAT_ARRAY_ROWS;\nvar SOURCE_FORMAT_OBJECT_ROWS = _sourceType.SOURCE_FORMAT_OBJECT_ROWS;\nvar SOURCE_FORMAT_KEYED_COLUMNS = _sourceType.SOURCE_FORMAT_KEYED_COLUMNS;\nvar SOURCE_FORMAT_UNKNOWN = _sourceType.SOURCE_FORMAT_UNKNOWN;\nvar SOURCE_FORMAT_TYPED_ARRAY = _sourceType.SOURCE_FORMAT_TYPED_ARRAY;\nvar SERIES_LAYOUT_BY_ROW = _sourceType.SERIES_LAYOUT_BY_ROW;\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar inner = makeInner();\n/**\n * @see {module:echarts/data/Source}\n * @param {module:echarts/component/dataset/DatasetModel} datasetModel\n * @return {string} sourceFormat\n */\n\nfunction detectSourceFormat(datasetModel) {\n  var data = datasetModel.option.source;\n  var sourceFormat = SOURCE_FORMAT_UNKNOWN;\n\n  if (isTypedArray(data)) {\n    sourceFormat = SOURCE_FORMAT_TYPED_ARRAY;\n  } else if (isArray(data)) {\n    // FIXME Whether tolerate null in top level array?\n    if (data.length === 0) {\n      sourceFormat = SOURCE_FORMAT_ARRAY_ROWS;\n    }\n\n    for (var i = 0, len = data.length; i < len; i++) {\n      var item = data[i];\n\n      if (item == null) {\n        continue;\n      } else if (isArray(item)) {\n        sourceFormat = SOURCE_FORMAT_ARRAY_ROWS;\n        break;\n      } else if (isObject(item)) {\n        sourceFormat = SOURCE_FORMAT_OBJECT_ROWS;\n        break;\n      }\n    }\n  } else if (isObject(data)) {\n    for (var key in data) {\n      if (data.hasOwnProperty(key) && isArrayLike(data[key])) {\n        sourceFormat = SOURCE_FORMAT_KEYED_COLUMNS;\n        break;\n      }\n    }\n  } else if (data != null) {\n    throw new Error('Invalid data');\n  }\n\n  inner(datasetModel).sourceFormat = sourceFormat;\n}\n/**\n * [Scenarios]:\n * (1) Provide source data directly:\n *     series: {\n *         encode: {...},\n *         dimensions: [...]\n *         seriesLayoutBy: 'row',\n *         data: [[...]]\n *     }\n * (2) Refer to datasetModel.\n *     series: [{\n *         encode: {...}\n *         // Ignore datasetIndex means `datasetIndex: 0`\n *         // and the dimensions defination in dataset is used\n *     }, {\n *         encode: {...},\n *         seriesLayoutBy: 'column',\n *         datasetIndex: 1\n *     }]\n *\n * Get data from series itself or datset.\n * @return {module:echarts/data/Source} source\n */\n\n\nfunction getSource(seriesModel) {\n  return inner(seriesModel).source;\n}\n/**\n * MUST be called before mergeOption of all series.\n * @param {module:echarts/model/Global} ecModel\n */\n\n\nfunction resetSourceDefaulter(ecModel) {\n  // `datasetMap` is used to make default encode.\n  inner(ecModel).datasetMap = createHashMap();\n}\n/**\n * [Caution]:\n * MUST be called after series option merged and\n * before \"series.getInitailData()\" called.\n *\n * [The rule of making default encode]:\n * Category axis (if exists) alway map to the first dimension.\n * Each other axis occupies a subsequent dimension.\n *\n * [Why make default encode]:\n * Simplify the typing of encode in option, avoiding the case like that:\n * series: [{encode: {x: 0, y: 1}}, {encode: {x: 0, y: 2}}, {encode: {x: 0, y: 3}}],\n * where the \"y\" have to be manually typed as \"1, 2, 3, ...\".\n *\n * @param {module:echarts/model/Series} seriesModel\n */\n\n\nfunction prepareSource(seriesModel) {\n  var seriesOption = seriesModel.option;\n  var data = seriesOption.data;\n  var sourceFormat = isTypedArray(data) ? SOURCE_FORMAT_TYPED_ARRAY : SOURCE_FORMAT_ORIGINAL;\n  var fromDataset = false;\n  var seriesLayoutBy = seriesOption.seriesLayoutBy;\n  var sourceHeader = seriesOption.sourceHeader;\n  var dimensionsDefine = seriesOption.dimensions;\n  var datasetModel = getDatasetModel(seriesModel);\n\n  if (datasetModel) {\n    var datasetOption = datasetModel.option;\n    data = datasetOption.source;\n    sourceFormat = inner(datasetModel).sourceFormat;\n    fromDataset = true; // These settings from series has higher priority.\n\n    seriesLayoutBy = seriesLayoutBy || datasetOption.seriesLayoutBy;\n    sourceHeader == null && (sourceHeader = datasetOption.sourceHeader);\n    dimensionsDefine = dimensionsDefine || datasetOption.dimensions;\n  }\n\n  var completeResult = completeBySourceData(data, sourceFormat, seriesLayoutBy, sourceHeader, dimensionsDefine); // Note: dataset option does not have `encode`.\n\n  var encodeDefine = seriesOption.encode;\n\n  if (!encodeDefine && datasetModel) {\n    encodeDefine = makeDefaultEncode(seriesModel, datasetModel, data, sourceFormat, seriesLayoutBy, completeResult);\n  }\n\n  inner(seriesModel).source = new Source({\n    data: data,\n    fromDataset: fromDataset,\n    seriesLayoutBy: seriesLayoutBy,\n    sourceFormat: sourceFormat,\n    dimensionsDefine: completeResult.dimensionsDefine,\n    startIndex: completeResult.startIndex,\n    dimensionsDetectCount: completeResult.dimensionsDetectCount,\n    encodeDefine: encodeDefine\n  });\n} // return {startIndex, dimensionsDefine, dimensionsCount}\n\n\nfunction completeBySourceData(data, sourceFormat, seriesLayoutBy, sourceHeader, dimensionsDefine) {\n  if (!data) {\n    return {\n      dimensionsDefine: normalizeDimensionsDefine(dimensionsDefine)\n    };\n  }\n\n  var dimensionsDetectCount;\n  var startIndex;\n  var findPotentialName;\n\n  if (sourceFormat === SOURCE_FORMAT_ARRAY_ROWS) {\n    // Rule: Most of the first line are string: it is header.\n    // Caution: consider a line with 5 string and 1 number,\n    // it still can not be sure it is a head, because the\n    // 5 string may be 5 values of category columns.\n    if (sourceHeader === 'auto' || sourceHeader == null) {\n      arrayRowsTravelFirst(function (val) {\n        // '-' is regarded as null/undefined.\n        if (val != null && val !== '-') {\n          if (isString(val)) {\n            startIndex == null && (startIndex = 1);\n          } else {\n            startIndex = 0;\n          }\n        } // 10 is an experience number, avoid long loop.\n\n      }, seriesLayoutBy, data, 10);\n    } else {\n      startIndex = sourceHeader ? 1 : 0;\n    }\n\n    if (!dimensionsDefine && startIndex === 1) {\n      dimensionsDefine = [];\n      arrayRowsTravelFirst(function (val, index) {\n        dimensionsDefine[index] = val != null ? val : '';\n      }, seriesLayoutBy, data);\n    }\n\n    dimensionsDetectCount = dimensionsDefine ? dimensionsDefine.length : seriesLayoutBy === SERIES_LAYOUT_BY_ROW ? data.length : data[0] ? data[0].length : null;\n  } else if (sourceFormat === SOURCE_FORMAT_OBJECT_ROWS) {\n    if (!dimensionsDefine) {\n      dimensionsDefine = objectRowsCollectDimensions(data);\n      findPotentialName = true;\n    }\n  } else if (sourceFormat === SOURCE_FORMAT_KEYED_COLUMNS) {\n    if (!dimensionsDefine) {\n      dimensionsDefine = [];\n      findPotentialName = true;\n      each(data, function (colArr, key) {\n        dimensionsDefine.push(key);\n      });\n    }\n  } else if (sourceFormat === SOURCE_FORMAT_ORIGINAL) {\n    var value0 = getDataItemValue(data[0]);\n    dimensionsDetectCount = isArray(value0) && value0.length || 1;\n  } else if (sourceFormat === SOURCE_FORMAT_TYPED_ARRAY) {}\n\n  var potentialNameDimIndex;\n\n  if (findPotentialName) {\n    each(dimensionsDefine, function (dim, idx) {\n      if ((isObject(dim) ? dim.name : dim) === 'name') {\n        potentialNameDimIndex = idx;\n      }\n    });\n  }\n\n  return {\n    startIndex: startIndex,\n    dimensionsDefine: normalizeDimensionsDefine(dimensionsDefine),\n    dimensionsDetectCount: dimensionsDetectCount,\n    potentialNameDimIndex: potentialNameDimIndex // TODO: potentialIdDimIdx\n\n  };\n} // Consider dimensions defined like ['A', 'price', 'B', 'price', 'C', 'price'],\n// which is reasonable. But dimension name is duplicated.\n// Returns undefined or an array contains only object without null/undefiend or string.\n\n\nfunction normalizeDimensionsDefine(dimensionsDefine) {\n  if (!dimensionsDefine) {\n    // The meaning of null/undefined is different from empty array.\n    return;\n  }\n\n  var nameMap = createHashMap();\n  return map(dimensionsDefine, function (item, index) {\n    item = extend({}, isObject(item) ? item : {\n      name: item\n    }); // User can set null in dimensions.\n    // We dont auto specify name, othewise a given name may\n    // cause it be refered unexpectedly.\n\n    if (item.name == null) {\n      return item;\n    } // Also consider number form like 2012.\n\n\n    item.name += ''; // User may also specify displayName.\n    // displayName will always exists except user not\n    // specified or dim name is not specified or detected.\n    // (A auto generated dim name will not be used as\n    // displayName).\n\n    if (item.displayName == null) {\n      item.displayName = item.name;\n    }\n\n    var exist = nameMap.get(item.name);\n\n    if (!exist) {\n      nameMap.set(item.name, {\n        count: 1\n      });\n    } else {\n      item.name += '-' + exist.count++;\n    }\n\n    return item;\n  });\n}\n\nfunction arrayRowsTravelFirst(cb, seriesLayoutBy, data, maxLoop) {\n  maxLoop == null && (maxLoop = Infinity);\n\n  if (seriesLayoutBy === SERIES_LAYOUT_BY_ROW) {\n    for (var i = 0; i < data.length && i < maxLoop; i++) {\n      cb(data[i] ? data[i][0] : null, i);\n    }\n  } else {\n    var value0 = data[0] || [];\n\n    for (var i = 0; i < value0.length && i < maxLoop; i++) {\n      cb(value0[i], i);\n    }\n  }\n}\n\nfunction objectRowsCollectDimensions(data) {\n  var firstIndex = 0;\n  var obj;\n\n  while (firstIndex < data.length && !(obj = data[firstIndex++])) {} // jshint ignore: line\n\n\n  if (obj) {\n    var dimensions = [];\n    each(obj, function (value, key) {\n      dimensions.push(key);\n    });\n    return dimensions;\n  }\n} // ??? TODO merge to completedimensions, where also has\n// default encode making logic. And the default rule\n// should depends on series? consider 'map'.\n\n\nfunction makeDefaultEncode(seriesModel, datasetModel, data, sourceFormat, seriesLayoutBy, completeResult) {\n  var coordSysDefine = getCoordSysDefineBySeries(seriesModel);\n  var encode = {}; // var encodeTooltip = [];\n  // var encodeLabel = [];\n\n  var encodeItemName = [];\n  var encodeSeriesName = [];\n  var seriesType = seriesModel.subType; // ??? TODO refactor: provide by series itself.\n  // Consider the case: 'map' series is based on geo coordSys,\n  // 'graph', 'heatmap' can be based on cartesian. But can not\n  // give default rule simply here.\n\n  var nSeriesMap = createHashMap(['pie', 'map', 'funnel']);\n  var cSeriesMap = createHashMap(['line', 'bar', 'pictorialBar', 'scatter', 'effectScatter', 'candlestick', 'boxplot']); // Usually in this case series will use the first data\n  // dimension as the \"value\" dimension, or other default\n  // processes respectively.\n\n  if (coordSysDefine && cSeriesMap.get(seriesType) != null) {\n    var ecModel = seriesModel.ecModel;\n    var datasetMap = inner(ecModel).datasetMap;\n    var key = datasetModel.uid + '_' + seriesLayoutBy;\n    var datasetRecord = datasetMap.get(key) || datasetMap.set(key, {\n      categoryWayDim: 1,\n      valueWayDim: 0\n    }); // TODO\n    // Auto detect first time axis and do arrangement.\n\n    each(coordSysDefine.coordSysDims, function (coordDim) {\n      // In value way.\n      if (coordSysDefine.firstCategoryDimIndex == null) {\n        var dataDim = datasetRecord.valueWayDim++;\n        encode[coordDim] = dataDim; // ??? TODO give a better default series name rule?\n        // especially when encode x y specified.\n        // consider: when mutiple series share one dimension\n        // category axis, series name should better use\n        // the other dimsion name. On the other hand, use\n        // both dimensions name.\n\n        encodeSeriesName.push(dataDim); // encodeTooltip.push(dataDim);\n        // encodeLabel.push(dataDim);\n      } // In category way, category axis.\n      else if (coordSysDefine.categoryAxisMap.get(coordDim)) {\n          encode[coordDim] = 0;\n          encodeItemName.push(0);\n        } // In category way, non-category axis.\n        else {\n            var dataDim = datasetRecord.categoryWayDim++;\n            encode[coordDim] = dataDim; // encodeTooltip.push(dataDim);\n            // encodeLabel.push(dataDim);\n\n            encodeSeriesName.push(dataDim);\n          }\n    });\n  } // Do not make a complex rule! Hard to code maintain and not necessary.\n  // ??? TODO refactor: provide by series itself.\n  // [{name: ..., value: ...}, ...] like:\n  else if (nSeriesMap.get(seriesType) != null) {\n      // Find the first not ordinal. (5 is an experience value)\n      var firstNotOrdinal;\n\n      for (var i = 0; i < 5 && firstNotOrdinal == null; i++) {\n        if (!doGuessOrdinal(data, sourceFormat, seriesLayoutBy, completeResult.dimensionsDefine, completeResult.startIndex, i)) {\n          firstNotOrdinal = i;\n        }\n      }\n\n      if (firstNotOrdinal != null) {\n        encode.value = firstNotOrdinal;\n        var nameDimIndex = completeResult.potentialNameDimIndex || Math.max(firstNotOrdinal - 1, 0); // By default, label use itemName in charts.\n        // So we dont set encodeLabel here.\n\n        encodeSeriesName.push(nameDimIndex);\n        encodeItemName.push(nameDimIndex); // encodeTooltip.push(firstNotOrdinal);\n      }\n    } // encodeTooltip.length && (encode.tooltip = encodeTooltip);\n  // encodeLabel.length && (encode.label = encodeLabel);\n\n\n  encodeItemName.length && (encode.itemName = encodeItemName);\n  encodeSeriesName.length && (encode.seriesName = encodeSeriesName);\n  return encode;\n}\n/**\n * If return null/undefined, indicate that should not use datasetModel.\n */\n\n\nfunction getDatasetModel(seriesModel) {\n  var option = seriesModel.option; // Caution: consider the scenario:\n  // A dataset is declared and a series is not expected to use the dataset,\n  // and at the beginning `setOption({series: { noData })` (just prepare other\n  // option but no data), then `setOption({series: {data: [...]}); In this case,\n  // the user should set an empty array to avoid that dataset is used by default.\n\n  var thisData = option.data;\n\n  if (!thisData) {\n    return seriesModel.ecModel.getComponent('dataset', option.datasetIndex || 0);\n  }\n}\n/**\n * The rule should not be complex, otherwise user might not\n * be able to known where the data is wrong.\n * The code is ugly, but how to make it neat?\n *\n * @param {module:echars/data/Source} source\n * @param {number} dimIndex\n * @return {boolean} Whether ordinal.\n */\n\n\nfunction guessOrdinal(source, dimIndex) {\n  return doGuessOrdinal(source.data, source.sourceFormat, source.seriesLayoutBy, source.dimensionsDefine, source.startIndex, dimIndex);\n} // dimIndex may be overflow source data.\n\n\nfunction doGuessOrdinal(data, sourceFormat, seriesLayoutBy, dimensionsDefine, startIndex, dimIndex) {\n  var result; // Experience value.\n\n  var maxLoop = 5;\n\n  if (isTypedArray(data)) {\n    return false;\n  } // When sourceType is 'objectRows' or 'keyedColumns', dimensionsDefine\n  // always exists in source.\n\n\n  var dimName;\n\n  if (dimensionsDefine) {\n    dimName = dimensionsDefine[dimIndex];\n    dimName = isObject(dimName) ? dimName.name : dimName;\n  }\n\n  if (sourceFormat === SOURCE_FORMAT_ARRAY_ROWS) {\n    if (seriesLayoutBy === SERIES_LAYOUT_BY_ROW) {\n      var sample = data[dimIndex];\n\n      for (var i = 0; i < (sample || []).length && i < maxLoop; i++) {\n        if ((result = detectValue(sample[startIndex + i])) != null) {\n          return result;\n        }\n      }\n    } else {\n      for (var i = 0; i < data.length && i < maxLoop; i++) {\n        var row = data[startIndex + i];\n\n        if (row && (result = detectValue(row[dimIndex])) != null) {\n          return result;\n        }\n      }\n    }\n  } else if (sourceFormat === SOURCE_FORMAT_OBJECT_ROWS) {\n    if (!dimName) {\n      return;\n    }\n\n    for (var i = 0; i < data.length && i < maxLoop; i++) {\n      var item = data[i];\n\n      if (item && (result = detectValue(item[dimName])) != null) {\n        return result;\n      }\n    }\n  } else if (sourceFormat === SOURCE_FORMAT_KEYED_COLUMNS) {\n    if (!dimName) {\n      return;\n    }\n\n    var sample = data[dimName];\n\n    if (!sample || isTypedArray(sample)) {\n      return false;\n    }\n\n    for (var i = 0; i < sample.length && i < maxLoop; i++) {\n      if ((result = detectValue(sample[i])) != null) {\n        return result;\n      }\n    }\n  } else if (sourceFormat === SOURCE_FORMAT_ORIGINAL) {\n    for (var i = 0; i < data.length && i < maxLoop; i++) {\n      var item = data[i];\n      var val = getDataItemValue(item);\n\n      if (!isArray(val)) {\n        return false;\n      }\n\n      if ((result = detectValue(val[dimIndex])) != null) {\n        return result;\n      }\n    }\n  }\n\n  function detectValue(val) {\n    // Consider usage convenience, '1', '2' will be treated as \"number\".\n    // `isFinit('')` get `true`.\n    if (val != null && isFinite(val) && val !== '') {\n      return false;\n    } else if (isString(val) && val !== '-') {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nexports.detectSourceFormat = detectSourceFormat;\nexports.getSource = getSource;\nexports.resetSourceDefaulter = resetSourceDefaulter;\nexports.prepareSource = prepareSource;\nexports.guessOrdinal = guessOrdinal;"]},"metadata":{},"sourceType":"script"}