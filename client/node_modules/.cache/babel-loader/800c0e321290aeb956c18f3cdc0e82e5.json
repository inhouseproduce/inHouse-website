{"ast":null,"code":"var BoundingRect = require(\"../core/BoundingRect\");\n\nvar imageHelper = require(\"../graphic/helper/image\");\n\nvar _util = require(\"../core/util\");\n\nvar getContext = _util.getContext;\nvar extend = _util.extend;\nvar retrieve2 = _util.retrieve2;\nvar retrieve3 = _util.retrieve3;\nvar trim = _util.trim;\nvar textWidthCache = {};\nvar textWidthCacheCounter = 0;\nvar TEXT_CACHE_MAX = 5000;\nvar STYLE_REG = /\\{([a-zA-Z0-9_]+)\\|([^}]*)\\}/g;\nvar DEFAULT_FONT = '12px sans-serif'; // Avoid assign to an exported variable, for transforming to cjs.\n\nvar methods = {};\n\nfunction $override(name, fn) {\n  methods[name] = fn;\n}\n/**\n * @public\n * @param {string} text\n * @param {string} font\n * @return {number} width\n */\n\n\nfunction getWidth(text, font) {\n  font = font || DEFAULT_FONT;\n  var key = text + ':' + font;\n\n  if (textWidthCache[key]) {\n    return textWidthCache[key];\n  }\n\n  var textLines = (text + '').split('\\n');\n  var width = 0;\n\n  for (var i = 0, l = textLines.length; i < l; i++) {\n    // textContain.measureText may be overrided in SVG or VML\n    width = Math.max(measureText(textLines[i], font).width, width);\n  }\n\n  if (textWidthCacheCounter > TEXT_CACHE_MAX) {\n    textWidthCacheCounter = 0;\n    textWidthCache = {};\n  }\n\n  textWidthCacheCounter++;\n  textWidthCache[key] = width;\n  return width;\n}\n/**\n * @public\n * @param {string} text\n * @param {string} font\n * @param {string} [textAlign='left']\n * @param {string} [textVerticalAlign='top']\n * @param {Array.<number>} [textPadding]\n * @param {Object} [rich]\n * @param {Object} [truncate]\n * @return {Object} {x, y, width, height, lineHeight}\n */\n\n\nfunction getBoundingRect(text, font, textAlign, textVerticalAlign, textPadding, textLineHeight, rich, truncate) {\n  return rich ? getRichTextRect(text, font, textAlign, textVerticalAlign, textPadding, textLineHeight, rich, truncate) : getPlainTextRect(text, font, textAlign, textVerticalAlign, textPadding, textLineHeight, truncate);\n}\n\nfunction getPlainTextRect(text, font, textAlign, textVerticalAlign, textPadding, textLineHeight, truncate) {\n  var contentBlock = parsePlainText(text, font, textPadding, textLineHeight, truncate);\n  var outerWidth = getWidth(text, font);\n\n  if (textPadding) {\n    outerWidth += textPadding[1] + textPadding[3];\n  }\n\n  var outerHeight = contentBlock.outerHeight;\n  var x = adjustTextX(0, outerWidth, textAlign);\n  var y = adjustTextY(0, outerHeight, textVerticalAlign);\n  var rect = new BoundingRect(x, y, outerWidth, outerHeight);\n  rect.lineHeight = contentBlock.lineHeight;\n  return rect;\n}\n\nfunction getRichTextRect(text, font, textAlign, textVerticalAlign, textPadding, textLineHeight, rich, truncate) {\n  var contentBlock = parseRichText(text, {\n    rich: rich,\n    truncate: truncate,\n    font: font,\n    textAlign: textAlign,\n    textPadding: textPadding,\n    textLineHeight: textLineHeight\n  });\n  var outerWidth = contentBlock.outerWidth;\n  var outerHeight = contentBlock.outerHeight;\n  var x = adjustTextX(0, outerWidth, textAlign);\n  var y = adjustTextY(0, outerHeight, textVerticalAlign);\n  return new BoundingRect(x, y, outerWidth, outerHeight);\n}\n/**\n * @public\n * @param {number} x\n * @param {number} width\n * @param {string} [textAlign='left']\n * @return {number} Adjusted x.\n */\n\n\nfunction adjustTextX(x, width, textAlign) {\n  // FIXME Right to left language\n  if (textAlign === 'right') {\n    x -= width;\n  } else if (textAlign === 'center') {\n    x -= width / 2;\n  }\n\n  return x;\n}\n/**\n * @public\n * @param {number} y\n * @param {number} height\n * @param {string} [textVerticalAlign='top']\n * @return {number} Adjusted y.\n */\n\n\nfunction adjustTextY(y, height, textVerticalAlign) {\n  if (textVerticalAlign === 'middle') {\n    y -= height / 2;\n  } else if (textVerticalAlign === 'bottom') {\n    y -= height;\n  }\n\n  return y;\n}\n/**\n * @public\n * @param {stirng} textPosition\n * @param {Object} rect {x, y, width, height}\n * @param {number} distance\n * @return {Object} {x, y, textAlign, textVerticalAlign}\n */\n\n\nfunction adjustTextPositionOnRect(textPosition, rect, distance) {\n  var x = rect.x;\n  var y = rect.y;\n  var height = rect.height;\n  var width = rect.width;\n  var halfHeight = height / 2;\n  var textAlign = 'left';\n  var textVerticalAlign = 'top';\n\n  switch (textPosition) {\n    case 'left':\n      x -= distance;\n      y += halfHeight;\n      textAlign = 'right';\n      textVerticalAlign = 'middle';\n      break;\n\n    case 'right':\n      x += distance + width;\n      y += halfHeight;\n      textVerticalAlign = 'middle';\n      break;\n\n    case 'top':\n      x += width / 2;\n      y -= distance;\n      textAlign = 'center';\n      textVerticalAlign = 'bottom';\n      break;\n\n    case 'bottom':\n      x += width / 2;\n      y += height + distance;\n      textAlign = 'center';\n      break;\n\n    case 'inside':\n      x += width / 2;\n      y += halfHeight;\n      textAlign = 'center';\n      textVerticalAlign = 'middle';\n      break;\n\n    case 'insideLeft':\n      x += distance;\n      y += halfHeight;\n      textVerticalAlign = 'middle';\n      break;\n\n    case 'insideRight':\n      x += width - distance;\n      y += halfHeight;\n      textAlign = 'right';\n      textVerticalAlign = 'middle';\n      break;\n\n    case 'insideTop':\n      x += width / 2;\n      y += distance;\n      textAlign = 'center';\n      break;\n\n    case 'insideBottom':\n      x += width / 2;\n      y += height - distance;\n      textAlign = 'center';\n      textVerticalAlign = 'bottom';\n      break;\n\n    case 'insideTopLeft':\n      x += distance;\n      y += distance;\n      break;\n\n    case 'insideTopRight':\n      x += width - distance;\n      y += distance;\n      textAlign = 'right';\n      break;\n\n    case 'insideBottomLeft':\n      x += distance;\n      y += height - distance;\n      textVerticalAlign = 'bottom';\n      break;\n\n    case 'insideBottomRight':\n      x += width - distance;\n      y += height - distance;\n      textAlign = 'right';\n      textVerticalAlign = 'bottom';\n      break;\n  }\n\n  return {\n    x: x,\n    y: y,\n    textAlign: textAlign,\n    textVerticalAlign: textVerticalAlign\n  };\n}\n/**\n * Show ellipsis if overflow.\n *\n * @public\n * @param  {string} text\n * @param  {string} containerWidth\n * @param  {string} font\n * @param  {number} [ellipsis='...']\n * @param  {Object} [options]\n * @param  {number} [options.maxIterations=3]\n * @param  {number} [options.minChar=0] If truncate result are less\n *                  then minChar, ellipsis will not show, which is\n *                  better for user hint in some cases.\n * @param  {number} [options.placeholder=''] When all truncated, use the placeholder.\n * @return {string}\n */\n\n\nfunction truncateText(text, containerWidth, font, ellipsis, options) {\n  if (!containerWidth) {\n    return '';\n  }\n\n  var textLines = (text + '').split('\\n');\n  options = prepareTruncateOptions(containerWidth, font, ellipsis, options); // FIXME\n  // It is not appropriate that every line has '...' when truncate multiple lines.\n\n  for (var i = 0, len = textLines.length; i < len; i++) {\n    textLines[i] = truncateSingleLine(textLines[i], options);\n  }\n\n  return textLines.join('\\n');\n}\n\nfunction prepareTruncateOptions(containerWidth, font, ellipsis, options) {\n  options = extend({}, options);\n  options.font = font;\n  var ellipsis = retrieve2(ellipsis, '...');\n  options.maxIterations = retrieve2(options.maxIterations, 2);\n  var minChar = options.minChar = retrieve2(options.minChar, 0); // FIXME\n  // Other languages?\n\n  options.cnCharWidth = getWidth('国', font); // FIXME\n  // Consider proportional font?\n\n  var ascCharWidth = options.ascCharWidth = getWidth('a', font);\n  options.placeholder = retrieve2(options.placeholder, ''); // Example 1: minChar: 3, text: 'asdfzxcv', truncate result: 'asdf', but not: 'a...'.\n  // Example 2: minChar: 3, text: '维度', truncate result: '维', but not: '...'.\n\n  var contentWidth = containerWidth = Math.max(0, containerWidth - 1); // Reserve some gap.\n\n  for (var i = 0; i < minChar && contentWidth >= ascCharWidth; i++) {\n    contentWidth -= ascCharWidth;\n  }\n\n  var ellipsisWidth = getWidth(ellipsis, font);\n\n  if (ellipsisWidth > contentWidth) {\n    ellipsis = '';\n    ellipsisWidth = 0;\n  }\n\n  contentWidth = containerWidth - ellipsisWidth;\n  options.ellipsis = ellipsis;\n  options.ellipsisWidth = ellipsisWidth;\n  options.contentWidth = contentWidth;\n  options.containerWidth = containerWidth;\n  return options;\n}\n\nfunction truncateSingleLine(textLine, options) {\n  var containerWidth = options.containerWidth;\n  var font = options.font;\n  var contentWidth = options.contentWidth;\n\n  if (!containerWidth) {\n    return '';\n  }\n\n  var lineWidth = getWidth(textLine, font);\n\n  if (lineWidth <= containerWidth) {\n    return textLine;\n  }\n\n  for (var j = 0;; j++) {\n    if (lineWidth <= contentWidth || j >= options.maxIterations) {\n      textLine += options.ellipsis;\n      break;\n    }\n\n    var subLength = j === 0 ? estimateLength(textLine, contentWidth, options.ascCharWidth, options.cnCharWidth) : lineWidth > 0 ? Math.floor(textLine.length * contentWidth / lineWidth) : 0;\n    textLine = textLine.substr(0, subLength);\n    lineWidth = getWidth(textLine, font);\n  }\n\n  if (textLine === '') {\n    textLine = options.placeholder;\n  }\n\n  return textLine;\n}\n\nfunction estimateLength(text, contentWidth, ascCharWidth, cnCharWidth) {\n  var width = 0;\n  var i = 0;\n\n  for (var len = text.length; i < len && width < contentWidth; i++) {\n    var charCode = text.charCodeAt(i);\n    width += 0 <= charCode && charCode <= 127 ? ascCharWidth : cnCharWidth;\n  }\n\n  return i;\n}\n/**\n * @public\n * @param {string} font\n * @return {number} line height\n */\n\n\nfunction getLineHeight(font) {\n  // FIXME A rough approach.\n  return getWidth('国', font);\n}\n/**\n * @public\n * @param {string} text\n * @param {string} font\n * @return {Object} width\n */\n\n\nfunction measureText(text, font) {\n  return methods.measureText(text, font);\n} // Avoid assign to an exported variable, for transforming to cjs.\n\n\nmethods.measureText = function (text, font) {\n  var ctx = getContext();\n  ctx.font = font || DEFAULT_FONT;\n  return ctx.measureText(text);\n};\n/**\n * @public\n * @param {string} text\n * @param {string} font\n * @param {Object} [truncate]\n * @return {Object} block: {lineHeight, lines, height, outerHeight}\n *  Notice: for performance, do not calculate outerWidth util needed.\n */\n\n\nfunction parsePlainText(text, font, padding, textLineHeight, truncate) {\n  text != null && (text += '');\n  var lineHeight = retrieve2(textLineHeight, getLineHeight(font));\n  var lines = text ? text.split('\\n') : [];\n  var height = lines.length * lineHeight;\n  var outerHeight = height;\n\n  if (padding) {\n    outerHeight += padding[0] + padding[2];\n  }\n\n  if (text && truncate) {\n    var truncOuterHeight = truncate.outerHeight;\n    var truncOuterWidth = truncate.outerWidth;\n\n    if (truncOuterHeight != null && outerHeight > truncOuterHeight) {\n      text = '';\n      lines = [];\n    } else if (truncOuterWidth != null) {\n      var options = prepareTruncateOptions(truncOuterWidth - (padding ? padding[1] + padding[3] : 0), font, truncate.ellipsis, {\n        minChar: truncate.minChar,\n        placeholder: truncate.placeholder\n      }); // FIXME\n      // It is not appropriate that every line has '...' when truncate multiple lines.\n\n      for (var i = 0, len = lines.length; i < len; i++) {\n        lines[i] = truncateSingleLine(lines[i], options);\n      }\n    }\n  }\n\n  return {\n    lines: lines,\n    height: height,\n    outerHeight: outerHeight,\n    lineHeight: lineHeight\n  };\n}\n/**\n * For example: 'some text {a|some text}other text{b|some text}xxx{c|}xxx'\n * Also consider 'bbbb{a|xxx\\nzzz}xxxx\\naaaa'.\n *\n * @public\n * @param {string} text\n * @param {Object} style\n * @return {Object} block\n * {\n *      width,\n *      height,\n *      lines: [{\n *          lineHeight,\n *          width,\n *          tokens: [[{\n *              styleName,\n *              text,\n *              width,      // include textPadding\n *              height,     // include textPadding\n *              textWidth, // pure text width\n *              textHeight, // pure text height\n *              lineHeihgt,\n *              font,\n *              textAlign,\n *              textVerticalAlign\n *          }], [...], ...]\n *      }, ...]\n * }\n * If styleName is undefined, it is plain text.\n */\n\n\nfunction parseRichText(text, style) {\n  var contentBlock = {\n    lines: [],\n    width: 0,\n    height: 0\n  };\n  text != null && (text += '');\n\n  if (!text) {\n    return contentBlock;\n  }\n\n  var lastIndex = STYLE_REG.lastIndex = 0;\n  var result;\n\n  while ((result = STYLE_REG.exec(text)) != null) {\n    var matchedIndex = result.index;\n\n    if (matchedIndex > lastIndex) {\n      pushTokens(contentBlock, text.substring(lastIndex, matchedIndex));\n    }\n\n    pushTokens(contentBlock, result[2], result[1]);\n    lastIndex = STYLE_REG.lastIndex;\n  }\n\n  if (lastIndex < text.length) {\n    pushTokens(contentBlock, text.substring(lastIndex, text.length));\n  }\n\n  var lines = contentBlock.lines;\n  var contentHeight = 0;\n  var contentWidth = 0; // For `textWidth: 100%`\n\n  var pendingList = [];\n  var stlPadding = style.textPadding;\n  var truncate = style.truncate;\n  var truncateWidth = truncate && truncate.outerWidth;\n  var truncateHeight = truncate && truncate.outerHeight;\n\n  if (stlPadding) {\n    truncateWidth != null && (truncateWidth -= stlPadding[1] + stlPadding[3]);\n    truncateHeight != null && (truncateHeight -= stlPadding[0] + stlPadding[2]);\n  } // Calculate layout info of tokens.\n\n\n  for (var i = 0; i < lines.length; i++) {\n    var line = lines[i];\n    var lineHeight = 0;\n    var lineWidth = 0;\n\n    for (var j = 0; j < line.tokens.length; j++) {\n      var token = line.tokens[j];\n      var tokenStyle = token.styleName && style.rich[token.styleName] || {}; // textPadding should not inherit from style.\n\n      var textPadding = token.textPadding = tokenStyle.textPadding; // textFont has been asigned to font by `normalizeStyle`.\n\n      var font = token.font = tokenStyle.font || style.font; // textHeight can be used when textVerticalAlign is specified in token.\n\n      var tokenHeight = token.textHeight = retrieve2( // textHeight should not be inherited, consider it can be specified\n      // as box height of the block.\n      tokenStyle.textHeight, getLineHeight(font));\n      textPadding && (tokenHeight += textPadding[0] + textPadding[2]);\n      token.height = tokenHeight;\n      token.lineHeight = retrieve3(tokenStyle.textLineHeight, style.textLineHeight, tokenHeight);\n      token.textAlign = tokenStyle && tokenStyle.textAlign || style.textAlign;\n      token.textVerticalAlign = tokenStyle && tokenStyle.textVerticalAlign || 'middle';\n\n      if (truncateHeight != null && contentHeight + token.lineHeight > truncateHeight) {\n        return {\n          lines: [],\n          width: 0,\n          height: 0\n        };\n      }\n\n      token.textWidth = getWidth(token.text, font);\n      var tokenWidth = tokenStyle.textWidth;\n      var tokenWidthNotSpecified = tokenWidth == null || tokenWidth === 'auto'; // Percent width, can be `100%`, can be used in drawing separate\n      // line when box width is needed to be auto.\n\n      if (typeof tokenWidth === 'string' && tokenWidth.charAt(tokenWidth.length - 1) === '%') {\n        token.percentWidth = tokenWidth;\n        pendingList.push(token);\n        tokenWidth = 0; // Do not truncate in this case, because there is no user case\n        // and it is too complicated.\n      } else {\n        if (tokenWidthNotSpecified) {\n          tokenWidth = token.textWidth; // FIXME: If image is not loaded and textWidth is not specified, calling\n          // `getBoundingRect()` will not get correct result.\n\n          var textBackgroundColor = tokenStyle.textBackgroundColor;\n          var bgImg = textBackgroundColor && textBackgroundColor.image; // Use cases:\n          // (1) If image is not loaded, it will be loaded at render phase and call\n          // `dirty()` and `textBackgroundColor.image` will be replaced with the loaded\n          // image, and then the right size will be calculated here at the next tick.\n          // See `graphic/helper/text.js`.\n          // (2) If image loaded, and `textBackgroundColor.image` is image src string,\n          // use `imageHelper.findExistImage` to find cached image.\n          // `imageHelper.findExistImage` will always be called here before\n          // `imageHelper.createOrUpdateImage` in `graphic/helper/text.js#renderRichText`\n          // which ensures that image will not be rendered before correct size calcualted.\n\n          if (bgImg) {\n            bgImg = imageHelper.findExistImage(bgImg);\n\n            if (imageHelper.isImageReady(bgImg)) {\n              tokenWidth = Math.max(tokenWidth, bgImg.width * tokenHeight / bgImg.height);\n            }\n          }\n        }\n\n        var paddingW = textPadding ? textPadding[1] + textPadding[3] : 0;\n        tokenWidth += paddingW;\n        var remianTruncWidth = truncateWidth != null ? truncateWidth - lineWidth : null;\n\n        if (remianTruncWidth != null && remianTruncWidth < tokenWidth) {\n          if (!tokenWidthNotSpecified || remianTruncWidth < paddingW) {\n            token.text = '';\n            token.textWidth = tokenWidth = 0;\n          } else {\n            token.text = truncateText(token.text, remianTruncWidth - paddingW, font, truncate.ellipsis, {\n              minChar: truncate.minChar\n            });\n            token.textWidth = getWidth(token.text, font);\n            tokenWidth = token.textWidth + paddingW;\n          }\n        }\n      }\n\n      lineWidth += token.width = tokenWidth;\n      tokenStyle && (lineHeight = Math.max(lineHeight, token.lineHeight));\n    }\n\n    line.width = lineWidth;\n    line.lineHeight = lineHeight;\n    contentHeight += lineHeight;\n    contentWidth = Math.max(contentWidth, lineWidth);\n  }\n\n  contentBlock.outerWidth = contentBlock.width = retrieve2(style.textWidth, contentWidth);\n  contentBlock.outerHeight = contentBlock.height = retrieve2(style.textHeight, contentHeight);\n\n  if (stlPadding) {\n    contentBlock.outerWidth += stlPadding[1] + stlPadding[3];\n    contentBlock.outerHeight += stlPadding[0] + stlPadding[2];\n  }\n\n  for (var i = 0; i < pendingList.length; i++) {\n    var token = pendingList[i];\n    var percentWidth = token.percentWidth; // Should not base on outerWidth, because token can not be placed out of padding.\n\n    token.width = parseInt(percentWidth, 10) / 100 * contentWidth;\n  }\n\n  return contentBlock;\n}\n\nfunction pushTokens(block, str, styleName) {\n  var isEmptyStr = str === '';\n  var strs = str.split('\\n');\n  var lines = block.lines;\n\n  for (var i = 0; i < strs.length; i++) {\n    var text = strs[i];\n    var token = {\n      styleName: styleName,\n      text: text,\n      isLineHolder: !text && !isEmptyStr\n    }; // The first token should be appended to the last line.\n\n    if (!i) {\n      var tokens = (lines[lines.length - 1] || (lines[0] = {\n        tokens: []\n      })).tokens; // Consider cases:\n      // (1) ''.split('\\n') => ['', '\\n', ''], the '' at the first item\n      // (which is a placeholder) should be replaced by new token.\n      // (2) A image backage, where token likes {a|}.\n      // (3) A redundant '' will affect textAlign in line.\n      // (4) tokens with the same tplName should not be merged, because\n      // they should be displayed in different box (with border and padding).\n\n      var tokensLen = tokens.length;\n      tokensLen === 1 && tokens[0].isLineHolder ? tokens[0] = token : // Consider text is '', only insert when it is the \"lineHolder\" or\n      // \"emptyStr\". Otherwise a redundant '' will affect textAlign in line.\n      (text || !tokensLen || isEmptyStr) && tokens.push(token);\n    } // Other tokens always start a new line.\n    else {\n        // If there is '', insert it as a placeholder.\n        lines.push({\n          tokens: [token]\n        });\n      }\n  }\n}\n\nfunction makeFont(style) {\n  // FIXME in node-canvas fontWeight is before fontStyle\n  // Use `fontSize` `fontFamily` to check whether font properties are defined.\n  var font = (style.fontSize || style.fontFamily) && [style.fontStyle, style.fontWeight, (style.fontSize || 12) + 'px', // If font properties are defined, `fontFamily` should not be ignored.\n  style.fontFamily || 'sans-serif'].join(' ');\n  return font && trim(font) || style.textFont || style.font;\n}\n\nexports.DEFAULT_FONT = DEFAULT_FONT;\nexports.$override = $override;\nexports.getWidth = getWidth;\nexports.getBoundingRect = getBoundingRect;\nexports.adjustTextX = adjustTextX;\nexports.adjustTextY = adjustTextY;\nexports.adjustTextPositionOnRect = adjustTextPositionOnRect;\nexports.truncateText = truncateText;\nexports.getLineHeight = getLineHeight;\nexports.measureText = measureText;\nexports.parsePlainText = parsePlainText;\nexports.parseRichText = parseRichText;\nexports.makeFont = makeFont;","map":{"version":3,"sources":["/Users/eduardjacobs/Desktop/files/inHouse-website/client/node_modules/zrender/lib/contain/text.js"],"names":["BoundingRect","require","imageHelper","_util","getContext","extend","retrieve2","retrieve3","trim","textWidthCache","textWidthCacheCounter","TEXT_CACHE_MAX","STYLE_REG","DEFAULT_FONT","methods","$override","name","fn","getWidth","text","font","key","textLines","split","width","i","l","length","Math","max","measureText","getBoundingRect","textAlign","textVerticalAlign","textPadding","textLineHeight","rich","truncate","getRichTextRect","getPlainTextRect","contentBlock","parsePlainText","outerWidth","outerHeight","x","adjustTextX","y","adjustTextY","rect","lineHeight","parseRichText","height","adjustTextPositionOnRect","textPosition","distance","halfHeight","truncateText","containerWidth","ellipsis","options","prepareTruncateOptions","len","truncateSingleLine","join","maxIterations","minChar","cnCharWidth","ascCharWidth","placeholder","contentWidth","ellipsisWidth","textLine","lineWidth","j","subLength","estimateLength","floor","substr","charCode","charCodeAt","getLineHeight","ctx","padding","lines","truncOuterHeight","truncOuterWidth","style","lastIndex","result","exec","matchedIndex","index","pushTokens","substring","contentHeight","pendingList","stlPadding","truncateWidth","truncateHeight","line","tokens","token","tokenStyle","styleName","tokenHeight","textHeight","textWidth","tokenWidth","tokenWidthNotSpecified","charAt","percentWidth","push","textBackgroundColor","bgImg","image","findExistImage","isImageReady","paddingW","remianTruncWidth","parseInt","block","str","isEmptyStr","strs","isLineHolder","tokensLen","makeFont","fontSize","fontFamily","fontStyle","fontWeight","textFont","exports"],"mappings":"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","sourcesContent":["var BoundingRect = require(\"../core/BoundingRect\");\n\nvar imageHelper = require(\"../graphic/helper/image\");\n\nvar _util = require(\"../core/util\");\n\nvar getContext = _util.getContext;\nvar extend = _util.extend;\nvar retrieve2 = _util.retrieve2;\nvar retrieve3 = _util.retrieve3;\nvar trim = _util.trim;\nvar textWidthCache = {};\nvar textWidthCacheCounter = 0;\nvar TEXT_CACHE_MAX = 5000;\nvar STYLE_REG = /\\{([a-zA-Z0-9_]+)\\|([^}]*)\\}/g;\nvar DEFAULT_FONT = '12px sans-serif'; // Avoid assign to an exported variable, for transforming to cjs.\n\nvar methods = {};\n\nfunction $override(name, fn) {\n  methods[name] = fn;\n}\n/**\n * @public\n * @param {string} text\n * @param {string} font\n * @return {number} width\n */\n\n\nfunction getWidth(text, font) {\n  font = font || DEFAULT_FONT;\n  var key = text + ':' + font;\n\n  if (textWidthCache[key]) {\n    return textWidthCache[key];\n  }\n\n  var textLines = (text + '').split('\\n');\n  var width = 0;\n\n  for (var i = 0, l = textLines.length; i < l; i++) {\n    // textContain.measureText may be overrided in SVG or VML\n    width = Math.max(measureText(textLines[i], font).width, width);\n  }\n\n  if (textWidthCacheCounter > TEXT_CACHE_MAX) {\n    textWidthCacheCounter = 0;\n    textWidthCache = {};\n  }\n\n  textWidthCacheCounter++;\n  textWidthCache[key] = width;\n  return width;\n}\n/**\n * @public\n * @param {string} text\n * @param {string} font\n * @param {string} [textAlign='left']\n * @param {string} [textVerticalAlign='top']\n * @param {Array.<number>} [textPadding]\n * @param {Object} [rich]\n * @param {Object} [truncate]\n * @return {Object} {x, y, width, height, lineHeight}\n */\n\n\nfunction getBoundingRect(text, font, textAlign, textVerticalAlign, textPadding, textLineHeight, rich, truncate) {\n  return rich ? getRichTextRect(text, font, textAlign, textVerticalAlign, textPadding, textLineHeight, rich, truncate) : getPlainTextRect(text, font, textAlign, textVerticalAlign, textPadding, textLineHeight, truncate);\n}\n\nfunction getPlainTextRect(text, font, textAlign, textVerticalAlign, textPadding, textLineHeight, truncate) {\n  var contentBlock = parsePlainText(text, font, textPadding, textLineHeight, truncate);\n  var outerWidth = getWidth(text, font);\n\n  if (textPadding) {\n    outerWidth += textPadding[1] + textPadding[3];\n  }\n\n  var outerHeight = contentBlock.outerHeight;\n  var x = adjustTextX(0, outerWidth, textAlign);\n  var y = adjustTextY(0, outerHeight, textVerticalAlign);\n  var rect = new BoundingRect(x, y, outerWidth, outerHeight);\n  rect.lineHeight = contentBlock.lineHeight;\n  return rect;\n}\n\nfunction getRichTextRect(text, font, textAlign, textVerticalAlign, textPadding, textLineHeight, rich, truncate) {\n  var contentBlock = parseRichText(text, {\n    rich: rich,\n    truncate: truncate,\n    font: font,\n    textAlign: textAlign,\n    textPadding: textPadding,\n    textLineHeight: textLineHeight\n  });\n  var outerWidth = contentBlock.outerWidth;\n  var outerHeight = contentBlock.outerHeight;\n  var x = adjustTextX(0, outerWidth, textAlign);\n  var y = adjustTextY(0, outerHeight, textVerticalAlign);\n  return new BoundingRect(x, y, outerWidth, outerHeight);\n}\n/**\n * @public\n * @param {number} x\n * @param {number} width\n * @param {string} [textAlign='left']\n * @return {number} Adjusted x.\n */\n\n\nfunction adjustTextX(x, width, textAlign) {\n  // FIXME Right to left language\n  if (textAlign === 'right') {\n    x -= width;\n  } else if (textAlign === 'center') {\n    x -= width / 2;\n  }\n\n  return x;\n}\n/**\n * @public\n * @param {number} y\n * @param {number} height\n * @param {string} [textVerticalAlign='top']\n * @return {number} Adjusted y.\n */\n\n\nfunction adjustTextY(y, height, textVerticalAlign) {\n  if (textVerticalAlign === 'middle') {\n    y -= height / 2;\n  } else if (textVerticalAlign === 'bottom') {\n    y -= height;\n  }\n\n  return y;\n}\n/**\n * @public\n * @param {stirng} textPosition\n * @param {Object} rect {x, y, width, height}\n * @param {number} distance\n * @return {Object} {x, y, textAlign, textVerticalAlign}\n */\n\n\nfunction adjustTextPositionOnRect(textPosition, rect, distance) {\n  var x = rect.x;\n  var y = rect.y;\n  var height = rect.height;\n  var width = rect.width;\n  var halfHeight = height / 2;\n  var textAlign = 'left';\n  var textVerticalAlign = 'top';\n\n  switch (textPosition) {\n    case 'left':\n      x -= distance;\n      y += halfHeight;\n      textAlign = 'right';\n      textVerticalAlign = 'middle';\n      break;\n\n    case 'right':\n      x += distance + width;\n      y += halfHeight;\n      textVerticalAlign = 'middle';\n      break;\n\n    case 'top':\n      x += width / 2;\n      y -= distance;\n      textAlign = 'center';\n      textVerticalAlign = 'bottom';\n      break;\n\n    case 'bottom':\n      x += width / 2;\n      y += height + distance;\n      textAlign = 'center';\n      break;\n\n    case 'inside':\n      x += width / 2;\n      y += halfHeight;\n      textAlign = 'center';\n      textVerticalAlign = 'middle';\n      break;\n\n    case 'insideLeft':\n      x += distance;\n      y += halfHeight;\n      textVerticalAlign = 'middle';\n      break;\n\n    case 'insideRight':\n      x += width - distance;\n      y += halfHeight;\n      textAlign = 'right';\n      textVerticalAlign = 'middle';\n      break;\n\n    case 'insideTop':\n      x += width / 2;\n      y += distance;\n      textAlign = 'center';\n      break;\n\n    case 'insideBottom':\n      x += width / 2;\n      y += height - distance;\n      textAlign = 'center';\n      textVerticalAlign = 'bottom';\n      break;\n\n    case 'insideTopLeft':\n      x += distance;\n      y += distance;\n      break;\n\n    case 'insideTopRight':\n      x += width - distance;\n      y += distance;\n      textAlign = 'right';\n      break;\n\n    case 'insideBottomLeft':\n      x += distance;\n      y += height - distance;\n      textVerticalAlign = 'bottom';\n      break;\n\n    case 'insideBottomRight':\n      x += width - distance;\n      y += height - distance;\n      textAlign = 'right';\n      textVerticalAlign = 'bottom';\n      break;\n  }\n\n  return {\n    x: x,\n    y: y,\n    textAlign: textAlign,\n    textVerticalAlign: textVerticalAlign\n  };\n}\n/**\n * Show ellipsis if overflow.\n *\n * @public\n * @param  {string} text\n * @param  {string} containerWidth\n * @param  {string} font\n * @param  {number} [ellipsis='...']\n * @param  {Object} [options]\n * @param  {number} [options.maxIterations=3]\n * @param  {number} [options.minChar=0] If truncate result are less\n *                  then minChar, ellipsis will not show, which is\n *                  better for user hint in some cases.\n * @param  {number} [options.placeholder=''] When all truncated, use the placeholder.\n * @return {string}\n */\n\n\nfunction truncateText(text, containerWidth, font, ellipsis, options) {\n  if (!containerWidth) {\n    return '';\n  }\n\n  var textLines = (text + '').split('\\n');\n  options = prepareTruncateOptions(containerWidth, font, ellipsis, options); // FIXME\n  // It is not appropriate that every line has '...' when truncate multiple lines.\n\n  for (var i = 0, len = textLines.length; i < len; i++) {\n    textLines[i] = truncateSingleLine(textLines[i], options);\n  }\n\n  return textLines.join('\\n');\n}\n\nfunction prepareTruncateOptions(containerWidth, font, ellipsis, options) {\n  options = extend({}, options);\n  options.font = font;\n  var ellipsis = retrieve2(ellipsis, '...');\n  options.maxIterations = retrieve2(options.maxIterations, 2);\n  var minChar = options.minChar = retrieve2(options.minChar, 0); // FIXME\n  // Other languages?\n\n  options.cnCharWidth = getWidth('国', font); // FIXME\n  // Consider proportional font?\n\n  var ascCharWidth = options.ascCharWidth = getWidth('a', font);\n  options.placeholder = retrieve2(options.placeholder, ''); // Example 1: minChar: 3, text: 'asdfzxcv', truncate result: 'asdf', but not: 'a...'.\n  // Example 2: minChar: 3, text: '维度', truncate result: '维', but not: '...'.\n\n  var contentWidth = containerWidth = Math.max(0, containerWidth - 1); // Reserve some gap.\n\n  for (var i = 0; i < minChar && contentWidth >= ascCharWidth; i++) {\n    contentWidth -= ascCharWidth;\n  }\n\n  var ellipsisWidth = getWidth(ellipsis, font);\n\n  if (ellipsisWidth > contentWidth) {\n    ellipsis = '';\n    ellipsisWidth = 0;\n  }\n\n  contentWidth = containerWidth - ellipsisWidth;\n  options.ellipsis = ellipsis;\n  options.ellipsisWidth = ellipsisWidth;\n  options.contentWidth = contentWidth;\n  options.containerWidth = containerWidth;\n  return options;\n}\n\nfunction truncateSingleLine(textLine, options) {\n  var containerWidth = options.containerWidth;\n  var font = options.font;\n  var contentWidth = options.contentWidth;\n\n  if (!containerWidth) {\n    return '';\n  }\n\n  var lineWidth = getWidth(textLine, font);\n\n  if (lineWidth <= containerWidth) {\n    return textLine;\n  }\n\n  for (var j = 0;; j++) {\n    if (lineWidth <= contentWidth || j >= options.maxIterations) {\n      textLine += options.ellipsis;\n      break;\n    }\n\n    var subLength = j === 0 ? estimateLength(textLine, contentWidth, options.ascCharWidth, options.cnCharWidth) : lineWidth > 0 ? Math.floor(textLine.length * contentWidth / lineWidth) : 0;\n    textLine = textLine.substr(0, subLength);\n    lineWidth = getWidth(textLine, font);\n  }\n\n  if (textLine === '') {\n    textLine = options.placeholder;\n  }\n\n  return textLine;\n}\n\nfunction estimateLength(text, contentWidth, ascCharWidth, cnCharWidth) {\n  var width = 0;\n  var i = 0;\n\n  for (var len = text.length; i < len && width < contentWidth; i++) {\n    var charCode = text.charCodeAt(i);\n    width += 0 <= charCode && charCode <= 127 ? ascCharWidth : cnCharWidth;\n  }\n\n  return i;\n}\n/**\n * @public\n * @param {string} font\n * @return {number} line height\n */\n\n\nfunction getLineHeight(font) {\n  // FIXME A rough approach.\n  return getWidth('国', font);\n}\n/**\n * @public\n * @param {string} text\n * @param {string} font\n * @return {Object} width\n */\n\n\nfunction measureText(text, font) {\n  return methods.measureText(text, font);\n} // Avoid assign to an exported variable, for transforming to cjs.\n\n\nmethods.measureText = function (text, font) {\n  var ctx = getContext();\n  ctx.font = font || DEFAULT_FONT;\n  return ctx.measureText(text);\n};\n/**\n * @public\n * @param {string} text\n * @param {string} font\n * @param {Object} [truncate]\n * @return {Object} block: {lineHeight, lines, height, outerHeight}\n *  Notice: for performance, do not calculate outerWidth util needed.\n */\n\n\nfunction parsePlainText(text, font, padding, textLineHeight, truncate) {\n  text != null && (text += '');\n  var lineHeight = retrieve2(textLineHeight, getLineHeight(font));\n  var lines = text ? text.split('\\n') : [];\n  var height = lines.length * lineHeight;\n  var outerHeight = height;\n\n  if (padding) {\n    outerHeight += padding[0] + padding[2];\n  }\n\n  if (text && truncate) {\n    var truncOuterHeight = truncate.outerHeight;\n    var truncOuterWidth = truncate.outerWidth;\n\n    if (truncOuterHeight != null && outerHeight > truncOuterHeight) {\n      text = '';\n      lines = [];\n    } else if (truncOuterWidth != null) {\n      var options = prepareTruncateOptions(truncOuterWidth - (padding ? padding[1] + padding[3] : 0), font, truncate.ellipsis, {\n        minChar: truncate.minChar,\n        placeholder: truncate.placeholder\n      }); // FIXME\n      // It is not appropriate that every line has '...' when truncate multiple lines.\n\n      for (var i = 0, len = lines.length; i < len; i++) {\n        lines[i] = truncateSingleLine(lines[i], options);\n      }\n    }\n  }\n\n  return {\n    lines: lines,\n    height: height,\n    outerHeight: outerHeight,\n    lineHeight: lineHeight\n  };\n}\n/**\n * For example: 'some text {a|some text}other text{b|some text}xxx{c|}xxx'\n * Also consider 'bbbb{a|xxx\\nzzz}xxxx\\naaaa'.\n *\n * @public\n * @param {string} text\n * @param {Object} style\n * @return {Object} block\n * {\n *      width,\n *      height,\n *      lines: [{\n *          lineHeight,\n *          width,\n *          tokens: [[{\n *              styleName,\n *              text,\n *              width,      // include textPadding\n *              height,     // include textPadding\n *              textWidth, // pure text width\n *              textHeight, // pure text height\n *              lineHeihgt,\n *              font,\n *              textAlign,\n *              textVerticalAlign\n *          }], [...], ...]\n *      }, ...]\n * }\n * If styleName is undefined, it is plain text.\n */\n\n\nfunction parseRichText(text, style) {\n  var contentBlock = {\n    lines: [],\n    width: 0,\n    height: 0\n  };\n  text != null && (text += '');\n\n  if (!text) {\n    return contentBlock;\n  }\n\n  var lastIndex = STYLE_REG.lastIndex = 0;\n  var result;\n\n  while ((result = STYLE_REG.exec(text)) != null) {\n    var matchedIndex = result.index;\n\n    if (matchedIndex > lastIndex) {\n      pushTokens(contentBlock, text.substring(lastIndex, matchedIndex));\n    }\n\n    pushTokens(contentBlock, result[2], result[1]);\n    lastIndex = STYLE_REG.lastIndex;\n  }\n\n  if (lastIndex < text.length) {\n    pushTokens(contentBlock, text.substring(lastIndex, text.length));\n  }\n\n  var lines = contentBlock.lines;\n  var contentHeight = 0;\n  var contentWidth = 0; // For `textWidth: 100%`\n\n  var pendingList = [];\n  var stlPadding = style.textPadding;\n  var truncate = style.truncate;\n  var truncateWidth = truncate && truncate.outerWidth;\n  var truncateHeight = truncate && truncate.outerHeight;\n\n  if (stlPadding) {\n    truncateWidth != null && (truncateWidth -= stlPadding[1] + stlPadding[3]);\n    truncateHeight != null && (truncateHeight -= stlPadding[0] + stlPadding[2]);\n  } // Calculate layout info of tokens.\n\n\n  for (var i = 0; i < lines.length; i++) {\n    var line = lines[i];\n    var lineHeight = 0;\n    var lineWidth = 0;\n\n    for (var j = 0; j < line.tokens.length; j++) {\n      var token = line.tokens[j];\n      var tokenStyle = token.styleName && style.rich[token.styleName] || {}; // textPadding should not inherit from style.\n\n      var textPadding = token.textPadding = tokenStyle.textPadding; // textFont has been asigned to font by `normalizeStyle`.\n\n      var font = token.font = tokenStyle.font || style.font; // textHeight can be used when textVerticalAlign is specified in token.\n\n      var tokenHeight = token.textHeight = retrieve2( // textHeight should not be inherited, consider it can be specified\n      // as box height of the block.\n      tokenStyle.textHeight, getLineHeight(font));\n      textPadding && (tokenHeight += textPadding[0] + textPadding[2]);\n      token.height = tokenHeight;\n      token.lineHeight = retrieve3(tokenStyle.textLineHeight, style.textLineHeight, tokenHeight);\n      token.textAlign = tokenStyle && tokenStyle.textAlign || style.textAlign;\n      token.textVerticalAlign = tokenStyle && tokenStyle.textVerticalAlign || 'middle';\n\n      if (truncateHeight != null && contentHeight + token.lineHeight > truncateHeight) {\n        return {\n          lines: [],\n          width: 0,\n          height: 0\n        };\n      }\n\n      token.textWidth = getWidth(token.text, font);\n      var tokenWidth = tokenStyle.textWidth;\n      var tokenWidthNotSpecified = tokenWidth == null || tokenWidth === 'auto'; // Percent width, can be `100%`, can be used in drawing separate\n      // line when box width is needed to be auto.\n\n      if (typeof tokenWidth === 'string' && tokenWidth.charAt(tokenWidth.length - 1) === '%') {\n        token.percentWidth = tokenWidth;\n        pendingList.push(token);\n        tokenWidth = 0; // Do not truncate in this case, because there is no user case\n        // and it is too complicated.\n      } else {\n        if (tokenWidthNotSpecified) {\n          tokenWidth = token.textWidth; // FIXME: If image is not loaded and textWidth is not specified, calling\n          // `getBoundingRect()` will not get correct result.\n\n          var textBackgroundColor = tokenStyle.textBackgroundColor;\n          var bgImg = textBackgroundColor && textBackgroundColor.image; // Use cases:\n          // (1) If image is not loaded, it will be loaded at render phase and call\n          // `dirty()` and `textBackgroundColor.image` will be replaced with the loaded\n          // image, and then the right size will be calculated here at the next tick.\n          // See `graphic/helper/text.js`.\n          // (2) If image loaded, and `textBackgroundColor.image` is image src string,\n          // use `imageHelper.findExistImage` to find cached image.\n          // `imageHelper.findExistImage` will always be called here before\n          // `imageHelper.createOrUpdateImage` in `graphic/helper/text.js#renderRichText`\n          // which ensures that image will not be rendered before correct size calcualted.\n\n          if (bgImg) {\n            bgImg = imageHelper.findExistImage(bgImg);\n\n            if (imageHelper.isImageReady(bgImg)) {\n              tokenWidth = Math.max(tokenWidth, bgImg.width * tokenHeight / bgImg.height);\n            }\n          }\n        }\n\n        var paddingW = textPadding ? textPadding[1] + textPadding[3] : 0;\n        tokenWidth += paddingW;\n        var remianTruncWidth = truncateWidth != null ? truncateWidth - lineWidth : null;\n\n        if (remianTruncWidth != null && remianTruncWidth < tokenWidth) {\n          if (!tokenWidthNotSpecified || remianTruncWidth < paddingW) {\n            token.text = '';\n            token.textWidth = tokenWidth = 0;\n          } else {\n            token.text = truncateText(token.text, remianTruncWidth - paddingW, font, truncate.ellipsis, {\n              minChar: truncate.minChar\n            });\n            token.textWidth = getWidth(token.text, font);\n            tokenWidth = token.textWidth + paddingW;\n          }\n        }\n      }\n\n      lineWidth += token.width = tokenWidth;\n      tokenStyle && (lineHeight = Math.max(lineHeight, token.lineHeight));\n    }\n\n    line.width = lineWidth;\n    line.lineHeight = lineHeight;\n    contentHeight += lineHeight;\n    contentWidth = Math.max(contentWidth, lineWidth);\n  }\n\n  contentBlock.outerWidth = contentBlock.width = retrieve2(style.textWidth, contentWidth);\n  contentBlock.outerHeight = contentBlock.height = retrieve2(style.textHeight, contentHeight);\n\n  if (stlPadding) {\n    contentBlock.outerWidth += stlPadding[1] + stlPadding[3];\n    contentBlock.outerHeight += stlPadding[0] + stlPadding[2];\n  }\n\n  for (var i = 0; i < pendingList.length; i++) {\n    var token = pendingList[i];\n    var percentWidth = token.percentWidth; // Should not base on outerWidth, because token can not be placed out of padding.\n\n    token.width = parseInt(percentWidth, 10) / 100 * contentWidth;\n  }\n\n  return contentBlock;\n}\n\nfunction pushTokens(block, str, styleName) {\n  var isEmptyStr = str === '';\n  var strs = str.split('\\n');\n  var lines = block.lines;\n\n  for (var i = 0; i < strs.length; i++) {\n    var text = strs[i];\n    var token = {\n      styleName: styleName,\n      text: text,\n      isLineHolder: !text && !isEmptyStr\n    }; // The first token should be appended to the last line.\n\n    if (!i) {\n      var tokens = (lines[lines.length - 1] || (lines[0] = {\n        tokens: []\n      })).tokens; // Consider cases:\n      // (1) ''.split('\\n') => ['', '\\n', ''], the '' at the first item\n      // (which is a placeholder) should be replaced by new token.\n      // (2) A image backage, where token likes {a|}.\n      // (3) A redundant '' will affect textAlign in line.\n      // (4) tokens with the same tplName should not be merged, because\n      // they should be displayed in different box (with border and padding).\n\n      var tokensLen = tokens.length;\n      tokensLen === 1 && tokens[0].isLineHolder ? tokens[0] = token : // Consider text is '', only insert when it is the \"lineHolder\" or\n      // \"emptyStr\". Otherwise a redundant '' will affect textAlign in line.\n      (text || !tokensLen || isEmptyStr) && tokens.push(token);\n    } // Other tokens always start a new line.\n    else {\n        // If there is '', insert it as a placeholder.\n        lines.push({\n          tokens: [token]\n        });\n      }\n  }\n}\n\nfunction makeFont(style) {\n  // FIXME in node-canvas fontWeight is before fontStyle\n  // Use `fontSize` `fontFamily` to check whether font properties are defined.\n  var font = (style.fontSize || style.fontFamily) && [style.fontStyle, style.fontWeight, (style.fontSize || 12) + 'px', // If font properties are defined, `fontFamily` should not be ignored.\n  style.fontFamily || 'sans-serif'].join(' ');\n  return font && trim(font) || style.textFont || style.font;\n}\n\nexports.DEFAULT_FONT = DEFAULT_FONT;\nexports.$override = $override;\nexports.getWidth = getWidth;\nexports.getBoundingRect = getBoundingRect;\nexports.adjustTextX = adjustTextX;\nexports.adjustTextY = adjustTextY;\nexports.adjustTextPositionOnRect = adjustTextPositionOnRect;\nexports.truncateText = truncateText;\nexports.getLineHeight = getLineHeight;\nexports.measureText = measureText;\nexports.parsePlainText = parsePlainText;\nexports.parseRichText = parseRichText;\nexports.makeFont = makeFont;"]},"metadata":{},"sourceType":"script"}