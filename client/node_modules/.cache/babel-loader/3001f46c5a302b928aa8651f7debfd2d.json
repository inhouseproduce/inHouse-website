{"ast":null,"code":"/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar _number = require(\"../util/number\");\n\nvar parsePercent = _number.parsePercent;\n\nvar _dataStackHelper = require(\"../data/helper/dataStackHelper\");\n\nvar isDimensionStacked = _dataStackHelper.isDimensionStacked;\n\nvar createRenderPlanner = require(\"../chart/helper/createRenderPlanner\");\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/* global Float32Array */\n\n\nvar STACK_PREFIX = '__ec_stack_';\nvar LARGE_BAR_MIN_WIDTH = 0.5;\nvar LargeArr = typeof Float32Array !== 'undefined' ? Float32Array : Array;\n\nfunction getSeriesStackId(seriesModel) {\n  return seriesModel.get('stack') || STACK_PREFIX + seriesModel.seriesIndex;\n}\n\nfunction getAxisKey(axis) {\n  return axis.dim + axis.index;\n}\n/**\n * @param {Object} opt\n * @param {module:echarts/coord/Axis} opt.axis Only support category axis currently.\n * @param {number} opt.count Positive interger.\n * @param {number} [opt.barWidth]\n * @param {number} [opt.barMaxWidth]\n * @param {number} [opt.barGap]\n * @param {number} [opt.barCategoryGap]\n * @return {Object} {width, offset, offsetCenter} If axis.type is not 'category', return undefined.\n */\n\n\nfunction getLayoutOnAxis(opt) {\n  var params = [];\n  var baseAxis = opt.axis;\n  var axisKey = 'axis0';\n\n  if (baseAxis.type !== 'category') {\n    return;\n  }\n\n  var bandWidth = baseAxis.getBandWidth();\n\n  for (var i = 0; i < opt.count || 0; i++) {\n    params.push(zrUtil.defaults({\n      bandWidth: bandWidth,\n      axisKey: axisKey,\n      stackId: STACK_PREFIX + i\n    }, opt));\n  }\n\n  var widthAndOffsets = doCalBarWidthAndOffset(params);\n  var result = [];\n\n  for (var i = 0; i < opt.count; i++) {\n    var item = widthAndOffsets[axisKey][STACK_PREFIX + i];\n    item.offsetCenter = item.offset + item.width / 2;\n    result.push(item);\n  }\n\n  return result;\n}\n\nfunction prepareLayoutBarSeries(seriesType, ecModel) {\n  var seriesModels = [];\n  ecModel.eachSeriesByType(seriesType, function (seriesModel) {\n    // Check series coordinate, do layout for cartesian2d only\n    if (isOnCartesian(seriesModel) && !isInLargeMode(seriesModel)) {\n      seriesModels.push(seriesModel);\n    }\n  });\n  return seriesModels;\n}\n\nfunction makeColumnLayout(barSeries) {\n  var seriesInfoList = [];\n  zrUtil.each(barSeries, function (seriesModel) {\n    var data = seriesModel.getData();\n    var cartesian = seriesModel.coordinateSystem;\n    var baseAxis = cartesian.getBaseAxis();\n    var axisExtent = baseAxis.getExtent();\n    var bandWidth = baseAxis.type === 'category' ? baseAxis.getBandWidth() : Math.abs(axisExtent[1] - axisExtent[0]) / data.count();\n    var barWidth = parsePercent(seriesModel.get('barWidth'), bandWidth);\n    var barMaxWidth = parsePercent(seriesModel.get('barMaxWidth'), bandWidth);\n    var barGap = seriesModel.get('barGap');\n    var barCategoryGap = seriesModel.get('barCategoryGap');\n    seriesInfoList.push({\n      bandWidth: bandWidth,\n      barWidth: barWidth,\n      barMaxWidth: barMaxWidth,\n      barGap: barGap,\n      barCategoryGap: barCategoryGap,\n      axisKey: getAxisKey(baseAxis),\n      stackId: getSeriesStackId(seriesModel)\n    });\n  });\n  return doCalBarWidthAndOffset(seriesInfoList);\n}\n\nfunction doCalBarWidthAndOffset(seriesInfoList) {\n  // Columns info on each category axis. Key is cartesian name\n  var columnsMap = {};\n  zrUtil.each(seriesInfoList, function (seriesInfo, idx) {\n    var axisKey = seriesInfo.axisKey;\n    var bandWidth = seriesInfo.bandWidth;\n    var columnsOnAxis = columnsMap[axisKey] || {\n      bandWidth: bandWidth,\n      remainedWidth: bandWidth,\n      autoWidthCount: 0,\n      categoryGap: '20%',\n      gap: '30%',\n      stacks: {}\n    };\n    var stacks = columnsOnAxis.stacks;\n    columnsMap[axisKey] = columnsOnAxis;\n    var stackId = seriesInfo.stackId;\n\n    if (!stacks[stackId]) {\n      columnsOnAxis.autoWidthCount++;\n    }\n\n    stacks[stackId] = stacks[stackId] || {\n      width: 0,\n      maxWidth: 0\n    }; // Caution: In a single coordinate system, these barGrid attributes\n    // will be shared by series. Consider that they have default values,\n    // only the attributes set on the last series will work.\n    // Do not change this fact unless there will be a break change.\n    // TODO\n\n    var barWidth = seriesInfo.barWidth;\n\n    if (barWidth && !stacks[stackId].width) {\n      // See #6312, do not restrict width.\n      stacks[stackId].width = barWidth;\n      barWidth = Math.min(columnsOnAxis.remainedWidth, barWidth);\n      columnsOnAxis.remainedWidth -= barWidth;\n    }\n\n    var barMaxWidth = seriesInfo.barMaxWidth;\n    barMaxWidth && (stacks[stackId].maxWidth = barMaxWidth);\n    var barGap = seriesInfo.barGap;\n    barGap != null && (columnsOnAxis.gap = barGap);\n    var barCategoryGap = seriesInfo.barCategoryGap;\n    barCategoryGap != null && (columnsOnAxis.categoryGap = barCategoryGap);\n  });\n  var result = {};\n  zrUtil.each(columnsMap, function (columnsOnAxis, coordSysName) {\n    result[coordSysName] = {};\n    var stacks = columnsOnAxis.stacks;\n    var bandWidth = columnsOnAxis.bandWidth;\n    var categoryGap = parsePercent(columnsOnAxis.categoryGap, bandWidth);\n    var barGapPercent = parsePercent(columnsOnAxis.gap, 1);\n    var remainedWidth = columnsOnAxis.remainedWidth;\n    var autoWidthCount = columnsOnAxis.autoWidthCount;\n    var autoWidth = (remainedWidth - categoryGap) / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);\n    autoWidth = Math.max(autoWidth, 0); // Find if any auto calculated bar exceeded maxBarWidth\n\n    zrUtil.each(stacks, function (column, stack) {\n      var maxWidth = column.maxWidth;\n\n      if (maxWidth && maxWidth < autoWidth) {\n        maxWidth = Math.min(maxWidth, remainedWidth);\n\n        if (column.width) {\n          maxWidth = Math.min(maxWidth, column.width);\n        }\n\n        remainedWidth -= maxWidth;\n        column.width = maxWidth;\n        autoWidthCount--;\n      }\n    }); // Recalculate width again\n\n    autoWidth = (remainedWidth - categoryGap) / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);\n    autoWidth = Math.max(autoWidth, 0);\n    var widthSum = 0;\n    var lastColumn;\n    zrUtil.each(stacks, function (column, idx) {\n      if (!column.width) {\n        column.width = autoWidth;\n      }\n\n      lastColumn = column;\n      widthSum += column.width * (1 + barGapPercent);\n    });\n\n    if (lastColumn) {\n      widthSum -= lastColumn.width * barGapPercent;\n    }\n\n    var offset = -widthSum / 2;\n    zrUtil.each(stacks, function (column, stackId) {\n      result[coordSysName][stackId] = result[coordSysName][stackId] || {\n        offset: offset,\n        width: column.width\n      };\n      offset += column.width * (1 + barGapPercent);\n    });\n  });\n  return result;\n}\n/**\n * @param {Object} barWidthAndOffset The result of makeColumnLayout\n * @param {module:echarts/coord/Axis} axis\n * @param {module:echarts/model/Series} [seriesModel] If not provided, return all.\n * @return {Object} {stackId: {offset, width}} or {offset, width} if seriesModel provided.\n */\n\n\nfunction retrieveColumnLayout(barWidthAndOffset, axis, seriesModel) {\n  if (barWidthAndOffset && axis) {\n    var result = barWidthAndOffset[getAxisKey(axis)];\n\n    if (result != null && seriesModel != null) {\n      result = result[getSeriesStackId(seriesModel)];\n    }\n\n    return result;\n  }\n}\n/**\n * @param {string} seriesType\n * @param {module:echarts/model/Global} ecModel\n */\n\n\nfunction layout(seriesType, ecModel) {\n  var seriesModels = prepareLayoutBarSeries(seriesType, ecModel);\n  var barWidthAndOffset = makeColumnLayout(seriesModels);\n  var lastStackCoords = {};\n  var lastStackCoordsOrigin = {};\n  zrUtil.each(seriesModels, function (seriesModel) {\n    var data = seriesModel.getData();\n    var cartesian = seriesModel.coordinateSystem;\n    var baseAxis = cartesian.getBaseAxis();\n    var stackId = getSeriesStackId(seriesModel);\n    var columnLayoutInfo = barWidthAndOffset[getAxisKey(baseAxis)][stackId];\n    var columnOffset = columnLayoutInfo.offset;\n    var columnWidth = columnLayoutInfo.width;\n    var valueAxis = cartesian.getOtherAxis(baseAxis);\n    var barMinHeight = seriesModel.get('barMinHeight') || 0;\n    lastStackCoords[stackId] = lastStackCoords[stackId] || [];\n    lastStackCoordsOrigin[stackId] = lastStackCoordsOrigin[stackId] || []; // Fix #4243\n\n    data.setLayout({\n      offset: columnOffset,\n      size: columnWidth\n    });\n    var valueDim = data.mapDimension(valueAxis.dim);\n    var baseDim = data.mapDimension(baseAxis.dim);\n    var stacked = isDimensionStacked(data, valueDim\n    /*, baseDim*/\n    );\n    var isValueAxisH = valueAxis.isHorizontal();\n    var valueAxisStart = getValueAxisStart(baseAxis, valueAxis, stacked);\n\n    for (var idx = 0, len = data.count(); idx < len; idx++) {\n      var value = data.get(valueDim, idx);\n      var baseValue = data.get(baseDim, idx);\n\n      if (isNaN(value)) {\n        continue;\n      }\n\n      var sign = value >= 0 ? 'p' : 'n';\n      var baseCoord = valueAxisStart; // Because of the barMinHeight, we can not use the value in\n      // stackResultDimension directly.\n\n      if (stacked) {\n        // Only ordinal axis can be stacked.\n        if (!lastStackCoords[stackId][baseValue]) {\n          lastStackCoords[stackId][baseValue] = {\n            p: valueAxisStart,\n            // Positive stack\n            n: valueAxisStart // Negative stack\n\n          };\n        } // Should also consider #4243\n\n\n        baseCoord = lastStackCoords[stackId][baseValue][sign];\n      }\n\n      var x;\n      var y;\n      var width;\n      var height;\n\n      if (isValueAxisH) {\n        var coord = cartesian.dataToPoint([value, baseValue]);\n        x = baseCoord;\n        y = coord[1] + columnOffset;\n        width = coord[0] - valueAxisStart;\n        height = columnWidth;\n\n        if (Math.abs(width) < barMinHeight) {\n          width = (width < 0 ? -1 : 1) * barMinHeight;\n        }\n\n        stacked && (lastStackCoords[stackId][baseValue][sign] += width);\n      } else {\n        var coord = cartesian.dataToPoint([baseValue, value]);\n        x = coord[0] + columnOffset;\n        y = baseCoord;\n        width = columnWidth;\n        height = coord[1] - valueAxisStart;\n\n        if (Math.abs(height) < barMinHeight) {\n          // Include zero to has a positive bar\n          height = (height <= 0 ? -1 : 1) * barMinHeight;\n        }\n\n        stacked && (lastStackCoords[stackId][baseValue][sign] += height);\n      }\n\n      data.setItemLayout(idx, {\n        x: x,\n        y: y,\n        width: width,\n        height: height\n      });\n    }\n  }, this);\n} // TODO: Do not support stack in large mode yet.\n\n\nvar largeLayout = {\n  seriesType: 'bar',\n  plan: createRenderPlanner(),\n  reset: function reset(seriesModel) {\n    if (!isOnCartesian(seriesModel) || !isInLargeMode(seriesModel)) {\n      return;\n    }\n\n    var data = seriesModel.getData();\n    var cartesian = seriesModel.coordinateSystem;\n    var baseAxis = cartesian.getBaseAxis();\n    var valueAxis = cartesian.getOtherAxis(baseAxis);\n    var valueDim = data.mapDimension(valueAxis.dim);\n    var baseDim = data.mapDimension(baseAxis.dim);\n    var valueAxisHorizontal = valueAxis.isHorizontal();\n    var valueDimIdx = valueAxisHorizontal ? 0 : 1;\n    var barWidth = retrieveColumnLayout(makeColumnLayout([seriesModel]), baseAxis, seriesModel).width;\n\n    if (!(barWidth > LARGE_BAR_MIN_WIDTH)) {\n      // jshint ignore:line\n      barWidth = LARGE_BAR_MIN_WIDTH;\n    }\n\n    return {\n      progress: progress\n    };\n\n    function progress(params, data) {\n      var largePoints = new LargeArr(params.count * 2);\n      var dataIndex;\n      var coord = [];\n      var valuePair = [];\n      var offset = 0;\n\n      while ((dataIndex = params.next()) != null) {\n        valuePair[valueDimIdx] = data.get(valueDim, dataIndex);\n        valuePair[1 - valueDimIdx] = data.get(baseDim, dataIndex);\n        coord = cartesian.dataToPoint(valuePair, null, coord);\n        largePoints[offset++] = coord[0];\n        largePoints[offset++] = coord[1];\n      }\n\n      data.setLayout({\n        largePoints: largePoints,\n        barWidth: barWidth,\n        valueAxisStart: getValueAxisStart(baseAxis, valueAxis, false),\n        valueAxisHorizontal: valueAxisHorizontal\n      });\n    }\n  }\n};\n\nfunction isOnCartesian(seriesModel) {\n  return seriesModel.coordinateSystem && seriesModel.coordinateSystem.type === 'cartesian2d';\n}\n\nfunction isInLargeMode(seriesModel) {\n  return seriesModel.pipelineContext && seriesModel.pipelineContext.large;\n} // See cases in `test/bar-start.html` and `#7412`, `#8747`.\n\n\nfunction getValueAxisStart(baseAxis, valueAxis, stacked) {\n  var extent = valueAxis.getGlobalExtent();\n  var min;\n  var max;\n\n  if (extent[0] > extent[1]) {\n    min = extent[1];\n    max = extent[0];\n  } else {\n    min = extent[0];\n    max = extent[1];\n  }\n\n  var valueStart = valueAxis.toGlobalCoord(valueAxis.dataToCoord(0));\n  valueStart < min && (valueStart = min);\n  valueStart > max && (valueStart = max);\n  return valueStart;\n}\n\nexports.getLayoutOnAxis = getLayoutOnAxis;\nexports.prepareLayoutBarSeries = prepareLayoutBarSeries;\nexports.makeColumnLayout = makeColumnLayout;\nexports.retrieveColumnLayout = retrieveColumnLayout;\nexports.layout = layout;\nexports.largeLayout = largeLayout;","map":{"version":3,"sources":["/Users/eduardjacobs/Desktop/files/inHouse-website/client/node_modules/echarts/lib/layout/barGrid.js"],"names":["zrUtil","require","_number","parsePercent","_dataStackHelper","isDimensionStacked","createRenderPlanner","STACK_PREFIX","LARGE_BAR_MIN_WIDTH","LargeArr","Float32Array","Array","getSeriesStackId","seriesModel","get","seriesIndex","getAxisKey","axis","dim","index","getLayoutOnAxis","opt","params","baseAxis","axisKey","type","bandWidth","getBandWidth","i","count","push","defaults","stackId","widthAndOffsets","doCalBarWidthAndOffset","result","item","offsetCenter","offset","width","prepareLayoutBarSeries","seriesType","ecModel","seriesModels","eachSeriesByType","isOnCartesian","isInLargeMode","makeColumnLayout","barSeries","seriesInfoList","each","data","getData","cartesian","coordinateSystem","getBaseAxis","axisExtent","getExtent","Math","abs","barWidth","barMaxWidth","barGap","barCategoryGap","columnsMap","seriesInfo","idx","columnsOnAxis","remainedWidth","autoWidthCount","categoryGap","gap","stacks","maxWidth","min","coordSysName","barGapPercent","autoWidth","max","column","stack","widthSum","lastColumn","retrieveColumnLayout","barWidthAndOffset","layout","lastStackCoords","lastStackCoordsOrigin","columnLayoutInfo","columnOffset","columnWidth","valueAxis","getOtherAxis","barMinHeight","setLayout","size","valueDim","mapDimension","baseDim","stacked","isValueAxisH","isHorizontal","valueAxisStart","getValueAxisStart","len","value","baseValue","isNaN","sign","baseCoord","p","n","x","y","height","coord","dataToPoint","setItemLayout","largeLayout","plan","reset","valueAxisHorizontal","valueDimIdx","progress","largePoints","dataIndex","valuePair","next","pipelineContext","large","extent","getGlobalExtent","valueStart","toGlobalCoord","dataToCoord","exports"],"mappings":"AACA;;;;;;;;;;;;;;;;;;AAmBA,IAAIA,MAAM,GAAGC,OAAO,CAAC,uBAAD,CAApB;;AAEA,IAAIC,OAAO,GAAGD,OAAO,CAAC,gBAAD,CAArB;;AAEA,IAAIE,YAAY,GAAGD,OAAO,CAACC,YAA3B;;AAEA,IAAIC,gBAAgB,GAAGH,OAAO,CAAC,gCAAD,CAA9B;;AAEA,IAAII,kBAAkB,GAAGD,gBAAgB,CAACC,kBAA1C;;AAEA,IAAIC,mBAAmB,GAAGL,OAAO,CAAC,qCAAD,CAAjC;AAEA;;;;;;;;;;;;;;;;;;;AAmBA;;;AACA,IAAIM,YAAY,GAAG,aAAnB;AACA,IAAIC,mBAAmB,GAAG,GAA1B;AACA,IAAIC,QAAQ,GAAG,OAAOC,YAAP,KAAwB,WAAxB,GAAsCA,YAAtC,GAAqDC,KAApE;;AAEA,SAASC,gBAAT,CAA0BC,WAA1B,EAAuC;AACrC,SAAOA,WAAW,CAACC,GAAZ,CAAgB,OAAhB,KAA4BP,YAAY,GAAGM,WAAW,CAACE,WAA9D;AACD;;AAED,SAASC,UAAT,CAAoBC,IAApB,EAA0B;AACxB,SAAOA,IAAI,CAACC,GAAL,GAAWD,IAAI,CAACE,KAAvB;AACD;AACD;;;;;;;;;;;;AAYA,SAASC,eAAT,CAAyBC,GAAzB,EAA8B;AAC5B,MAAIC,MAAM,GAAG,EAAb;AACA,MAAIC,QAAQ,GAAGF,GAAG,CAACJ,IAAnB;AACA,MAAIO,OAAO,GAAG,OAAd;;AAEA,MAAID,QAAQ,CAACE,IAAT,KAAkB,UAAtB,EAAkC;AAChC;AACD;;AAED,MAAIC,SAAS,GAAGH,QAAQ,CAACI,YAAT,EAAhB;;AAEA,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGP,GAAG,CAACQ,KAAR,IAAiB,CAAjC,EAAoCD,CAAC,EAArC,EAAyC;AACvCN,IAAAA,MAAM,CAACQ,IAAP,CAAY9B,MAAM,CAAC+B,QAAP,CAAgB;AAC1BL,MAAAA,SAAS,EAAEA,SADe;AAE1BF,MAAAA,OAAO,EAAEA,OAFiB;AAG1BQ,MAAAA,OAAO,EAAEzB,YAAY,GAAGqB;AAHE,KAAhB,EAITP,GAJS,CAAZ;AAKD;;AAED,MAAIY,eAAe,GAAGC,sBAAsB,CAACZ,MAAD,CAA5C;AACA,MAAIa,MAAM,GAAG,EAAb;;AAEA,OAAK,IAAIP,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGP,GAAG,CAACQ,KAAxB,EAA+BD,CAAC,EAAhC,EAAoC;AAClC,QAAIQ,IAAI,GAAGH,eAAe,CAACT,OAAD,CAAf,CAAyBjB,YAAY,GAAGqB,CAAxC,CAAX;AACAQ,IAAAA,IAAI,CAACC,YAAL,GAAoBD,IAAI,CAACE,MAAL,GAAcF,IAAI,CAACG,KAAL,GAAa,CAA/C;AACAJ,IAAAA,MAAM,CAACL,IAAP,CAAYM,IAAZ;AACD;;AAED,SAAOD,MAAP;AACD;;AAED,SAASK,sBAAT,CAAgCC,UAAhC,EAA4CC,OAA5C,EAAqD;AACnD,MAAIC,YAAY,GAAG,EAAnB;AACAD,EAAAA,OAAO,CAACE,gBAAR,CAAyBH,UAAzB,EAAqC,UAAU5B,WAAV,EAAuB;AAC1D;AACA,QAAIgC,aAAa,CAAChC,WAAD,CAAb,IAA8B,CAACiC,aAAa,CAACjC,WAAD,CAAhD,EAA+D;AAC7D8B,MAAAA,YAAY,CAACb,IAAb,CAAkBjB,WAAlB;AACD;AACF,GALD;AAMA,SAAO8B,YAAP;AACD;;AAED,SAASI,gBAAT,CAA0BC,SAA1B,EAAqC;AACnC,MAAIC,cAAc,GAAG,EAArB;AACAjD,EAAAA,MAAM,CAACkD,IAAP,CAAYF,SAAZ,EAAuB,UAAUnC,WAAV,EAAuB;AAC5C,QAAIsC,IAAI,GAAGtC,WAAW,CAACuC,OAAZ,EAAX;AACA,QAAIC,SAAS,GAAGxC,WAAW,CAACyC,gBAA5B;AACA,QAAI/B,QAAQ,GAAG8B,SAAS,CAACE,WAAV,EAAf;AACA,QAAIC,UAAU,GAAGjC,QAAQ,CAACkC,SAAT,EAAjB;AACA,QAAI/B,SAAS,GAAGH,QAAQ,CAACE,IAAT,KAAkB,UAAlB,GAA+BF,QAAQ,CAACI,YAAT,EAA/B,GAAyD+B,IAAI,CAACC,GAAL,CAASH,UAAU,CAAC,CAAD,CAAV,GAAgBA,UAAU,CAAC,CAAD,CAAnC,IAA0CL,IAAI,CAACtB,KAAL,EAAnH;AACA,QAAI+B,QAAQ,GAAGzD,YAAY,CAACU,WAAW,CAACC,GAAZ,CAAgB,UAAhB,CAAD,EAA8BY,SAA9B,CAA3B;AACA,QAAImC,WAAW,GAAG1D,YAAY,CAACU,WAAW,CAACC,GAAZ,CAAgB,aAAhB,CAAD,EAAiCY,SAAjC,CAA9B;AACA,QAAIoC,MAAM,GAAGjD,WAAW,CAACC,GAAZ,CAAgB,QAAhB,CAAb;AACA,QAAIiD,cAAc,GAAGlD,WAAW,CAACC,GAAZ,CAAgB,gBAAhB,CAArB;AACAmC,IAAAA,cAAc,CAACnB,IAAf,CAAoB;AAClBJ,MAAAA,SAAS,EAAEA,SADO;AAElBkC,MAAAA,QAAQ,EAAEA,QAFQ;AAGlBC,MAAAA,WAAW,EAAEA,WAHK;AAIlBC,MAAAA,MAAM,EAAEA,MAJU;AAKlBC,MAAAA,cAAc,EAAEA,cALE;AAMlBvC,MAAAA,OAAO,EAAER,UAAU,CAACO,QAAD,CAND;AAOlBS,MAAAA,OAAO,EAAEpB,gBAAgB,CAACC,WAAD;AAPP,KAApB;AASD,GAnBD;AAoBA,SAAOqB,sBAAsB,CAACe,cAAD,CAA7B;AACD;;AAED,SAASf,sBAAT,CAAgCe,cAAhC,EAAgD;AAC9C;AACA,MAAIe,UAAU,GAAG,EAAjB;AACAhE,EAAAA,MAAM,CAACkD,IAAP,CAAYD,cAAZ,EAA4B,UAAUgB,UAAV,EAAsBC,GAAtB,EAA2B;AACrD,QAAI1C,OAAO,GAAGyC,UAAU,CAACzC,OAAzB;AACA,QAAIE,SAAS,GAAGuC,UAAU,CAACvC,SAA3B;AACA,QAAIyC,aAAa,GAAGH,UAAU,CAACxC,OAAD,CAAV,IAAuB;AACzCE,MAAAA,SAAS,EAAEA,SAD8B;AAEzC0C,MAAAA,aAAa,EAAE1C,SAF0B;AAGzC2C,MAAAA,cAAc,EAAE,CAHyB;AAIzCC,MAAAA,WAAW,EAAE,KAJ4B;AAKzCC,MAAAA,GAAG,EAAE,KALoC;AAMzCC,MAAAA,MAAM,EAAE;AANiC,KAA3C;AAQA,QAAIA,MAAM,GAAGL,aAAa,CAACK,MAA3B;AACAR,IAAAA,UAAU,CAACxC,OAAD,CAAV,GAAsB2C,aAAtB;AACA,QAAInC,OAAO,GAAGiC,UAAU,CAACjC,OAAzB;;AAEA,QAAI,CAACwC,MAAM,CAACxC,OAAD,CAAX,EAAsB;AACpBmC,MAAAA,aAAa,CAACE,cAAd;AACD;;AAEDG,IAAAA,MAAM,CAACxC,OAAD,CAAN,GAAkBwC,MAAM,CAACxC,OAAD,CAAN,IAAmB;AACnCO,MAAAA,KAAK,EAAE,CAD4B;AAEnCkC,MAAAA,QAAQ,EAAE;AAFyB,KAArC,CAnBqD,CAsBlD;AACH;AACA;AACA;AACA;;AAEA,QAAIb,QAAQ,GAAGK,UAAU,CAACL,QAA1B;;AAEA,QAAIA,QAAQ,IAAI,CAACY,MAAM,CAACxC,OAAD,CAAN,CAAgBO,KAAjC,EAAwC;AACtC;AACAiC,MAAAA,MAAM,CAACxC,OAAD,CAAN,CAAgBO,KAAhB,GAAwBqB,QAAxB;AACAA,MAAAA,QAAQ,GAAGF,IAAI,CAACgB,GAAL,CAASP,aAAa,CAACC,aAAvB,EAAsCR,QAAtC,CAAX;AACAO,MAAAA,aAAa,CAACC,aAAd,IAA+BR,QAA/B;AACD;;AAED,QAAIC,WAAW,GAAGI,UAAU,CAACJ,WAA7B;AACAA,IAAAA,WAAW,KAAKW,MAAM,CAACxC,OAAD,CAAN,CAAgByC,QAAhB,GAA2BZ,WAAhC,CAAX;AACA,QAAIC,MAAM,GAAGG,UAAU,CAACH,MAAxB;AACAA,IAAAA,MAAM,IAAI,IAAV,KAAmBK,aAAa,CAACI,GAAd,GAAoBT,MAAvC;AACA,QAAIC,cAAc,GAAGE,UAAU,CAACF,cAAhC;AACAA,IAAAA,cAAc,IAAI,IAAlB,KAA2BI,aAAa,CAACG,WAAd,GAA4BP,cAAvD;AACD,GA3CD;AA4CA,MAAI5B,MAAM,GAAG,EAAb;AACAnC,EAAAA,MAAM,CAACkD,IAAP,CAAYc,UAAZ,EAAwB,UAAUG,aAAV,EAAyBQ,YAAzB,EAAuC;AAC7DxC,IAAAA,MAAM,CAACwC,YAAD,CAAN,GAAuB,EAAvB;AACA,QAAIH,MAAM,GAAGL,aAAa,CAACK,MAA3B;AACA,QAAI9C,SAAS,GAAGyC,aAAa,CAACzC,SAA9B;AACA,QAAI4C,WAAW,GAAGnE,YAAY,CAACgE,aAAa,CAACG,WAAf,EAA4B5C,SAA5B,CAA9B;AACA,QAAIkD,aAAa,GAAGzE,YAAY,CAACgE,aAAa,CAACI,GAAf,EAAoB,CAApB,CAAhC;AACA,QAAIH,aAAa,GAAGD,aAAa,CAACC,aAAlC;AACA,QAAIC,cAAc,GAAGF,aAAa,CAACE,cAAnC;AACA,QAAIQ,SAAS,GAAG,CAACT,aAAa,GAAGE,WAAjB,KAAiCD,cAAc,GAAG,CAACA,cAAc,GAAG,CAAlB,IAAuBO,aAAzE,CAAhB;AACAC,IAAAA,SAAS,GAAGnB,IAAI,CAACoB,GAAL,CAASD,SAAT,EAAoB,CAApB,CAAZ,CAT6D,CASzB;;AAEpC7E,IAAAA,MAAM,CAACkD,IAAP,CAAYsB,MAAZ,EAAoB,UAAUO,MAAV,EAAkBC,KAAlB,EAAyB;AAC3C,UAAIP,QAAQ,GAAGM,MAAM,CAACN,QAAtB;;AAEA,UAAIA,QAAQ,IAAIA,QAAQ,GAAGI,SAA3B,EAAsC;AACpCJ,QAAAA,QAAQ,GAAGf,IAAI,CAACgB,GAAL,CAASD,QAAT,EAAmBL,aAAnB,CAAX;;AAEA,YAAIW,MAAM,CAACxC,KAAX,EAAkB;AAChBkC,UAAAA,QAAQ,GAAGf,IAAI,CAACgB,GAAL,CAASD,QAAT,EAAmBM,MAAM,CAACxC,KAA1B,CAAX;AACD;;AAED6B,QAAAA,aAAa,IAAIK,QAAjB;AACAM,QAAAA,MAAM,CAACxC,KAAP,GAAekC,QAAf;AACAJ,QAAAA,cAAc;AACf;AACF,KAdD,EAX6D,CAyBzD;;AAEJQ,IAAAA,SAAS,GAAG,CAACT,aAAa,GAAGE,WAAjB,KAAiCD,cAAc,GAAG,CAACA,cAAc,GAAG,CAAlB,IAAuBO,aAAzE,CAAZ;AACAC,IAAAA,SAAS,GAAGnB,IAAI,CAACoB,GAAL,CAASD,SAAT,EAAoB,CAApB,CAAZ;AACA,QAAII,QAAQ,GAAG,CAAf;AACA,QAAIC,UAAJ;AACAlF,IAAAA,MAAM,CAACkD,IAAP,CAAYsB,MAAZ,EAAoB,UAAUO,MAAV,EAAkBb,GAAlB,EAAuB;AACzC,UAAI,CAACa,MAAM,CAACxC,KAAZ,EAAmB;AACjBwC,QAAAA,MAAM,CAACxC,KAAP,GAAesC,SAAf;AACD;;AAEDK,MAAAA,UAAU,GAAGH,MAAb;AACAE,MAAAA,QAAQ,IAAIF,MAAM,CAACxC,KAAP,IAAgB,IAAIqC,aAApB,CAAZ;AACD,KAPD;;AASA,QAAIM,UAAJ,EAAgB;AACdD,MAAAA,QAAQ,IAAIC,UAAU,CAAC3C,KAAX,GAAmBqC,aAA/B;AACD;;AAED,QAAItC,MAAM,GAAG,CAAC2C,QAAD,GAAY,CAAzB;AACAjF,IAAAA,MAAM,CAACkD,IAAP,CAAYsB,MAAZ,EAAoB,UAAUO,MAAV,EAAkB/C,OAAlB,EAA2B;AAC7CG,MAAAA,MAAM,CAACwC,YAAD,CAAN,CAAqB3C,OAArB,IAAgCG,MAAM,CAACwC,YAAD,CAAN,CAAqB3C,OAArB,KAAiC;AAC/DM,QAAAA,MAAM,EAAEA,MADuD;AAE/DC,QAAAA,KAAK,EAAEwC,MAAM,CAACxC;AAFiD,OAAjE;AAIAD,MAAAA,MAAM,IAAIyC,MAAM,CAACxC,KAAP,IAAgB,IAAIqC,aAApB,CAAV;AACD,KAND;AAOD,GApDD;AAqDA,SAAOzC,MAAP;AACD;AACD;;;;;;;;AAQA,SAASgD,oBAAT,CAA8BC,iBAA9B,EAAiDnE,IAAjD,EAAuDJ,WAAvD,EAAoE;AAClE,MAAIuE,iBAAiB,IAAInE,IAAzB,EAA+B;AAC7B,QAAIkB,MAAM,GAAGiD,iBAAiB,CAACpE,UAAU,CAACC,IAAD,CAAX,CAA9B;;AAEA,QAAIkB,MAAM,IAAI,IAAV,IAAkBtB,WAAW,IAAI,IAArC,EAA2C;AACzCsB,MAAAA,MAAM,GAAGA,MAAM,CAACvB,gBAAgB,CAACC,WAAD,CAAjB,CAAf;AACD;;AAED,WAAOsB,MAAP;AACD;AACF;AACD;;;;;;AAMA,SAASkD,MAAT,CAAgB5C,UAAhB,EAA4BC,OAA5B,EAAqC;AACnC,MAAIC,YAAY,GAAGH,sBAAsB,CAACC,UAAD,EAAaC,OAAb,CAAzC;AACA,MAAI0C,iBAAiB,GAAGrC,gBAAgB,CAACJ,YAAD,CAAxC;AACA,MAAI2C,eAAe,GAAG,EAAtB;AACA,MAAIC,qBAAqB,GAAG,EAA5B;AACAvF,EAAAA,MAAM,CAACkD,IAAP,CAAYP,YAAZ,EAA0B,UAAU9B,WAAV,EAAuB;AAC/C,QAAIsC,IAAI,GAAGtC,WAAW,CAACuC,OAAZ,EAAX;AACA,QAAIC,SAAS,GAAGxC,WAAW,CAACyC,gBAA5B;AACA,QAAI/B,QAAQ,GAAG8B,SAAS,CAACE,WAAV,EAAf;AACA,QAAIvB,OAAO,GAAGpB,gBAAgB,CAACC,WAAD,CAA9B;AACA,QAAI2E,gBAAgB,GAAGJ,iBAAiB,CAACpE,UAAU,CAACO,QAAD,CAAX,CAAjB,CAAwCS,OAAxC,CAAvB;AACA,QAAIyD,YAAY,GAAGD,gBAAgB,CAAClD,MAApC;AACA,QAAIoD,WAAW,GAAGF,gBAAgB,CAACjD,KAAnC;AACA,QAAIoD,SAAS,GAAGtC,SAAS,CAACuC,YAAV,CAAuBrE,QAAvB,CAAhB;AACA,QAAIsE,YAAY,GAAGhF,WAAW,CAACC,GAAZ,CAAgB,cAAhB,KAAmC,CAAtD;AACAwE,IAAAA,eAAe,CAACtD,OAAD,CAAf,GAA2BsD,eAAe,CAACtD,OAAD,CAAf,IAA4B,EAAvD;AACAuD,IAAAA,qBAAqB,CAACvD,OAAD,CAArB,GAAiCuD,qBAAqB,CAACvD,OAAD,CAArB,IAAkC,EAAnE,CAX+C,CAWwB;;AAEvEmB,IAAAA,IAAI,CAAC2C,SAAL,CAAe;AACbxD,MAAAA,MAAM,EAAEmD,YADK;AAEbM,MAAAA,IAAI,EAAEL;AAFO,KAAf;AAIA,QAAIM,QAAQ,GAAG7C,IAAI,CAAC8C,YAAL,CAAkBN,SAAS,CAACzE,GAA5B,CAAf;AACA,QAAIgF,OAAO,GAAG/C,IAAI,CAAC8C,YAAL,CAAkB1E,QAAQ,CAACL,GAA3B,CAAd;AACA,QAAIiF,OAAO,GAAG9F,kBAAkB,CAAC8C,IAAD,EAAO6C;AACvC;AADgC,KAAhC;AAGA,QAAII,YAAY,GAAGT,SAAS,CAACU,YAAV,EAAnB;AACA,QAAIC,cAAc,GAAGC,iBAAiB,CAAChF,QAAD,EAAWoE,SAAX,EAAsBQ,OAAtB,CAAtC;;AAEA,SAAK,IAAIjC,GAAG,GAAG,CAAV,EAAasC,GAAG,GAAGrD,IAAI,CAACtB,KAAL,EAAxB,EAAsCqC,GAAG,GAAGsC,GAA5C,EAAiDtC,GAAG,EAApD,EAAwD;AACtD,UAAIuC,KAAK,GAAGtD,IAAI,CAACrC,GAAL,CAASkF,QAAT,EAAmB9B,GAAnB,CAAZ;AACA,UAAIwC,SAAS,GAAGvD,IAAI,CAACrC,GAAL,CAASoF,OAAT,EAAkBhC,GAAlB,CAAhB;;AAEA,UAAIyC,KAAK,CAACF,KAAD,CAAT,EAAkB;AAChB;AACD;;AAED,UAAIG,IAAI,GAAGH,KAAK,IAAI,CAAT,GAAa,GAAb,GAAmB,GAA9B;AACA,UAAII,SAAS,GAAGP,cAAhB,CATsD,CAStB;AAChC;;AAEA,UAAIH,OAAJ,EAAa;AACX;AACA,YAAI,CAACb,eAAe,CAACtD,OAAD,CAAf,CAAyB0E,SAAzB,CAAL,EAA0C;AACxCpB,UAAAA,eAAe,CAACtD,OAAD,CAAf,CAAyB0E,SAAzB,IAAsC;AACpCI,YAAAA,CAAC,EAAER,cADiC;AAEpC;AACAS,YAAAA,CAAC,EAAET,cAHiC,CAGlB;;AAHkB,WAAtC;AAMD,SATU,CAST;;;AAGFO,QAAAA,SAAS,GAAGvB,eAAe,CAACtD,OAAD,CAAf,CAAyB0E,SAAzB,EAAoCE,IAApC,CAAZ;AACD;;AAED,UAAII,CAAJ;AACA,UAAIC,CAAJ;AACA,UAAI1E,KAAJ;AACA,UAAI2E,MAAJ;;AAEA,UAAId,YAAJ,EAAkB;AAChB,YAAIe,KAAK,GAAG9D,SAAS,CAAC+D,WAAV,CAAsB,CAACX,KAAD,EAAQC,SAAR,CAAtB,CAAZ;AACAM,QAAAA,CAAC,GAAGH,SAAJ;AACAI,QAAAA,CAAC,GAAGE,KAAK,CAAC,CAAD,CAAL,GAAW1B,YAAf;AACAlD,QAAAA,KAAK,GAAG4E,KAAK,CAAC,CAAD,CAAL,GAAWb,cAAnB;AACAY,QAAAA,MAAM,GAAGxB,WAAT;;AAEA,YAAIhC,IAAI,CAACC,GAAL,CAASpB,KAAT,IAAkBsD,YAAtB,EAAoC;AAClCtD,UAAAA,KAAK,GAAG,CAACA,KAAK,GAAG,CAAR,GAAY,CAAC,CAAb,GAAiB,CAAlB,IAAuBsD,YAA/B;AACD;;AAEDM,QAAAA,OAAO,KAAKb,eAAe,CAACtD,OAAD,CAAf,CAAyB0E,SAAzB,EAAoCE,IAApC,KAA6CrE,KAAlD,CAAP;AACD,OAZD,MAYO;AACL,YAAI4E,KAAK,GAAG9D,SAAS,CAAC+D,WAAV,CAAsB,CAACV,SAAD,EAAYD,KAAZ,CAAtB,CAAZ;AACAO,QAAAA,CAAC,GAAGG,KAAK,CAAC,CAAD,CAAL,GAAW1B,YAAf;AACAwB,QAAAA,CAAC,GAAGJ,SAAJ;AACAtE,QAAAA,KAAK,GAAGmD,WAAR;AACAwB,QAAAA,MAAM,GAAGC,KAAK,CAAC,CAAD,CAAL,GAAWb,cAApB;;AAEA,YAAI5C,IAAI,CAACC,GAAL,CAASuD,MAAT,IAAmBrB,YAAvB,EAAqC;AACnC;AACAqB,UAAAA,MAAM,GAAG,CAACA,MAAM,IAAI,CAAV,GAAc,CAAC,CAAf,GAAmB,CAApB,IAAyBrB,YAAlC;AACD;;AAEDM,QAAAA,OAAO,KAAKb,eAAe,CAACtD,OAAD,CAAf,CAAyB0E,SAAzB,EAAoCE,IAApC,KAA6CM,MAAlD,CAAP;AACD;;AAED/D,MAAAA,IAAI,CAACkE,aAAL,CAAmBnD,GAAnB,EAAwB;AACtB8C,QAAAA,CAAC,EAAEA,CADmB;AAEtBC,QAAAA,CAAC,EAAEA,CAFmB;AAGtB1E,QAAAA,KAAK,EAAEA,KAHe;AAItB2E,QAAAA,MAAM,EAAEA;AAJc,OAAxB;AAMD;AACF,GA3FD,EA2FG,IA3FH;AA4FD,C,CAAC;;;AAGF,IAAII,WAAW,GAAG;AAChB7E,EAAAA,UAAU,EAAE,KADI;AAEhB8E,EAAAA,IAAI,EAAEjH,mBAAmB,EAFT;AAGhBkH,EAAAA,KAAK,EAAE,eAAU3G,WAAV,EAAuB;AAC5B,QAAI,CAACgC,aAAa,CAAChC,WAAD,CAAd,IAA+B,CAACiC,aAAa,CAACjC,WAAD,CAAjD,EAAgE;AAC9D;AACD;;AAED,QAAIsC,IAAI,GAAGtC,WAAW,CAACuC,OAAZ,EAAX;AACA,QAAIC,SAAS,GAAGxC,WAAW,CAACyC,gBAA5B;AACA,QAAI/B,QAAQ,GAAG8B,SAAS,CAACE,WAAV,EAAf;AACA,QAAIoC,SAAS,GAAGtC,SAAS,CAACuC,YAAV,CAAuBrE,QAAvB,CAAhB;AACA,QAAIyE,QAAQ,GAAG7C,IAAI,CAAC8C,YAAL,CAAkBN,SAAS,CAACzE,GAA5B,CAAf;AACA,QAAIgF,OAAO,GAAG/C,IAAI,CAAC8C,YAAL,CAAkB1E,QAAQ,CAACL,GAA3B,CAAd;AACA,QAAIuG,mBAAmB,GAAG9B,SAAS,CAACU,YAAV,EAA1B;AACA,QAAIqB,WAAW,GAAGD,mBAAmB,GAAG,CAAH,GAAO,CAA5C;AACA,QAAI7D,QAAQ,GAAGuB,oBAAoB,CAACpC,gBAAgB,CAAC,CAAClC,WAAD,CAAD,CAAjB,EAAkCU,QAAlC,EAA4CV,WAA5C,CAApB,CAA6E0B,KAA5F;;AAEA,QAAI,EAAEqB,QAAQ,GAAGpD,mBAAb,CAAJ,EAAuC;AACrC;AACAoD,MAAAA,QAAQ,GAAGpD,mBAAX;AACD;;AAED,WAAO;AACLmH,MAAAA,QAAQ,EAAEA;AADL,KAAP;;AAIA,aAASA,QAAT,CAAkBrG,MAAlB,EAA0B6B,IAA1B,EAAgC;AAC9B,UAAIyE,WAAW,GAAG,IAAInH,QAAJ,CAAaa,MAAM,CAACO,KAAP,GAAe,CAA5B,CAAlB;AACA,UAAIgG,SAAJ;AACA,UAAIV,KAAK,GAAG,EAAZ;AACA,UAAIW,SAAS,GAAG,EAAhB;AACA,UAAIxF,MAAM,GAAG,CAAb;;AAEA,aAAO,CAACuF,SAAS,GAAGvG,MAAM,CAACyG,IAAP,EAAb,KAA+B,IAAtC,EAA4C;AAC1CD,QAAAA,SAAS,CAACJ,WAAD,CAAT,GAAyBvE,IAAI,CAACrC,GAAL,CAASkF,QAAT,EAAmB6B,SAAnB,CAAzB;AACAC,QAAAA,SAAS,CAAC,IAAIJ,WAAL,CAAT,GAA6BvE,IAAI,CAACrC,GAAL,CAASoF,OAAT,EAAkB2B,SAAlB,CAA7B;AACAV,QAAAA,KAAK,GAAG9D,SAAS,CAAC+D,WAAV,CAAsBU,SAAtB,EAAiC,IAAjC,EAAuCX,KAAvC,CAAR;AACAS,QAAAA,WAAW,CAACtF,MAAM,EAAP,CAAX,GAAwB6E,KAAK,CAAC,CAAD,CAA7B;AACAS,QAAAA,WAAW,CAACtF,MAAM,EAAP,CAAX,GAAwB6E,KAAK,CAAC,CAAD,CAA7B;AACD;;AAEDhE,MAAAA,IAAI,CAAC2C,SAAL,CAAe;AACb8B,QAAAA,WAAW,EAAEA,WADA;AAEbhE,QAAAA,QAAQ,EAAEA,QAFG;AAGb0C,QAAAA,cAAc,EAAEC,iBAAiB,CAAChF,QAAD,EAAWoE,SAAX,EAAsB,KAAtB,CAHpB;AAIb8B,QAAAA,mBAAmB,EAAEA;AAJR,OAAf;AAMD;AACF;AAjDe,CAAlB;;AAoDA,SAAS5E,aAAT,CAAuBhC,WAAvB,EAAoC;AAClC,SAAOA,WAAW,CAACyC,gBAAZ,IAAgCzC,WAAW,CAACyC,gBAAZ,CAA6B7B,IAA7B,KAAsC,aAA7E;AACD;;AAED,SAASqB,aAAT,CAAuBjC,WAAvB,EAAoC;AAClC,SAAOA,WAAW,CAACmH,eAAZ,IAA+BnH,WAAW,CAACmH,eAAZ,CAA4BC,KAAlE;AACD,C,CAAC;;;AAGF,SAAS1B,iBAAT,CAA2BhF,QAA3B,EAAqCoE,SAArC,EAAgDQ,OAAhD,EAAyD;AACvD,MAAI+B,MAAM,GAAGvC,SAAS,CAACwC,eAAV,EAAb;AACA,MAAIzD,GAAJ;AACA,MAAII,GAAJ;;AAEA,MAAIoD,MAAM,CAAC,CAAD,CAAN,GAAYA,MAAM,CAAC,CAAD,CAAtB,EAA2B;AACzBxD,IAAAA,GAAG,GAAGwD,MAAM,CAAC,CAAD,CAAZ;AACApD,IAAAA,GAAG,GAAGoD,MAAM,CAAC,CAAD,CAAZ;AACD,GAHD,MAGO;AACLxD,IAAAA,GAAG,GAAGwD,MAAM,CAAC,CAAD,CAAZ;AACApD,IAAAA,GAAG,GAAGoD,MAAM,CAAC,CAAD,CAAZ;AACD;;AAED,MAAIE,UAAU,GAAGzC,SAAS,CAAC0C,aAAV,CAAwB1C,SAAS,CAAC2C,WAAV,CAAsB,CAAtB,CAAxB,CAAjB;AACAF,EAAAA,UAAU,GAAG1D,GAAb,KAAqB0D,UAAU,GAAG1D,GAAlC;AACA0D,EAAAA,UAAU,GAAGtD,GAAb,KAAqBsD,UAAU,GAAGtD,GAAlC;AACA,SAAOsD,UAAP;AACD;;AAEDG,OAAO,CAACnH,eAAR,GAA0BA,eAA1B;AACAmH,OAAO,CAAC/F,sBAAR,GAAiCA,sBAAjC;AACA+F,OAAO,CAACxF,gBAAR,GAA2BA,gBAA3B;AACAwF,OAAO,CAACpD,oBAAR,GAA+BA,oBAA/B;AACAoD,OAAO,CAAClD,MAAR,GAAiBA,MAAjB;AACAkD,OAAO,CAACjB,WAAR,GAAsBA,WAAtB","sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar _number = require(\"../util/number\");\n\nvar parsePercent = _number.parsePercent;\n\nvar _dataStackHelper = require(\"../data/helper/dataStackHelper\");\n\nvar isDimensionStacked = _dataStackHelper.isDimensionStacked;\n\nvar createRenderPlanner = require(\"../chart/helper/createRenderPlanner\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/* global Float32Array */\nvar STACK_PREFIX = '__ec_stack_';\nvar LARGE_BAR_MIN_WIDTH = 0.5;\nvar LargeArr = typeof Float32Array !== 'undefined' ? Float32Array : Array;\n\nfunction getSeriesStackId(seriesModel) {\n  return seriesModel.get('stack') || STACK_PREFIX + seriesModel.seriesIndex;\n}\n\nfunction getAxisKey(axis) {\n  return axis.dim + axis.index;\n}\n/**\n * @param {Object} opt\n * @param {module:echarts/coord/Axis} opt.axis Only support category axis currently.\n * @param {number} opt.count Positive interger.\n * @param {number} [opt.barWidth]\n * @param {number} [opt.barMaxWidth]\n * @param {number} [opt.barGap]\n * @param {number} [opt.barCategoryGap]\n * @return {Object} {width, offset, offsetCenter} If axis.type is not 'category', return undefined.\n */\n\n\nfunction getLayoutOnAxis(opt) {\n  var params = [];\n  var baseAxis = opt.axis;\n  var axisKey = 'axis0';\n\n  if (baseAxis.type !== 'category') {\n    return;\n  }\n\n  var bandWidth = baseAxis.getBandWidth();\n\n  for (var i = 0; i < opt.count || 0; i++) {\n    params.push(zrUtil.defaults({\n      bandWidth: bandWidth,\n      axisKey: axisKey,\n      stackId: STACK_PREFIX + i\n    }, opt));\n  }\n\n  var widthAndOffsets = doCalBarWidthAndOffset(params);\n  var result = [];\n\n  for (var i = 0; i < opt.count; i++) {\n    var item = widthAndOffsets[axisKey][STACK_PREFIX + i];\n    item.offsetCenter = item.offset + item.width / 2;\n    result.push(item);\n  }\n\n  return result;\n}\n\nfunction prepareLayoutBarSeries(seriesType, ecModel) {\n  var seriesModels = [];\n  ecModel.eachSeriesByType(seriesType, function (seriesModel) {\n    // Check series coordinate, do layout for cartesian2d only\n    if (isOnCartesian(seriesModel) && !isInLargeMode(seriesModel)) {\n      seriesModels.push(seriesModel);\n    }\n  });\n  return seriesModels;\n}\n\nfunction makeColumnLayout(barSeries) {\n  var seriesInfoList = [];\n  zrUtil.each(barSeries, function (seriesModel) {\n    var data = seriesModel.getData();\n    var cartesian = seriesModel.coordinateSystem;\n    var baseAxis = cartesian.getBaseAxis();\n    var axisExtent = baseAxis.getExtent();\n    var bandWidth = baseAxis.type === 'category' ? baseAxis.getBandWidth() : Math.abs(axisExtent[1] - axisExtent[0]) / data.count();\n    var barWidth = parsePercent(seriesModel.get('barWidth'), bandWidth);\n    var barMaxWidth = parsePercent(seriesModel.get('barMaxWidth'), bandWidth);\n    var barGap = seriesModel.get('barGap');\n    var barCategoryGap = seriesModel.get('barCategoryGap');\n    seriesInfoList.push({\n      bandWidth: bandWidth,\n      barWidth: barWidth,\n      barMaxWidth: barMaxWidth,\n      barGap: barGap,\n      barCategoryGap: barCategoryGap,\n      axisKey: getAxisKey(baseAxis),\n      stackId: getSeriesStackId(seriesModel)\n    });\n  });\n  return doCalBarWidthAndOffset(seriesInfoList);\n}\n\nfunction doCalBarWidthAndOffset(seriesInfoList) {\n  // Columns info on each category axis. Key is cartesian name\n  var columnsMap = {};\n  zrUtil.each(seriesInfoList, function (seriesInfo, idx) {\n    var axisKey = seriesInfo.axisKey;\n    var bandWidth = seriesInfo.bandWidth;\n    var columnsOnAxis = columnsMap[axisKey] || {\n      bandWidth: bandWidth,\n      remainedWidth: bandWidth,\n      autoWidthCount: 0,\n      categoryGap: '20%',\n      gap: '30%',\n      stacks: {}\n    };\n    var stacks = columnsOnAxis.stacks;\n    columnsMap[axisKey] = columnsOnAxis;\n    var stackId = seriesInfo.stackId;\n\n    if (!stacks[stackId]) {\n      columnsOnAxis.autoWidthCount++;\n    }\n\n    stacks[stackId] = stacks[stackId] || {\n      width: 0,\n      maxWidth: 0\n    }; // Caution: In a single coordinate system, these barGrid attributes\n    // will be shared by series. Consider that they have default values,\n    // only the attributes set on the last series will work.\n    // Do not change this fact unless there will be a break change.\n    // TODO\n\n    var barWidth = seriesInfo.barWidth;\n\n    if (barWidth && !stacks[stackId].width) {\n      // See #6312, do not restrict width.\n      stacks[stackId].width = barWidth;\n      barWidth = Math.min(columnsOnAxis.remainedWidth, barWidth);\n      columnsOnAxis.remainedWidth -= barWidth;\n    }\n\n    var barMaxWidth = seriesInfo.barMaxWidth;\n    barMaxWidth && (stacks[stackId].maxWidth = barMaxWidth);\n    var barGap = seriesInfo.barGap;\n    barGap != null && (columnsOnAxis.gap = barGap);\n    var barCategoryGap = seriesInfo.barCategoryGap;\n    barCategoryGap != null && (columnsOnAxis.categoryGap = barCategoryGap);\n  });\n  var result = {};\n  zrUtil.each(columnsMap, function (columnsOnAxis, coordSysName) {\n    result[coordSysName] = {};\n    var stacks = columnsOnAxis.stacks;\n    var bandWidth = columnsOnAxis.bandWidth;\n    var categoryGap = parsePercent(columnsOnAxis.categoryGap, bandWidth);\n    var barGapPercent = parsePercent(columnsOnAxis.gap, 1);\n    var remainedWidth = columnsOnAxis.remainedWidth;\n    var autoWidthCount = columnsOnAxis.autoWidthCount;\n    var autoWidth = (remainedWidth - categoryGap) / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);\n    autoWidth = Math.max(autoWidth, 0); // Find if any auto calculated bar exceeded maxBarWidth\n\n    zrUtil.each(stacks, function (column, stack) {\n      var maxWidth = column.maxWidth;\n\n      if (maxWidth && maxWidth < autoWidth) {\n        maxWidth = Math.min(maxWidth, remainedWidth);\n\n        if (column.width) {\n          maxWidth = Math.min(maxWidth, column.width);\n        }\n\n        remainedWidth -= maxWidth;\n        column.width = maxWidth;\n        autoWidthCount--;\n      }\n    }); // Recalculate width again\n\n    autoWidth = (remainedWidth - categoryGap) / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);\n    autoWidth = Math.max(autoWidth, 0);\n    var widthSum = 0;\n    var lastColumn;\n    zrUtil.each(stacks, function (column, idx) {\n      if (!column.width) {\n        column.width = autoWidth;\n      }\n\n      lastColumn = column;\n      widthSum += column.width * (1 + barGapPercent);\n    });\n\n    if (lastColumn) {\n      widthSum -= lastColumn.width * barGapPercent;\n    }\n\n    var offset = -widthSum / 2;\n    zrUtil.each(stacks, function (column, stackId) {\n      result[coordSysName][stackId] = result[coordSysName][stackId] || {\n        offset: offset,\n        width: column.width\n      };\n      offset += column.width * (1 + barGapPercent);\n    });\n  });\n  return result;\n}\n/**\n * @param {Object} barWidthAndOffset The result of makeColumnLayout\n * @param {module:echarts/coord/Axis} axis\n * @param {module:echarts/model/Series} [seriesModel] If not provided, return all.\n * @return {Object} {stackId: {offset, width}} or {offset, width} if seriesModel provided.\n */\n\n\nfunction retrieveColumnLayout(barWidthAndOffset, axis, seriesModel) {\n  if (barWidthAndOffset && axis) {\n    var result = barWidthAndOffset[getAxisKey(axis)];\n\n    if (result != null && seriesModel != null) {\n      result = result[getSeriesStackId(seriesModel)];\n    }\n\n    return result;\n  }\n}\n/**\n * @param {string} seriesType\n * @param {module:echarts/model/Global} ecModel\n */\n\n\nfunction layout(seriesType, ecModel) {\n  var seriesModels = prepareLayoutBarSeries(seriesType, ecModel);\n  var barWidthAndOffset = makeColumnLayout(seriesModels);\n  var lastStackCoords = {};\n  var lastStackCoordsOrigin = {};\n  zrUtil.each(seriesModels, function (seriesModel) {\n    var data = seriesModel.getData();\n    var cartesian = seriesModel.coordinateSystem;\n    var baseAxis = cartesian.getBaseAxis();\n    var stackId = getSeriesStackId(seriesModel);\n    var columnLayoutInfo = barWidthAndOffset[getAxisKey(baseAxis)][stackId];\n    var columnOffset = columnLayoutInfo.offset;\n    var columnWidth = columnLayoutInfo.width;\n    var valueAxis = cartesian.getOtherAxis(baseAxis);\n    var barMinHeight = seriesModel.get('barMinHeight') || 0;\n    lastStackCoords[stackId] = lastStackCoords[stackId] || [];\n    lastStackCoordsOrigin[stackId] = lastStackCoordsOrigin[stackId] || []; // Fix #4243\n\n    data.setLayout({\n      offset: columnOffset,\n      size: columnWidth\n    });\n    var valueDim = data.mapDimension(valueAxis.dim);\n    var baseDim = data.mapDimension(baseAxis.dim);\n    var stacked = isDimensionStacked(data, valueDim\n    /*, baseDim*/\n    );\n    var isValueAxisH = valueAxis.isHorizontal();\n    var valueAxisStart = getValueAxisStart(baseAxis, valueAxis, stacked);\n\n    for (var idx = 0, len = data.count(); idx < len; idx++) {\n      var value = data.get(valueDim, idx);\n      var baseValue = data.get(baseDim, idx);\n\n      if (isNaN(value)) {\n        continue;\n      }\n\n      var sign = value >= 0 ? 'p' : 'n';\n      var baseCoord = valueAxisStart; // Because of the barMinHeight, we can not use the value in\n      // stackResultDimension directly.\n\n      if (stacked) {\n        // Only ordinal axis can be stacked.\n        if (!lastStackCoords[stackId][baseValue]) {\n          lastStackCoords[stackId][baseValue] = {\n            p: valueAxisStart,\n            // Positive stack\n            n: valueAxisStart // Negative stack\n\n          };\n        } // Should also consider #4243\n\n\n        baseCoord = lastStackCoords[stackId][baseValue][sign];\n      }\n\n      var x;\n      var y;\n      var width;\n      var height;\n\n      if (isValueAxisH) {\n        var coord = cartesian.dataToPoint([value, baseValue]);\n        x = baseCoord;\n        y = coord[1] + columnOffset;\n        width = coord[0] - valueAxisStart;\n        height = columnWidth;\n\n        if (Math.abs(width) < barMinHeight) {\n          width = (width < 0 ? -1 : 1) * barMinHeight;\n        }\n\n        stacked && (lastStackCoords[stackId][baseValue][sign] += width);\n      } else {\n        var coord = cartesian.dataToPoint([baseValue, value]);\n        x = coord[0] + columnOffset;\n        y = baseCoord;\n        width = columnWidth;\n        height = coord[1] - valueAxisStart;\n\n        if (Math.abs(height) < barMinHeight) {\n          // Include zero to has a positive bar\n          height = (height <= 0 ? -1 : 1) * barMinHeight;\n        }\n\n        stacked && (lastStackCoords[stackId][baseValue][sign] += height);\n      }\n\n      data.setItemLayout(idx, {\n        x: x,\n        y: y,\n        width: width,\n        height: height\n      });\n    }\n  }, this);\n} // TODO: Do not support stack in large mode yet.\n\n\nvar largeLayout = {\n  seriesType: 'bar',\n  plan: createRenderPlanner(),\n  reset: function (seriesModel) {\n    if (!isOnCartesian(seriesModel) || !isInLargeMode(seriesModel)) {\n      return;\n    }\n\n    var data = seriesModel.getData();\n    var cartesian = seriesModel.coordinateSystem;\n    var baseAxis = cartesian.getBaseAxis();\n    var valueAxis = cartesian.getOtherAxis(baseAxis);\n    var valueDim = data.mapDimension(valueAxis.dim);\n    var baseDim = data.mapDimension(baseAxis.dim);\n    var valueAxisHorizontal = valueAxis.isHorizontal();\n    var valueDimIdx = valueAxisHorizontal ? 0 : 1;\n    var barWidth = retrieveColumnLayout(makeColumnLayout([seriesModel]), baseAxis, seriesModel).width;\n\n    if (!(barWidth > LARGE_BAR_MIN_WIDTH)) {\n      // jshint ignore:line\n      barWidth = LARGE_BAR_MIN_WIDTH;\n    }\n\n    return {\n      progress: progress\n    };\n\n    function progress(params, data) {\n      var largePoints = new LargeArr(params.count * 2);\n      var dataIndex;\n      var coord = [];\n      var valuePair = [];\n      var offset = 0;\n\n      while ((dataIndex = params.next()) != null) {\n        valuePair[valueDimIdx] = data.get(valueDim, dataIndex);\n        valuePair[1 - valueDimIdx] = data.get(baseDim, dataIndex);\n        coord = cartesian.dataToPoint(valuePair, null, coord);\n        largePoints[offset++] = coord[0];\n        largePoints[offset++] = coord[1];\n      }\n\n      data.setLayout({\n        largePoints: largePoints,\n        barWidth: barWidth,\n        valueAxisStart: getValueAxisStart(baseAxis, valueAxis, false),\n        valueAxisHorizontal: valueAxisHorizontal\n      });\n    }\n  }\n};\n\nfunction isOnCartesian(seriesModel) {\n  return seriesModel.coordinateSystem && seriesModel.coordinateSystem.type === 'cartesian2d';\n}\n\nfunction isInLargeMode(seriesModel) {\n  return seriesModel.pipelineContext && seriesModel.pipelineContext.large;\n} // See cases in `test/bar-start.html` and `#7412`, `#8747`.\n\n\nfunction getValueAxisStart(baseAxis, valueAxis, stacked) {\n  var extent = valueAxis.getGlobalExtent();\n  var min;\n  var max;\n\n  if (extent[0] > extent[1]) {\n    min = extent[1];\n    max = extent[0];\n  } else {\n    min = extent[0];\n    max = extent[1];\n  }\n\n  var valueStart = valueAxis.toGlobalCoord(valueAxis.dataToCoord(0));\n  valueStart < min && (valueStart = min);\n  valueStart > max && (valueStart = max);\n  return valueStart;\n}\n\nexports.getLayoutOnAxis = getLayoutOnAxis;\nexports.prepareLayoutBarSeries = prepareLayoutBarSeries;\nexports.makeColumnLayout = makeColumnLayout;\nexports.retrieveColumnLayout = retrieveColumnLayout;\nexports.layout = layout;\nexports.largeLayout = largeLayout;"]},"metadata":{},"sourceType":"script"}