{"ast":null,"code":"/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar _config = require(\"../config\");\n\nvar __DEV__ = _config.__DEV__;\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar Model = require(\"../model/Model\");\n\nvar DataDiffer = require(\"./DataDiffer\");\n\nvar Source = require(\"./Source\");\n\nvar _dataProvider = require(\"./helper/dataProvider\");\n\nvar defaultDimValueGetters = _dataProvider.defaultDimValueGetters;\nvar DefaultDataProvider = _dataProvider.DefaultDataProvider;\n\nvar _dimensionHelper = require(\"./helper/dimensionHelper\");\n\nvar summarizeDimensions = _dimensionHelper.summarizeDimensions;\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/* global Float64Array, Int32Array, Uint32Array, Uint16Array */\n\n/**\n * List for data storage\n * @module echarts/data/List\n */\n\nvar isObject = zrUtil.isObject;\nvar UNDEFINED = 'undefined';\nvar INDEX_NOT_FOUND = -1; // Use prefix to avoid index to be the same as otherIdList[idx],\n// which will cause weird udpate animation.\n\nvar ID_PREFIX = 'e\\0\\0';\nvar dataCtors = {\n  'float': typeof Float64Array === UNDEFINED ? Array : Float64Array,\n  'int': typeof Int32Array === UNDEFINED ? Array : Int32Array,\n  // Ordinal data type can be string or int\n  'ordinal': Array,\n  'number': Array,\n  'time': Array\n}; // Caution: MUST not use `new CtorUint32Array(arr, 0, len)`, because the Ctor of array is\n// different from the Ctor of typed array.\n\nvar CtorUint32Array = typeof Uint32Array === UNDEFINED ? Array : Uint32Array;\nvar CtorInt32Array = typeof Int32Array === UNDEFINED ? Array : Int32Array;\nvar CtorUint16Array = typeof Uint16Array === UNDEFINED ? Array : Uint16Array;\n\nfunction getIndicesCtor(list) {\n  // The possible max value in this._indicies is always this._rawCount despite of filtering.\n  return list._rawCount > 65535 ? CtorUint32Array : CtorUint16Array;\n}\n\nfunction cloneChunk(originalChunk) {\n  var Ctor = originalChunk.constructor; // Only shallow clone is enough when Array.\n\n  return Ctor === Array ? originalChunk.slice() : new Ctor(originalChunk);\n}\n\nvar TRANSFERABLE_PROPERTIES = ['hasItemOption', '_nameList', '_idList', '_invertedIndicesMap', '_rawData', '_chunkSize', '_chunkCount', '_dimValueGetter', '_count', '_rawCount', '_nameDimIdx', '_idDimIdx'];\nvar CLONE_PROPERTIES = ['_extent', '_approximateExtent', '_rawExtent'];\n\nfunction transferProperties(target, source) {\n  zrUtil.each(TRANSFERABLE_PROPERTIES.concat(source.__wrappedMethods || []), function (propName) {\n    if (source.hasOwnProperty(propName)) {\n      target[propName] = source[propName];\n    }\n  });\n  target.__wrappedMethods = source.__wrappedMethods;\n  zrUtil.each(CLONE_PROPERTIES, function (propName) {\n    target[propName] = zrUtil.clone(source[propName]);\n  });\n  target._calculationInfo = zrUtil.extend(source._calculationInfo);\n}\n/**\n * @constructor\n * @alias module:echarts/data/List\n *\n * @param {Array.<string|Object>} dimensions\n *      For example, ['someDimName', {name: 'someDimName', type: 'someDimType'}, ...].\n *      Dimensions should be concrete names like x, y, z, lng, lat, angle, radius\n *      Spetial fields: {\n *          ordinalMeta: <module:echarts/data/OrdinalMeta>\n *          createInvertedIndices: <boolean>\n *      }\n * @param {module:echarts/model/Model} hostModel\n */\n\n\nvar List = function List(dimensions, hostModel) {\n  dimensions = dimensions || ['x', 'y'];\n  var dimensionInfos = {};\n  var dimensionNames = [];\n  var invertedIndicesMap = {};\n\n  for (var i = 0; i < dimensions.length; i++) {\n    // Use the original dimensions[i], where other flag props may exists.\n    var dimensionInfo = dimensions[i];\n\n    if (zrUtil.isString(dimensionInfo)) {\n      dimensionInfo = {\n        name: dimensionInfo\n      };\n    }\n\n    var dimensionName = dimensionInfo.name;\n    dimensionInfo.type = dimensionInfo.type || 'float';\n\n    if (!dimensionInfo.coordDim) {\n      dimensionInfo.coordDim = dimensionName;\n      dimensionInfo.coordDimIndex = 0;\n    }\n\n    dimensionInfo.otherDims = dimensionInfo.otherDims || {};\n    dimensionNames.push(dimensionName);\n    dimensionInfos[dimensionName] = dimensionInfo;\n    dimensionInfo.index = i;\n\n    if (dimensionInfo.createInvertedIndices) {\n      invertedIndicesMap[dimensionName] = [];\n    }\n  }\n  /**\n   * @readOnly\n   * @type {Array.<string>}\n   */\n\n\n  this.dimensions = dimensionNames;\n  /**\n   * Infomation of each data dimension, like data type.\n   * @type {Object}\n   */\n\n  this._dimensionInfos = dimensionInfos;\n  /**\n   * @type {module:echarts/model/Model}\n   */\n\n  this.hostModel = hostModel;\n  /**\n   * @type {module:echarts/model/Model}\n   */\n\n  this.dataType;\n  /**\n   * Indices stores the indices of data subset after filtered.\n   * This data subset will be used in chart.\n   * @type {Array.<number>}\n   * @readOnly\n   */\n\n  this._indices = null;\n  this._count = 0;\n  this._rawCount = 0;\n  /**\n   * Data storage\n   * @type {Object.<key, Array.<TypedArray|Array>>}\n   * @private\n   */\n\n  this._storage = {};\n  /**\n   * @type {Array.<string>}\n   */\n\n  this._nameList = [];\n  /**\n   * @type {Array.<string>}\n   */\n\n  this._idList = [];\n  /**\n   * Models of data option is stored sparse for optimizing memory cost\n   * @type {Array.<module:echarts/model/Model>}\n   * @private\n   */\n\n  this._optionModels = [];\n  /**\n   * Global visual properties after visual coding\n   * @type {Object}\n   * @private\n   */\n\n  this._visual = {};\n  /**\n   * Globel layout properties.\n   * @type {Object}\n   * @private\n   */\n\n  this._layout = {};\n  /**\n   * Item visual properties after visual coding\n   * @type {Array.<Object>}\n   * @private\n   */\n\n  this._itemVisuals = [];\n  /**\n   * Key: visual type, Value: boolean\n   * @type {Object}\n   * @readOnly\n   */\n\n  this.hasItemVisual = {};\n  /**\n   * Item layout properties after layout\n   * @type {Array.<Object>}\n   * @private\n   */\n\n  this._itemLayouts = [];\n  /**\n   * Graphic elemnents\n   * @type {Array.<module:zrender/Element>}\n   * @private\n   */\n\n  this._graphicEls = [];\n  /**\n   * Max size of each chunk.\n   * @type {number}\n   * @private\n   */\n\n  this._chunkSize = 1e5;\n  /**\n   * @type {number}\n   * @private\n   */\n\n  this._chunkCount = 0;\n  /**\n   * @type {Array.<Array|Object>}\n   * @private\n   */\n\n  this._rawData;\n  /**\n   * Raw extent will not be cloned, but only transfered.\n   * It will not be calculated util needed.\n   * key: dim,\n   * value: {end: number, extent: Array.<number>}\n   * @type {Object}\n   * @private\n   */\n\n  this._rawExtent = {};\n  /**\n   * @type {Object}\n   * @private\n   */\n\n  this._extent = {};\n  /**\n   * key: dim\n   * value: extent\n   * @type {Object}\n   * @private\n   */\n\n  this._approximateExtent = {};\n  /**\n   * Cache summary info for fast visit. See \"dimensionHelper\".\n   * @type {Object}\n   * @private\n   */\n\n  this._dimensionsSummary = summarizeDimensions(this);\n  /**\n   * @type {Object.<Array|TypedArray>}\n   * @private\n   */\n\n  this._invertedIndicesMap = invertedIndicesMap;\n  /**\n   * @type {Object}\n   * @private\n   */\n\n  this._calculationInfo = {};\n};\n\nvar listProto = List.prototype;\nlistProto.type = 'list';\n/**\n * If each data item has it's own option\n * @type {boolean}\n */\n\nlistProto.hasItemOption = true;\n/**\n * Get dimension name\n * @param {string|number} dim\n *        Dimension can be concrete names like x, y, z, lng, lat, angle, radius\n *        Or a ordinal number. For example getDimensionInfo(0) will return 'x' or 'lng' or 'radius'\n * @return {string} Concrete dim name.\n */\n\nlistProto.getDimension = function (dim) {\n  if (!isNaN(dim)) {\n    dim = this.dimensions[dim] || dim;\n  }\n\n  return dim;\n};\n/**\n * Get type and calculation info of particular dimension\n * @param {string|number} dim\n *        Dimension can be concrete names like x, y, z, lng, lat, angle, radius\n *        Or a ordinal number. For example getDimensionInfo(0) will return 'x' or 'lng' or 'radius'\n */\n\n\nlistProto.getDimensionInfo = function (dim) {\n  // Do not clone, because there may be categories in dimInfo.\n  return this._dimensionInfos[this.getDimension(dim)];\n};\n/**\n * @return {Array.<string>} concrete dimension name list on coord.\n */\n\n\nlistProto.getDimensionsOnCoord = function () {\n  return this._dimensionsSummary.dataDimsOnCoord.slice();\n};\n/**\n * @param {string} coordDim\n * @param {number} [idx] A coordDim may map to more than one data dim.\n *        If idx is `true`, return a array of all mapped dims.\n *        If idx is not specified, return the first dim not extra.\n * @return {string|Array.<string>} concrete data dim.\n *        If idx is number, and not found, return null/undefined.\n *        If idx is `true`, and not found, return empty array (always return array).\n */\n\n\nlistProto.mapDimension = function (coordDim, idx) {\n  var dimensionsSummary = this._dimensionsSummary;\n\n  if (idx == null) {\n    return dimensionsSummary.encodeFirstDimNotExtra[coordDim];\n  }\n\n  var dims = dimensionsSummary.encode[coordDim];\n  return idx === true // always return array if idx is `true`\n  ? (dims || []).slice() : dims && dims[idx];\n};\n/**\n * Initialize from data\n * @param {Array.<Object|number|Array>} data source or data or data provider.\n * @param {Array.<string>} [nameLIst] The name of a datum is used on data diff and\n *        defualt label/tooltip.\n *        A name can be specified in encode.itemName,\n *        or dataItem.name (only for series option data),\n *        or provided in nameList from outside.\n * @param {Function} [dimValueGetter] (dataItem, dimName, dataIndex, dimIndex) => number\n */\n\n\nlistProto.initData = function (data, nameList, dimValueGetter) {\n  var notProvider = Source.isInstance(data) || zrUtil.isArrayLike(data);\n\n  if (notProvider) {\n    data = new DefaultDataProvider(data, this.dimensions.length);\n  }\n\n  this._rawData = data; // Clear\n\n  this._storage = {};\n  this._indices = null;\n  this._nameList = nameList || [];\n  this._idList = [];\n  this._nameRepeatCount = {};\n\n  if (!dimValueGetter) {\n    this.hasItemOption = false;\n  }\n  /**\n   * @readOnly\n   */\n\n\n  this.defaultDimValueGetter = defaultDimValueGetters[this._rawData.getSource().sourceFormat]; // Default dim value getter\n\n  this._dimValueGetter = dimValueGetter = dimValueGetter || this.defaultDimValueGetter;\n  this._dimValueGetterArrayRows = defaultDimValueGetters.arrayRows; // Reset raw extent.\n\n  this._rawExtent = {};\n\n  this._initDataFromProvider(0, data.count()); // If data has no item option.\n\n\n  if (data.pure) {\n    this.hasItemOption = false;\n  }\n};\n\nlistProto.getProvider = function () {\n  return this._rawData;\n};\n/**\n * Caution: Can be only called on raw data (before `this._indices` created).\n */\n\n\nlistProto.appendData = function (data) {\n  var rawData = this._rawData;\n  var start = this.count();\n  rawData.appendData(data);\n  var end = rawData.count();\n\n  if (!rawData.persistent) {\n    end += start;\n  }\n\n  this._initDataFromProvider(start, end);\n};\n/**\n * Caution: Can be only called on raw data (before `this._indices` created).\n * This method does not modify `rawData` (`dataProvider`), but only\n * add values to storage.\n *\n * The final count will be increased by `Math.max(values.length, names.length)`.\n *\n * @param {Array.<Array.<*>>} values That is the SourceType: 'arrayRows', like\n *        [\n *            [12, 33, 44],\n *            [NaN, 43, 1],\n *            ['-', 'asdf', 0]\n *        ]\n *        Each item is exaclty cooresponding to a dimension.\n * @param {Array.<string>} [names]\n */\n\n\nlistProto.appendValues = function (values, names) {\n  var chunkSize = this._chunkSize;\n  var storage = this._storage;\n  var dimensions = this.dimensions;\n  var dimLen = dimensions.length;\n  var rawExtent = this._rawExtent;\n  var start = this.count();\n  var end = start + Math.max(values.length, names ? names.length : 0);\n  var originalChunkCount = this._chunkCount;\n\n  for (var i = 0; i < dimLen; i++) {\n    var dim = dimensions[i];\n\n    if (!rawExtent[dim]) {\n      rawExtent[dim] = getInitialExtent();\n    }\n\n    if (!storage[dim]) {\n      storage[dim] = [];\n    }\n\n    prepareChunks(storage, this._dimensionInfos[dim], chunkSize, originalChunkCount, end);\n    this._chunkCount = storage[dim].length;\n  }\n\n  var emptyDataItem = new Array(dimLen);\n\n  for (var idx = start; idx < end; idx++) {\n    var sourceIdx = idx - start;\n    var chunkIndex = Math.floor(idx / chunkSize);\n    var chunkOffset = idx % chunkSize; // Store the data by dimensions\n\n    for (var k = 0; k < dimLen; k++) {\n      var dim = dimensions[k];\n\n      var val = this._dimValueGetterArrayRows(values[sourceIdx] || emptyDataItem, dim, sourceIdx, k);\n\n      storage[dim][chunkIndex][chunkOffset] = val;\n      var dimRawExtent = rawExtent[dim];\n      val < dimRawExtent[0] && (dimRawExtent[0] = val);\n      val > dimRawExtent[1] && (dimRawExtent[1] = val);\n    }\n\n    if (names) {\n      this._nameList[idx] = names[sourceIdx];\n    }\n  }\n\n  this._rawCount = this._count = end; // Reset data extent\n\n  this._extent = {};\n  prepareInvertedIndex(this);\n};\n\nlistProto._initDataFromProvider = function (start, end) {\n  // Optimize.\n  if (start >= end) {\n    return;\n  }\n\n  var chunkSize = this._chunkSize;\n  var rawData = this._rawData;\n  var storage = this._storage;\n  var dimensions = this.dimensions;\n  var dimLen = dimensions.length;\n  var dimensionInfoMap = this._dimensionInfos;\n  var nameList = this._nameList;\n  var idList = this._idList;\n  var rawExtent = this._rawExtent;\n  var nameRepeatCount = this._nameRepeatCount = {};\n  var nameDimIdx;\n  var originalChunkCount = this._chunkCount;\n\n  for (var i = 0; i < dimLen; i++) {\n    var dim = dimensions[i];\n\n    if (!rawExtent[dim]) {\n      rawExtent[dim] = getInitialExtent();\n    }\n\n    var dimInfo = dimensionInfoMap[dim];\n\n    if (dimInfo.otherDims.itemName === 0) {\n      nameDimIdx = this._nameDimIdx = i;\n    }\n\n    if (dimInfo.otherDims.itemId === 0) {\n      this._idDimIdx = i;\n    }\n\n    if (!storage[dim]) {\n      storage[dim] = [];\n    }\n\n    prepareChunks(storage, dimInfo, chunkSize, originalChunkCount, end);\n    this._chunkCount = storage[dim].length;\n  }\n\n  var dataItem = new Array(dimLen);\n\n  for (var idx = start; idx < end; idx++) {\n    // NOTICE: Try not to write things into dataItem\n    dataItem = rawData.getItem(idx, dataItem); // Each data item is value\n    // [1, 2]\n    // 2\n    // Bar chart, line chart which uses category axis\n    // only gives the 'y' value. 'x' value is the indices of category\n    // Use a tempValue to normalize the value to be a (x, y) value\n\n    var chunkIndex = Math.floor(idx / chunkSize);\n    var chunkOffset = idx % chunkSize; // Store the data by dimensions\n\n    for (var k = 0; k < dimLen; k++) {\n      var dim = dimensions[k];\n      var dimStorage = storage[dim][chunkIndex]; // PENDING NULL is empty or zero\n\n      var val = this._dimValueGetter(dataItem, dim, idx, k);\n\n      dimStorage[chunkOffset] = val;\n      var dimRawExtent = rawExtent[dim];\n      val < dimRawExtent[0] && (dimRawExtent[0] = val);\n      val > dimRawExtent[1] && (dimRawExtent[1] = val);\n    } // ??? FIXME not check by pure but sourceFormat?\n    // TODO refactor these logic.\n\n\n    if (!rawData.pure) {\n      var name = nameList[idx];\n\n      if (dataItem && name == null) {\n        // If dataItem is {name: ...}, it has highest priority.\n        // That is appropriate for many common cases.\n        if (dataItem.name != null) {\n          // There is no other place to persistent dataItem.name,\n          // so save it to nameList.\n          nameList[idx] = name = dataItem.name;\n        } else if (nameDimIdx != null) {\n          var nameDim = dimensions[nameDimIdx];\n          var nameDimChunk = storage[nameDim][chunkIndex];\n\n          if (nameDimChunk) {\n            name = nameDimChunk[chunkOffset];\n            var ordinalMeta = dimensionInfoMap[nameDim].ordinalMeta;\n\n            if (ordinalMeta && ordinalMeta.categories.length) {\n              name = ordinalMeta.categories[name];\n            }\n          }\n        }\n      } // Try using the id in option\n      // id or name is used on dynamical data, mapping old and new items.\n\n\n      var id = dataItem == null ? null : dataItem.id;\n\n      if (id == null && name != null) {\n        // Use name as id and add counter to avoid same name\n        nameRepeatCount[name] = nameRepeatCount[name] || 0;\n        id = name;\n\n        if (nameRepeatCount[name] > 0) {\n          id += '__ec__' + nameRepeatCount[name];\n        }\n\n        nameRepeatCount[name]++;\n      }\n\n      id != null && (idList[idx] = id);\n    }\n  }\n\n  if (!rawData.persistent && rawData.clean) {\n    // Clean unused data if data source is typed array.\n    rawData.clean();\n  }\n\n  this._rawCount = this._count = end; // Reset data extent\n\n  this._extent = {};\n  prepareInvertedIndex(this);\n};\n\nfunction prepareChunks(storage, dimInfo, chunkSize, chunkCount, end) {\n  var DataCtor = dataCtors[dimInfo.type];\n  var lastChunkIndex = chunkCount - 1;\n  var dim = dimInfo.name;\n  var resizeChunkArray = storage[dim][lastChunkIndex];\n\n  if (resizeChunkArray && resizeChunkArray.length < chunkSize) {\n    var newStore = new DataCtor(Math.min(end - lastChunkIndex * chunkSize, chunkSize)); // The cost of the copy is probably inconsiderable\n    // within the initial chunkSize.\n\n    for (var j = 0; j < resizeChunkArray.length; j++) {\n      newStore[j] = resizeChunkArray[j];\n    }\n\n    storage[dim][lastChunkIndex] = newStore;\n  } // Create new chunks.\n\n\n  for (var k = chunkCount * chunkSize; k < end; k += chunkSize) {\n    storage[dim].push(new DataCtor(Math.min(end - k, chunkSize)));\n  }\n}\n\nfunction prepareInvertedIndex(list) {\n  var invertedIndicesMap = list._invertedIndicesMap;\n  zrUtil.each(invertedIndicesMap, function (invertedIndices, dim) {\n    var dimInfo = list._dimensionInfos[dim]; // Currently, only dimensions that has ordinalMeta can create inverted indices.\n\n    var ordinalMeta = dimInfo.ordinalMeta;\n\n    if (ordinalMeta) {\n      invertedIndices = invertedIndicesMap[dim] = new CtorInt32Array(ordinalMeta.categories.length); // The default value of TypedArray is 0. To avoid miss\n      // mapping to 0, we should set it as INDEX_NOT_FOUND.\n\n      for (var i = 0; i < invertedIndices.length; i++) {\n        invertedIndices[i] = INDEX_NOT_FOUND;\n      }\n\n      for (var i = 0; i < list._count; i++) {\n        // Only support the case that all values are distinct.\n        invertedIndices[list.get(dim, i)] = i;\n      }\n    }\n  });\n}\n\nfunction getRawValueFromStore(list, dimIndex, rawIndex) {\n  var val;\n\n  if (dimIndex != null) {\n    var chunkSize = list._chunkSize;\n    var chunkIndex = Math.floor(rawIndex / chunkSize);\n    var chunkOffset = rawIndex % chunkSize;\n    var dim = list.dimensions[dimIndex];\n    var chunk = list._storage[dim][chunkIndex];\n\n    if (chunk) {\n      val = chunk[chunkOffset];\n      var ordinalMeta = list._dimensionInfos[dim].ordinalMeta;\n\n      if (ordinalMeta && ordinalMeta.categories.length) {\n        val = ordinalMeta.categories[val];\n      }\n    }\n  }\n\n  return val;\n}\n/**\n * @return {number}\n */\n\n\nlistProto.count = function () {\n  return this._count;\n};\n\nlistProto.getIndices = function () {\n  var newIndices;\n  var indices = this._indices;\n\n  if (indices) {\n    var Ctor = indices.constructor;\n    var thisCount = this._count; // `new Array(a, b, c)` is different from `new Uint32Array(a, b, c)`.\n\n    if (Ctor === Array) {\n      newIndices = new Ctor(thisCount);\n\n      for (var i = 0; i < thisCount; i++) {\n        newIndices[i] = indices[i];\n      }\n    } else {\n      newIndices = new Ctor(indices.buffer, 0, thisCount);\n    }\n  } else {\n    var Ctor = getIndicesCtor(this);\n    var newIndices = new Ctor(this.count());\n\n    for (var i = 0; i < newIndices.length; i++) {\n      newIndices[i] = i;\n    }\n  }\n\n  return newIndices;\n};\n/**\n * Get value. Return NaN if idx is out of range.\n * @param {string} dim Dim must be concrete name.\n * @param {number} idx\n * @param {boolean} stack\n * @return {number}\n */\n\n\nlistProto.get = function (dim, idx\n/*, stack */\n) {\n  if (!(idx >= 0 && idx < this._count)) {\n    return NaN;\n  }\n\n  var storage = this._storage;\n\n  if (!storage[dim]) {\n    // TODO Warn ?\n    return NaN;\n  }\n\n  idx = this.getRawIndex(idx);\n  var chunkIndex = Math.floor(idx / this._chunkSize);\n  var chunkOffset = idx % this._chunkSize;\n  var chunkStore = storage[dim][chunkIndex];\n  var value = chunkStore[chunkOffset]; // FIXME ordinal data type is not stackable\n  // if (stack) {\n  //     var dimensionInfo = this._dimensionInfos[dim];\n  //     if (dimensionInfo && dimensionInfo.stackable) {\n  //         var stackedOn = this.stackedOn;\n  //         while (stackedOn) {\n  //             // Get no stacked data of stacked on\n  //             var stackedValue = stackedOn.get(dim, idx);\n  //             // Considering positive stack, negative stack and empty data\n  //             if ((value >= 0 && stackedValue > 0)  // Positive stack\n  //                 || (value <= 0 && stackedValue < 0) // Negative stack\n  //             ) {\n  //                 value += stackedValue;\n  //             }\n  //             stackedOn = stackedOn.stackedOn;\n  //         }\n  //     }\n  // }\n\n  return value;\n};\n/**\n * @param {string} dim concrete dim\n * @param {number} rawIndex\n * @return {number|string}\n */\n\n\nlistProto.getByRawIndex = function (dim, rawIdx) {\n  if (!(rawIdx >= 0 && rawIdx < this._rawCount)) {\n    return NaN;\n  }\n\n  var dimStore = this._storage[dim];\n\n  if (!dimStore) {\n    // TODO Warn ?\n    return NaN;\n  }\n\n  var chunkIndex = Math.floor(rawIdx / this._chunkSize);\n  var chunkOffset = rawIdx % this._chunkSize;\n  var chunkStore = dimStore[chunkIndex];\n  return chunkStore[chunkOffset];\n};\n/**\n * FIXME Use `get` on chrome maybe slow(in filterSelf and selectRange).\n * Hack a much simpler _getFast\n * @private\n */\n\n\nlistProto._getFast = function (dim, rawIdx) {\n  var chunkIndex = Math.floor(rawIdx / this._chunkSize);\n  var chunkOffset = rawIdx % this._chunkSize;\n  var chunkStore = this._storage[dim][chunkIndex];\n  return chunkStore[chunkOffset];\n};\n/**\n * Get value for multi dimensions.\n * @param {Array.<string>} [dimensions] If ignored, using all dimensions.\n * @param {number} idx\n * @return {number}\n */\n\n\nlistProto.getValues = function (dimensions, idx\n/*, stack */\n) {\n  var values = [];\n\n  if (!zrUtil.isArray(dimensions)) {\n    // stack = idx;\n    idx = dimensions;\n    dimensions = this.dimensions;\n  }\n\n  for (var i = 0, len = dimensions.length; i < len; i++) {\n    values.push(this.get(dimensions[i], idx\n    /*, stack */\n    ));\n  }\n\n  return values;\n};\n/**\n * If value is NaN. Inlcuding '-'\n * Only check the coord dimensions.\n * @param {string} dim\n * @param {number} idx\n * @return {number}\n */\n\n\nlistProto.hasValue = function (idx) {\n  var dataDimsOnCoord = this._dimensionsSummary.dataDimsOnCoord;\n  var dimensionInfos = this._dimensionInfos;\n\n  for (var i = 0, len = dataDimsOnCoord.length; i < len; i++) {\n    if ( // Ordinal type can be string or number\n    dimensionInfos[dataDimsOnCoord[i]].type !== 'ordinal' // FIXME check ordinal when using index?\n    && isNaN(this.get(dataDimsOnCoord[i], idx))) {\n      return false;\n    }\n  }\n\n  return true;\n};\n/**\n * Get extent of data in one dimension\n * @param {string} dim\n * @param {boolean} stack\n */\n\n\nlistProto.getDataExtent = function (dim\n/*, stack */\n) {\n  // Make sure use concrete dim as cache name.\n  dim = this.getDimension(dim);\n  var dimData = this._storage[dim];\n  var initialExtent = getInitialExtent(); // stack = !!((stack || false) && this.getCalculationInfo(dim));\n\n  if (!dimData) {\n    return initialExtent;\n  } // Make more strict checkings to ensure hitting cache.\n\n\n  var currEnd = this.count(); // var cacheName = [dim, !!stack].join('_');\n  // var cacheName = dim;\n  // Consider the most cases when using data zoom, `getDataExtent`\n  // happened before filtering. We cache raw extent, which is not\n  // necessary to be cleared and recalculated when restore data.\n\n  var useRaw = !this._indices; // && !stack;\n\n  var dimExtent;\n\n  if (useRaw) {\n    return this._rawExtent[dim].slice();\n  }\n\n  dimExtent = this._extent[dim];\n\n  if (dimExtent) {\n    return dimExtent.slice();\n  }\n\n  dimExtent = initialExtent;\n  var min = dimExtent[0];\n  var max = dimExtent[1];\n\n  for (var i = 0; i < currEnd; i++) {\n    // var value = stack ? this.get(dim, i, true) : this._getFast(dim, this.getRawIndex(i));\n    var value = this._getFast(dim, this.getRawIndex(i));\n\n    value < min && (min = value);\n    value > max && (max = value);\n  }\n\n  dimExtent = [min, max];\n  this._extent[dim] = dimExtent;\n  return dimExtent;\n};\n/**\n * Optimize for the scenario that data is filtered by a given extent.\n * Consider that if data amount is more than hundreds of thousand,\n * extent calculation will cost more than 10ms and the cache will\n * be erased because of the filtering.\n */\n\n\nlistProto.getApproximateExtent = function (dim\n/*, stack */\n) {\n  dim = this.getDimension(dim);\n  return this._approximateExtent[dim] || this.getDataExtent(dim\n  /*, stack */\n  );\n};\n\nlistProto.setApproximateExtent = function (extent, dim\n/*, stack */\n) {\n  dim = this.getDimension(dim);\n  this._approximateExtent[dim] = extent.slice();\n};\n/**\n * @param {string} key\n * @return {*}\n */\n\n\nlistProto.getCalculationInfo = function (key) {\n  return this._calculationInfo[key];\n};\n/**\n * @param {string|Object} key or k-v object\n * @param {*} [value]\n */\n\n\nlistProto.setCalculationInfo = function (key, value) {\n  isObject(key) ? zrUtil.extend(this._calculationInfo, key) : this._calculationInfo[key] = value;\n};\n/**\n * Get sum of data in one dimension\n * @param {string} dim\n */\n\n\nlistProto.getSum = function (dim\n/*, stack */\n) {\n  var dimData = this._storage[dim];\n  var sum = 0;\n\n  if (dimData) {\n    for (var i = 0, len = this.count(); i < len; i++) {\n      var value = this.get(dim, i\n      /*, stack */\n      );\n\n      if (!isNaN(value)) {\n        sum += value;\n      }\n    }\n  }\n\n  return sum;\n};\n/**\n * Get median of data in one dimension\n * @param {string} dim\n */\n\n\nlistProto.getMedian = function (dim\n/*, stack */\n) {\n  var dimDataArray = []; // map all data of one dimension\n\n  this.each(dim, function (val, idx) {\n    if (!isNaN(val)) {\n      dimDataArray.push(val);\n    }\n  }); // TODO\n  // Use quick select?\n  // immutability & sort\n\n  var sortedDimDataArray = [].concat(dimDataArray).sort(function (a, b) {\n    return a - b;\n  });\n  var len = this.count(); // calculate median\n\n  return len === 0 ? 0 : len % 2 === 1 ? sortedDimDataArray[(len - 1) / 2] : (sortedDimDataArray[len / 2] + sortedDimDataArray[len / 2 - 1]) / 2;\n}; // /**\n//  * Retreive the index with given value\n//  * @param {string} dim Concrete dimension.\n//  * @param {number} value\n//  * @return {number}\n//  */\n// Currently incorrect: should return dataIndex but not rawIndex.\n// Do not fix it until this method is to be used somewhere.\n// FIXME Precision of float value\n// listProto.indexOf = function (dim, value) {\n//     var storage = this._storage;\n//     var dimData = storage[dim];\n//     var chunkSize = this._chunkSize;\n//     if (dimData) {\n//         for (var i = 0, len = this.count(); i < len; i++) {\n//             var chunkIndex = Math.floor(i / chunkSize);\n//             var chunkOffset = i % chunkSize;\n//             if (dimData[chunkIndex][chunkOffset] === value) {\n//                 return i;\n//             }\n//         }\n//     }\n//     return -1;\n// };\n\n/**\n * Only support the dimension which inverted index created.\n * Do not support other cases until required.\n * @param {string} concrete dim\n * @param {number|string} value\n * @return {number} rawIndex\n */\n\n\nlistProto.rawIndexOf = function (dim, value) {\n  var invertedIndices = dim && this._invertedIndicesMap[dim];\n  var rawIndex = invertedIndices[value];\n\n  if (rawIndex == null || isNaN(rawIndex)) {\n    return INDEX_NOT_FOUND;\n  }\n\n  return rawIndex;\n};\n/**\n * Retreive the index with given name\n * @param {number} idx\n * @param {number} name\n * @return {number}\n */\n\n\nlistProto.indexOfName = function (name) {\n  for (var i = 0, len = this.count(); i < len; i++) {\n    if (this.getName(i) === name) {\n      return i;\n    }\n  }\n\n  return -1;\n};\n/**\n * Retreive the index with given raw data index\n * @param {number} idx\n * @param {number} name\n * @return {number}\n */\n\n\nlistProto.indexOfRawIndex = function (rawIndex) {\n  if (!this._indices) {\n    return rawIndex;\n  }\n\n  if (rawIndex >= this._rawCount || rawIndex < 0) {\n    return -1;\n  } // Indices are ascending\n\n\n  var indices = this._indices; // If rawIndex === dataIndex\n\n  var rawDataIndex = indices[rawIndex];\n\n  if (rawDataIndex != null && rawDataIndex < this._count && rawDataIndex === rawIndex) {\n    return rawIndex;\n  }\n\n  var left = 0;\n  var right = this._count - 1;\n\n  while (left <= right) {\n    var mid = (left + right) / 2 | 0;\n\n    if (indices[mid] < rawIndex) {\n      left = mid + 1;\n    } else if (indices[mid] > rawIndex) {\n      right = mid - 1;\n    } else {\n      return mid;\n    }\n  }\n\n  return -1;\n};\n/**\n * Retreive the index of nearest value\n * @param {string} dim\n * @param {number} value\n * @param {number} [maxDistance=Infinity]\n * @return {Array.<number>} Considere multiple points has the same value.\n */\n\n\nlistProto.indicesOfNearest = function (dim, value, maxDistance) {\n  var storage = this._storage;\n  var dimData = storage[dim];\n  var nearestIndices = [];\n\n  if (!dimData) {\n    return nearestIndices;\n  }\n\n  if (maxDistance == null) {\n    maxDistance = Infinity;\n  }\n\n  var minDist = Number.MAX_VALUE;\n  var minDiff = -1;\n\n  for (var i = 0, len = this.count(); i < len; i++) {\n    var diff = value - this.get(dim, i\n    /*, stack */\n    );\n    var dist = Math.abs(diff);\n\n    if (diff <= maxDistance && dist <= minDist) {\n      // For the case of two data are same on xAxis, which has sequence data.\n      // Show the nearest index\n      // https://github.com/ecomfe/echarts/issues/2869\n      if (dist < minDist || diff >= 0 && minDiff < 0) {\n        minDist = dist;\n        minDiff = diff;\n        nearestIndices.length = 0;\n      }\n\n      nearestIndices.push(i);\n    }\n  }\n\n  return nearestIndices;\n};\n/**\n * Get raw data index\n * @param {number} idx\n * @return {number}\n */\n\n\nlistProto.getRawIndex = getRawIndexWithoutIndices;\n\nfunction getRawIndexWithoutIndices(idx) {\n  return idx;\n}\n\nfunction getRawIndexWithIndices(idx) {\n  if (idx < this._count && idx >= 0) {\n    return this._indices[idx];\n  }\n\n  return -1;\n}\n/**\n * Get raw data item\n * @param {number} idx\n * @return {number}\n */\n\n\nlistProto.getRawDataItem = function (idx) {\n  if (!this._rawData.persistent) {\n    var val = [];\n\n    for (var i = 0; i < this.dimensions.length; i++) {\n      var dim = this.dimensions[i];\n      val.push(this.get(dim, idx));\n    }\n\n    return val;\n  } else {\n    return this._rawData.getItem(this.getRawIndex(idx));\n  }\n};\n/**\n * @param {number} idx\n * @param {boolean} [notDefaultIdx=false]\n * @return {string}\n */\n\n\nlistProto.getName = function (idx) {\n  var rawIndex = this.getRawIndex(idx);\n  return this._nameList[rawIndex] || getRawValueFromStore(this, this._nameDimIdx, rawIndex) || '';\n};\n/**\n * @param {number} idx\n * @param {boolean} [notDefaultIdx=false]\n * @return {string}\n */\n\n\nlistProto.getId = function (idx) {\n  return getId(this, this.getRawIndex(idx));\n};\n\nfunction getId(list, rawIndex) {\n  var id = list._idList[rawIndex];\n\n  if (id == null) {\n    id = getRawValueFromStore(list, list._idDimIdx, rawIndex);\n  }\n\n  if (id == null) {\n    // FIXME Check the usage in graph, should not use prefix.\n    id = ID_PREFIX + rawIndex;\n  }\n\n  return id;\n}\n\nfunction normalizeDimensions(dimensions) {\n  if (!zrUtil.isArray(dimensions)) {\n    dimensions = [dimensions];\n  }\n\n  return dimensions;\n}\n\nfunction validateDimensions(list, dims) {\n  for (var i = 0; i < dims.length; i++) {\n    // stroage may be empty when no data, so use\n    // dimensionInfos to check.\n    if (!list._dimensionInfos[dims[i]]) {\n      console.error('Unkown dimension ' + dims[i]);\n    }\n  }\n}\n/**\n * Data iteration\n * @param {string|Array.<string>}\n * @param {Function} cb\n * @param {*} [context=this]\n *\n * @example\n *  list.each('x', function (x, idx) {});\n *  list.each(['x', 'y'], function (x, y, idx) {});\n *  list.each(function (idx) {})\n */\n\n\nlistProto.each = function (dims, cb, context, contextCompat) {\n  'use strict';\n\n  if (!this._count) {\n    return;\n  }\n\n  if (typeof dims === 'function') {\n    contextCompat = context;\n    context = cb;\n    cb = dims;\n    dims = [];\n  } // contextCompat just for compat echarts3\n\n\n  context = context || contextCompat || this;\n  dims = zrUtil.map(normalizeDimensions(dims), this.getDimension, this);\n  var dimSize = dims.length;\n\n  for (var i = 0; i < this.count(); i++) {\n    // Simple optimization\n    switch (dimSize) {\n      case 0:\n        cb.call(context, i);\n        break;\n\n      case 1:\n        cb.call(context, this.get(dims[0], i), i);\n        break;\n\n      case 2:\n        cb.call(context, this.get(dims[0], i), this.get(dims[1], i), i);\n        break;\n\n      default:\n        var k = 0;\n        var value = [];\n\n        for (; k < dimSize; k++) {\n          value[k] = this.get(dims[k], i);\n        } // Index\n\n\n        value[k] = i;\n        cb.apply(context, value);\n    }\n  }\n};\n/**\n * Data filter\n * @param {string|Array.<string>}\n * @param {Function} cb\n * @param {*} [context=this]\n */\n\n\nlistProto.filterSelf = function (dimensions, cb, context, contextCompat) {\n  'use strict';\n\n  if (!this._count) {\n    return;\n  }\n\n  if (typeof dimensions === 'function') {\n    contextCompat = context;\n    context = cb;\n    cb = dimensions;\n    dimensions = [];\n  } // contextCompat just for compat echarts3\n\n\n  context = context || contextCompat || this;\n  dimensions = zrUtil.map(normalizeDimensions(dimensions), this.getDimension, this);\n  var count = this.count();\n  var Ctor = getIndicesCtor(this);\n  var newIndices = new Ctor(count);\n  var value = [];\n  var dimSize = dimensions.length;\n  var offset = 0;\n  var dim0 = dimensions[0];\n\n  for (var i = 0; i < count; i++) {\n    var keep;\n    var rawIdx = this.getRawIndex(i); // Simple optimization\n\n    if (dimSize === 0) {\n      keep = cb.call(context, i);\n    } else if (dimSize === 1) {\n      var val = this._getFast(dim0, rawIdx);\n\n      keep = cb.call(context, val, i);\n    } else {\n      for (var k = 0; k < dimSize; k++) {\n        value[k] = this._getFast(dim0, rawIdx);\n      }\n\n      value[k] = i;\n      keep = cb.apply(context, value);\n    }\n\n    if (keep) {\n      newIndices[offset++] = rawIdx;\n    }\n  } // Set indices after filtered.\n\n\n  if (offset < count) {\n    this._indices = newIndices;\n  }\n\n  this._count = offset; // Reset data extent\n\n  this._extent = {};\n  this.getRawIndex = this._indices ? getRawIndexWithIndices : getRawIndexWithoutIndices;\n  return this;\n};\n/**\n * Select data in range. (For optimization of filter)\n * (Manually inline code, support 5 million data filtering in data zoom.)\n */\n\n\nlistProto.selectRange = function (range) {\n  'use strict';\n\n  if (!this._count) {\n    return;\n  }\n\n  var dimensions = [];\n\n  for (var dim in range) {\n    if (range.hasOwnProperty(dim)) {\n      dimensions.push(dim);\n    }\n  }\n\n  var dimSize = dimensions.length;\n\n  if (!dimSize) {\n    return;\n  }\n\n  var originalCount = this.count();\n  var Ctor = getIndicesCtor(this);\n  var newIndices = new Ctor(originalCount);\n  var offset = 0;\n  var dim0 = dimensions[0];\n  var min = range[dim0][0];\n  var max = range[dim0][1];\n  var quickFinished = false;\n\n  if (!this._indices) {\n    // Extreme optimization for common case. About 2x faster in chrome.\n    var idx = 0;\n\n    if (dimSize === 1) {\n      var dimStorage = this._storage[dimensions[0]];\n\n      for (var k = 0; k < this._chunkCount; k++) {\n        var chunkStorage = dimStorage[k];\n        var len = Math.min(this._count - k * this._chunkSize, this._chunkSize);\n\n        for (var i = 0; i < len; i++) {\n          var val = chunkStorage[i]; // NaN will not be filtered. Consider the case, in line chart, empty\n          // value indicates the line should be broken. But for the case like\n          // scatter plot, a data item with empty value will not be rendered,\n          // but the axis extent may be effected if some other dim of the data\n          // item has value. Fortunately it is not a significant negative effect.\n\n          if (val >= min && val <= max || isNaN(val)) {\n            newIndices[offset++] = idx;\n          }\n\n          idx++;\n        }\n      }\n\n      quickFinished = true;\n    } else if (dimSize === 2) {\n      var dimStorage = this._storage[dim0];\n      var dimStorage2 = this._storage[dimensions[1]];\n      var min2 = range[dimensions[1]][0];\n      var max2 = range[dimensions[1]][1];\n\n      for (var k = 0; k < this._chunkCount; k++) {\n        var chunkStorage = dimStorage[k];\n        var chunkStorage2 = dimStorage2[k];\n        var len = Math.min(this._count - k * this._chunkSize, this._chunkSize);\n\n        for (var i = 0; i < len; i++) {\n          var val = chunkStorage[i];\n          var val2 = chunkStorage2[i]; // Do not filter NaN, see comment above.\n\n          if ((val >= min && val <= max || isNaN(val)) && (val2 >= min2 && val2 <= max2 || isNaN(val2))) {\n            newIndices[offset++] = idx;\n          }\n\n          idx++;\n        }\n      }\n\n      quickFinished = true;\n    }\n  }\n\n  if (!quickFinished) {\n    if (dimSize === 1) {\n      for (var i = 0; i < originalCount; i++) {\n        var rawIndex = this.getRawIndex(i);\n\n        var val = this._getFast(dim0, rawIndex); // Do not filter NaN, see comment above.\n\n\n        if (val >= min && val <= max || isNaN(val)) {\n          newIndices[offset++] = rawIndex;\n        }\n      }\n    } else {\n      for (var i = 0; i < originalCount; i++) {\n        var keep = true;\n        var rawIndex = this.getRawIndex(i);\n\n        for (var k = 0; k < dimSize; k++) {\n          var dimk = dimensions[k];\n\n          var val = this._getFast(dim, rawIndex); // Do not filter NaN, see comment above.\n\n\n          if (val < range[dimk][0] || val > range[dimk][1]) {\n            keep = false;\n          }\n        }\n\n        if (keep) {\n          newIndices[offset++] = this.getRawIndex(i);\n        }\n      }\n    }\n  } // Set indices after filtered.\n\n\n  if (offset < originalCount) {\n    this._indices = newIndices;\n  }\n\n  this._count = offset; // Reset data extent\n\n  this._extent = {};\n  this.getRawIndex = this._indices ? getRawIndexWithIndices : getRawIndexWithoutIndices;\n  return this;\n};\n/**\n * Data mapping to a plain array\n * @param {string|Array.<string>} [dimensions]\n * @param {Function} cb\n * @param {*} [context=this]\n * @return {Array}\n */\n\n\nlistProto.mapArray = function (dimensions, cb, context, contextCompat) {\n  'use strict';\n\n  if (typeof dimensions === 'function') {\n    contextCompat = context;\n    context = cb;\n    cb = dimensions;\n    dimensions = [];\n  } // contextCompat just for compat echarts3\n\n\n  context = context || contextCompat || this;\n  var result = [];\n  this.each(dimensions, function () {\n    result.push(cb && cb.apply(this, arguments));\n  }, context);\n  return result;\n}; // Data in excludeDimensions is copied, otherwise transfered.\n\n\nfunction cloneListForMapAndSample(original, excludeDimensions) {\n  var allDimensions = original.dimensions;\n  var list = new List(zrUtil.map(allDimensions, original.getDimensionInfo, original), original.hostModel); // FIXME If needs stackedOn, value may already been stacked\n\n  transferProperties(list, original);\n  var storage = list._storage = {};\n  var originalStorage = original._storage; // Init storage\n\n  for (var i = 0; i < allDimensions.length; i++) {\n    var dim = allDimensions[i];\n\n    if (originalStorage[dim]) {\n      // Notice that we do not reset invertedIndicesMap here, becuase\n      // there is no scenario of mapping or sampling ordinal dimension.\n      if (zrUtil.indexOf(excludeDimensions, dim) >= 0) {\n        storage[dim] = cloneDimStore(originalStorage[dim]);\n        list._rawExtent[dim] = getInitialExtent();\n        list._extent[dim] = null;\n      } else {\n        // Direct reference for other dimensions\n        storage[dim] = originalStorage[dim];\n      }\n    }\n  }\n\n  return list;\n}\n\nfunction cloneDimStore(originalDimStore) {\n  var newDimStore = new Array(originalDimStore.length);\n\n  for (var j = 0; j < originalDimStore.length; j++) {\n    newDimStore[j] = cloneChunk(originalDimStore[j]);\n  }\n\n  return newDimStore;\n}\n\nfunction getInitialExtent() {\n  return [Infinity, -Infinity];\n}\n/**\n * Data mapping to a new List with given dimensions\n * @param {string|Array.<string>} dimensions\n * @param {Function} cb\n * @param {*} [context=this]\n * @return {Array}\n */\n\n\nlistProto.map = function (dimensions, cb, context, contextCompat) {\n  'use strict'; // contextCompat just for compat echarts3\n\n  context = context || contextCompat || this;\n  dimensions = zrUtil.map(normalizeDimensions(dimensions), this.getDimension, this);\n  var list = cloneListForMapAndSample(this, dimensions); // Following properties are all immutable.\n  // So we can reference to the same value\n\n  list._indices = this._indices;\n  list.getRawIndex = list._indices ? getRawIndexWithIndices : getRawIndexWithoutIndices;\n  var storage = list._storage;\n  var tmpRetValue = [];\n  var chunkSize = this._chunkSize;\n  var dimSize = dimensions.length;\n  var dataCount = this.count();\n  var values = [];\n  var rawExtent = list._rawExtent;\n\n  for (var dataIndex = 0; dataIndex < dataCount; dataIndex++) {\n    for (var dimIndex = 0; dimIndex < dimSize; dimIndex++) {\n      values[dimIndex] = this.get(dimensions[dimIndex], dataIndex\n      /*, stack */\n      );\n    }\n\n    values[dimSize] = dataIndex;\n    var retValue = cb && cb.apply(context, values);\n\n    if (retValue != null) {\n      // a number or string (in oridinal dimension)?\n      if (typeof retValue !== 'object') {\n        tmpRetValue[0] = retValue;\n        retValue = tmpRetValue;\n      }\n\n      var rawIndex = this.getRawIndex(dataIndex);\n      var chunkIndex = Math.floor(rawIndex / chunkSize);\n      var chunkOffset = rawIndex % chunkSize;\n\n      for (var i = 0; i < retValue.length; i++) {\n        var dim = dimensions[i];\n        var val = retValue[i];\n        var rawExtentOnDim = rawExtent[dim];\n        var dimStore = storage[dim];\n\n        if (dimStore) {\n          dimStore[chunkIndex][chunkOffset] = val;\n        }\n\n        if (val < rawExtentOnDim[0]) {\n          rawExtentOnDim[0] = val;\n        }\n\n        if (val > rawExtentOnDim[1]) {\n          rawExtentOnDim[1] = val;\n        }\n      }\n    }\n  }\n\n  return list;\n};\n/**\n * Large data down sampling on given dimension\n * @param {string} dimension\n * @param {number} rate\n * @param {Function} sampleValue\n * @param {Function} sampleIndex Sample index for name and id\n */\n\n\nlistProto.downSample = function (dimension, rate, sampleValue, sampleIndex) {\n  var list = cloneListForMapAndSample(this, [dimension]);\n  var targetStorage = list._storage;\n  var frameValues = [];\n  var frameSize = Math.floor(1 / rate);\n  var dimStore = targetStorage[dimension];\n  var len = this.count();\n  var chunkSize = this._chunkSize;\n  var rawExtentOnDim = list._rawExtent[dimension];\n  var newIndices = new (getIndicesCtor(this))(len);\n  var offset = 0;\n\n  for (var i = 0; i < len; i += frameSize) {\n    // Last frame\n    if (frameSize > len - i) {\n      frameSize = len - i;\n      frameValues.length = frameSize;\n    }\n\n    for (var k = 0; k < frameSize; k++) {\n      var dataIdx = this.getRawIndex(i + k);\n      var originalChunkIndex = Math.floor(dataIdx / chunkSize);\n      var originalChunkOffset = dataIdx % chunkSize;\n      frameValues[k] = dimStore[originalChunkIndex][originalChunkOffset];\n    }\n\n    var value = sampleValue(frameValues);\n    var sampleFrameIdx = this.getRawIndex(Math.min(i + sampleIndex(frameValues, value) || 0, len - 1));\n    var sampleChunkIndex = Math.floor(sampleFrameIdx / chunkSize);\n    var sampleChunkOffset = sampleFrameIdx % chunkSize; // Only write value on the filtered data\n\n    dimStore[sampleChunkIndex][sampleChunkOffset] = value;\n\n    if (value < rawExtentOnDim[0]) {\n      rawExtentOnDim[0] = value;\n    }\n\n    if (value > rawExtentOnDim[1]) {\n      rawExtentOnDim[1] = value;\n    }\n\n    newIndices[offset++] = sampleFrameIdx;\n  }\n\n  list._count = offset;\n  list._indices = newIndices;\n  list.getRawIndex = getRawIndexWithIndices;\n  return list;\n};\n/**\n * Get model of one data item.\n *\n * @param {number} idx\n */\n// FIXME Model proxy ?\n\n\nlistProto.getItemModel = function (idx) {\n  var hostModel = this.hostModel;\n  return new Model(this.getRawDataItem(idx), hostModel, hostModel && hostModel.ecModel);\n};\n/**\n * Create a data differ\n * @param {module:echarts/data/List} otherList\n * @return {module:echarts/data/DataDiffer}\n */\n\n\nlistProto.diff = function (otherList) {\n  var thisList = this;\n  return new DataDiffer(otherList ? otherList.getIndices() : [], this.getIndices(), function (idx) {\n    return getId(otherList, idx);\n  }, function (idx) {\n    return getId(thisList, idx);\n  });\n};\n/**\n * Get visual property.\n * @param {string} key\n */\n\n\nlistProto.getVisual = function (key) {\n  var visual = this._visual;\n  return visual && visual[key];\n};\n/**\n * Set visual property\n * @param {string|Object} key\n * @param {*} [value]\n *\n * @example\n *  setVisual('color', color);\n *  setVisual({\n *      'color': color\n *  });\n */\n\n\nlistProto.setVisual = function (key, val) {\n  if (isObject(key)) {\n    for (var name in key) {\n      if (key.hasOwnProperty(name)) {\n        this.setVisual(name, key[name]);\n      }\n    }\n\n    return;\n  }\n\n  this._visual = this._visual || {};\n  this._visual[key] = val;\n};\n/**\n * Set layout property.\n * @param {string|Object} key\n * @param {*} [val]\n */\n\n\nlistProto.setLayout = function (key, val) {\n  if (isObject(key)) {\n    for (var name in key) {\n      if (key.hasOwnProperty(name)) {\n        this.setLayout(name, key[name]);\n      }\n    }\n\n    return;\n  }\n\n  this._layout[key] = val;\n};\n/**\n * Get layout property.\n * @param  {string} key.\n * @return {*}\n */\n\n\nlistProto.getLayout = function (key) {\n  return this._layout[key];\n};\n/**\n * Get layout of single data item\n * @param {number} idx\n */\n\n\nlistProto.getItemLayout = function (idx) {\n  return this._itemLayouts[idx];\n};\n/**\n * Set layout of single data item\n * @param {number} idx\n * @param {Object} layout\n * @param {boolean=} [merge=false]\n */\n\n\nlistProto.setItemLayout = function (idx, layout, merge) {\n  this._itemLayouts[idx] = merge ? zrUtil.extend(this._itemLayouts[idx] || {}, layout) : layout;\n};\n/**\n * Clear all layout of single data item\n */\n\n\nlistProto.clearItemLayouts = function () {\n  this._itemLayouts.length = 0;\n};\n/**\n * Get visual property of single data item\n * @param {number} idx\n * @param {string} key\n * @param {boolean} [ignoreParent=false]\n */\n\n\nlistProto.getItemVisual = function (idx, key, ignoreParent) {\n  var itemVisual = this._itemVisuals[idx];\n  var val = itemVisual && itemVisual[key];\n\n  if (val == null && !ignoreParent) {\n    // Use global visual property\n    return this.getVisual(key);\n  }\n\n  return val;\n};\n/**\n * Set visual property of single data item\n *\n * @param {number} idx\n * @param {string|Object} key\n * @param {*} [value]\n *\n * @example\n *  setItemVisual(0, 'color', color);\n *  setItemVisual(0, {\n *      'color': color\n *  });\n */\n\n\nlistProto.setItemVisual = function (idx, key, value) {\n  var itemVisual = this._itemVisuals[idx] || {};\n  var hasItemVisual = this.hasItemVisual;\n  this._itemVisuals[idx] = itemVisual;\n\n  if (isObject(key)) {\n    for (var name in key) {\n      if (key.hasOwnProperty(name)) {\n        itemVisual[name] = key[name];\n        hasItemVisual[name] = true;\n      }\n    }\n\n    return;\n  }\n\n  itemVisual[key] = value;\n  hasItemVisual[key] = true;\n};\n/**\n * Clear itemVisuals and list visual.\n */\n\n\nlistProto.clearAllVisual = function () {\n  this._visual = {};\n  this._itemVisuals = [];\n  this.hasItemVisual = {};\n};\n\nvar setItemDataAndSeriesIndex = function setItemDataAndSeriesIndex(child) {\n  child.seriesIndex = this.seriesIndex;\n  child.dataIndex = this.dataIndex;\n  child.dataType = this.dataType;\n};\n/**\n * Set graphic element relative to data. It can be set as null\n * @param {number} idx\n * @param {module:zrender/Element} [el]\n */\n\n\nlistProto.setItemGraphicEl = function (idx, el) {\n  var hostModel = this.hostModel;\n\n  if (el) {\n    // Add data index and series index for indexing the data by element\n    // Useful in tooltip\n    el.dataIndex = idx;\n    el.dataType = this.dataType;\n    el.seriesIndex = hostModel && hostModel.seriesIndex;\n\n    if (el.type === 'group') {\n      el.traverse(setItemDataAndSeriesIndex, el);\n    }\n  }\n\n  this._graphicEls[idx] = el;\n};\n/**\n * @param {number} idx\n * @return {module:zrender/Element}\n */\n\n\nlistProto.getItemGraphicEl = function (idx) {\n  return this._graphicEls[idx];\n};\n/**\n * @param {Function} cb\n * @param {*} context\n */\n\n\nlistProto.eachItemGraphicEl = function (cb, context) {\n  zrUtil.each(this._graphicEls, function (el, idx) {\n    if (el) {\n      cb && cb.call(context, el, idx);\n    }\n  });\n};\n/**\n * Shallow clone a new list except visual and layout properties, and graph elements.\n * New list only change the indices.\n */\n\n\nlistProto.cloneShallow = function (list) {\n  if (!list) {\n    var dimensionInfoList = zrUtil.map(this.dimensions, this.getDimensionInfo, this);\n    list = new List(dimensionInfoList, this.hostModel);\n  } // FIXME\n\n\n  list._storage = this._storage;\n  transferProperties(list, this); // Clone will not change the data extent and indices\n\n  if (this._indices) {\n    var Ctor = this._indices.constructor;\n    list._indices = new Ctor(this._indices);\n  } else {\n    list._indices = null;\n  }\n\n  list.getRawIndex = list._indices ? getRawIndexWithIndices : getRawIndexWithoutIndices;\n  return list;\n};\n/**\n * Wrap some method to add more feature\n * @param {string} methodName\n * @param {Function} injectFunction\n */\n\n\nlistProto.wrapMethod = function (methodName, injectFunction) {\n  var originalMethod = this[methodName];\n\n  if (typeof originalMethod !== 'function') {\n    return;\n  }\n\n  this.__wrappedMethods = this.__wrappedMethods || [];\n\n  this.__wrappedMethods.push(methodName);\n\n  this[methodName] = function () {\n    var res = originalMethod.apply(this, arguments);\n    return injectFunction.apply(this, [res].concat(zrUtil.slice(arguments)));\n  };\n}; // Methods that create a new list based on this list should be listed here.\n// Notice that those method should `RETURN` the new list.\n\n\nlistProto.TRANSFERABLE_METHODS = ['cloneShallow', 'downSample', 'map']; // Methods that change indices of this list should be listed here.\n\nlistProto.CHANGABLE_METHODS = ['filterSelf', 'selectRange'];\nvar _default = List;\nmodule.exports = _default;","map":{"version":3,"sources":["/Users/eduardjacobs/Desktop/files/inHouse-website/client/node_modules/echarts/lib/data/List.js"],"names":["_config","require","__DEV__","zrUtil","Model","DataDiffer","Source","_dataProvider","defaultDimValueGetters","DefaultDataProvider","_dimensionHelper","summarizeDimensions","isObject","UNDEFINED","INDEX_NOT_FOUND","ID_PREFIX","dataCtors","Float64Array","Array","Int32Array","CtorUint32Array","Uint32Array","CtorInt32Array","CtorUint16Array","Uint16Array","getIndicesCtor","list","_rawCount","cloneChunk","originalChunk","Ctor","constructor","slice","TRANSFERABLE_PROPERTIES","CLONE_PROPERTIES","transferProperties","target","source","each","concat","__wrappedMethods","propName","hasOwnProperty","clone","_calculationInfo","extend","List","dimensions","hostModel","dimensionInfos","dimensionNames","invertedIndicesMap","i","length","dimensionInfo","isString","name","dimensionName","type","coordDim","coordDimIndex","otherDims","push","index","createInvertedIndices","_dimensionInfos","dataType","_indices","_count","_storage","_nameList","_idList","_optionModels","_visual","_layout","_itemVisuals","hasItemVisual","_itemLayouts","_graphicEls","_chunkSize","_chunkCount","_rawData","_rawExtent","_extent","_approximateExtent","_dimensionsSummary","_invertedIndicesMap","listProto","prototype","hasItemOption","getDimension","dim","isNaN","getDimensionInfo","getDimensionsOnCoord","dataDimsOnCoord","mapDimension","idx","dimensionsSummary","encodeFirstDimNotExtra","dims","encode","initData","data","nameList","dimValueGetter","notProvider","isInstance","isArrayLike","_nameRepeatCount","defaultDimValueGetter","getSource","sourceFormat","_dimValueGetter","_dimValueGetterArrayRows","arrayRows","_initDataFromProvider","count","pure","getProvider","appendData","rawData","start","end","persistent","appendValues","values","names","chunkSize","storage","dimLen","rawExtent","Math","max","originalChunkCount","getInitialExtent","prepareChunks","emptyDataItem","sourceIdx","chunkIndex","floor","chunkOffset","k","val","dimRawExtent","prepareInvertedIndex","dimensionInfoMap","idList","nameRepeatCount","nameDimIdx","dimInfo","itemName","_nameDimIdx","itemId","_idDimIdx","dataItem","getItem","dimStorage","nameDim","nameDimChunk","ordinalMeta","categories","id","clean","chunkCount","DataCtor","lastChunkIndex","resizeChunkArray","newStore","min","j","invertedIndices","get","getRawValueFromStore","dimIndex","rawIndex","chunk","getIndices","newIndices","indices","thisCount","buffer","NaN","getRawIndex","chunkStore","value","getByRawIndex","rawIdx","dimStore","_getFast","getValues","isArray","len","hasValue","getDataExtent","dimData","initialExtent","currEnd","useRaw","dimExtent","getApproximateExtent","setApproximateExtent","extent","getCalculationInfo","key","setCalculationInfo","getSum","sum","getMedian","dimDataArray","sortedDimDataArray","sort","a","b","rawIndexOf","indexOfName","getName","indexOfRawIndex","rawDataIndex","left","right","mid","indicesOfNearest","maxDistance","nearestIndices","Infinity","minDist","Number","MAX_VALUE","minDiff","diff","dist","abs","getRawIndexWithoutIndices","getRawIndexWithIndices","getRawDataItem","getId","normalizeDimensions","validateDimensions","console","error","cb","context","contextCompat","map","dimSize","call","apply","filterSelf","offset","dim0","keep","selectRange","range","originalCount","quickFinished","chunkStorage","dimStorage2","min2","max2","chunkStorage2","val2","dimk","mapArray","result","arguments","cloneListForMapAndSample","original","excludeDimensions","allDimensions","originalStorage","indexOf","cloneDimStore","originalDimStore","newDimStore","tmpRetValue","dataCount","dataIndex","retValue","rawExtentOnDim","downSample","dimension","rate","sampleValue","sampleIndex","targetStorage","frameValues","frameSize","dataIdx","originalChunkIndex","originalChunkOffset","sampleFrameIdx","sampleChunkIndex","sampleChunkOffset","getItemModel","ecModel","otherList","thisList","getVisual","visual","setVisual","setLayout","getLayout","getItemLayout","setItemLayout","layout","merge","clearItemLayouts","getItemVisual","ignoreParent","itemVisual","setItemVisual","clearAllVisual","setItemDataAndSeriesIndex","child","seriesIndex","setItemGraphicEl","el","traverse","getItemGraphicEl","eachItemGraphicEl","cloneShallow","dimensionInfoList","wrapMethod","methodName","injectFunction","originalMethod","res","TRANSFERABLE_METHODS","CHANGABLE_METHODS","_default","module","exports"],"mappings":"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","sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\nvar _config = require(\"../config\");\n\nvar __DEV__ = _config.__DEV__;\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar Model = require(\"../model/Model\");\n\nvar DataDiffer = require(\"./DataDiffer\");\n\nvar Source = require(\"./Source\");\n\nvar _dataProvider = require(\"./helper/dataProvider\");\n\nvar defaultDimValueGetters = _dataProvider.defaultDimValueGetters;\nvar DefaultDataProvider = _dataProvider.DefaultDataProvider;\n\nvar _dimensionHelper = require(\"./helper/dimensionHelper\");\n\nvar summarizeDimensions = _dimensionHelper.summarizeDimensions;\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/* global Float64Array, Int32Array, Uint32Array, Uint16Array */\n\n/**\n * List for data storage\n * @module echarts/data/List\n */\nvar isObject = zrUtil.isObject;\nvar UNDEFINED = 'undefined';\nvar INDEX_NOT_FOUND = -1; // Use prefix to avoid index to be the same as otherIdList[idx],\n// which will cause weird udpate animation.\n\nvar ID_PREFIX = 'e\\0\\0';\nvar dataCtors = {\n  'float': typeof Float64Array === UNDEFINED ? Array : Float64Array,\n  'int': typeof Int32Array === UNDEFINED ? Array : Int32Array,\n  // Ordinal data type can be string or int\n  'ordinal': Array,\n  'number': Array,\n  'time': Array\n}; // Caution: MUST not use `new CtorUint32Array(arr, 0, len)`, because the Ctor of array is\n// different from the Ctor of typed array.\n\nvar CtorUint32Array = typeof Uint32Array === UNDEFINED ? Array : Uint32Array;\nvar CtorInt32Array = typeof Int32Array === UNDEFINED ? Array : Int32Array;\nvar CtorUint16Array = typeof Uint16Array === UNDEFINED ? Array : Uint16Array;\n\nfunction getIndicesCtor(list) {\n  // The possible max value in this._indicies is always this._rawCount despite of filtering.\n  return list._rawCount > 65535 ? CtorUint32Array : CtorUint16Array;\n}\n\nfunction cloneChunk(originalChunk) {\n  var Ctor = originalChunk.constructor; // Only shallow clone is enough when Array.\n\n  return Ctor === Array ? originalChunk.slice() : new Ctor(originalChunk);\n}\n\nvar TRANSFERABLE_PROPERTIES = ['hasItemOption', '_nameList', '_idList', '_invertedIndicesMap', '_rawData', '_chunkSize', '_chunkCount', '_dimValueGetter', '_count', '_rawCount', '_nameDimIdx', '_idDimIdx'];\nvar CLONE_PROPERTIES = ['_extent', '_approximateExtent', '_rawExtent'];\n\nfunction transferProperties(target, source) {\n  zrUtil.each(TRANSFERABLE_PROPERTIES.concat(source.__wrappedMethods || []), function (propName) {\n    if (source.hasOwnProperty(propName)) {\n      target[propName] = source[propName];\n    }\n  });\n  target.__wrappedMethods = source.__wrappedMethods;\n  zrUtil.each(CLONE_PROPERTIES, function (propName) {\n    target[propName] = zrUtil.clone(source[propName]);\n  });\n  target._calculationInfo = zrUtil.extend(source._calculationInfo);\n}\n/**\n * @constructor\n * @alias module:echarts/data/List\n *\n * @param {Array.<string|Object>} dimensions\n *      For example, ['someDimName', {name: 'someDimName', type: 'someDimType'}, ...].\n *      Dimensions should be concrete names like x, y, z, lng, lat, angle, radius\n *      Spetial fields: {\n *          ordinalMeta: <module:echarts/data/OrdinalMeta>\n *          createInvertedIndices: <boolean>\n *      }\n * @param {module:echarts/model/Model} hostModel\n */\n\n\nvar List = function (dimensions, hostModel) {\n  dimensions = dimensions || ['x', 'y'];\n  var dimensionInfos = {};\n  var dimensionNames = [];\n  var invertedIndicesMap = {};\n\n  for (var i = 0; i < dimensions.length; i++) {\n    // Use the original dimensions[i], where other flag props may exists.\n    var dimensionInfo = dimensions[i];\n\n    if (zrUtil.isString(dimensionInfo)) {\n      dimensionInfo = {\n        name: dimensionInfo\n      };\n    }\n\n    var dimensionName = dimensionInfo.name;\n    dimensionInfo.type = dimensionInfo.type || 'float';\n\n    if (!dimensionInfo.coordDim) {\n      dimensionInfo.coordDim = dimensionName;\n      dimensionInfo.coordDimIndex = 0;\n    }\n\n    dimensionInfo.otherDims = dimensionInfo.otherDims || {};\n    dimensionNames.push(dimensionName);\n    dimensionInfos[dimensionName] = dimensionInfo;\n    dimensionInfo.index = i;\n\n    if (dimensionInfo.createInvertedIndices) {\n      invertedIndicesMap[dimensionName] = [];\n    }\n  }\n  /**\n   * @readOnly\n   * @type {Array.<string>}\n   */\n\n\n  this.dimensions = dimensionNames;\n  /**\n   * Infomation of each data dimension, like data type.\n   * @type {Object}\n   */\n\n  this._dimensionInfos = dimensionInfos;\n  /**\n   * @type {module:echarts/model/Model}\n   */\n\n  this.hostModel = hostModel;\n  /**\n   * @type {module:echarts/model/Model}\n   */\n\n  this.dataType;\n  /**\n   * Indices stores the indices of data subset after filtered.\n   * This data subset will be used in chart.\n   * @type {Array.<number>}\n   * @readOnly\n   */\n\n  this._indices = null;\n  this._count = 0;\n  this._rawCount = 0;\n  /**\n   * Data storage\n   * @type {Object.<key, Array.<TypedArray|Array>>}\n   * @private\n   */\n\n  this._storage = {};\n  /**\n   * @type {Array.<string>}\n   */\n\n  this._nameList = [];\n  /**\n   * @type {Array.<string>}\n   */\n\n  this._idList = [];\n  /**\n   * Models of data option is stored sparse for optimizing memory cost\n   * @type {Array.<module:echarts/model/Model>}\n   * @private\n   */\n\n  this._optionModels = [];\n  /**\n   * Global visual properties after visual coding\n   * @type {Object}\n   * @private\n   */\n\n  this._visual = {};\n  /**\n   * Globel layout properties.\n   * @type {Object}\n   * @private\n   */\n\n  this._layout = {};\n  /**\n   * Item visual properties after visual coding\n   * @type {Array.<Object>}\n   * @private\n   */\n\n  this._itemVisuals = [];\n  /**\n   * Key: visual type, Value: boolean\n   * @type {Object}\n   * @readOnly\n   */\n\n  this.hasItemVisual = {};\n  /**\n   * Item layout properties after layout\n   * @type {Array.<Object>}\n   * @private\n   */\n\n  this._itemLayouts = [];\n  /**\n   * Graphic elemnents\n   * @type {Array.<module:zrender/Element>}\n   * @private\n   */\n\n  this._graphicEls = [];\n  /**\n   * Max size of each chunk.\n   * @type {number}\n   * @private\n   */\n\n  this._chunkSize = 1e5;\n  /**\n   * @type {number}\n   * @private\n   */\n\n  this._chunkCount = 0;\n  /**\n   * @type {Array.<Array|Object>}\n   * @private\n   */\n\n  this._rawData;\n  /**\n   * Raw extent will not be cloned, but only transfered.\n   * It will not be calculated util needed.\n   * key: dim,\n   * value: {end: number, extent: Array.<number>}\n   * @type {Object}\n   * @private\n   */\n\n  this._rawExtent = {};\n  /**\n   * @type {Object}\n   * @private\n   */\n\n  this._extent = {};\n  /**\n   * key: dim\n   * value: extent\n   * @type {Object}\n   * @private\n   */\n\n  this._approximateExtent = {};\n  /**\n   * Cache summary info for fast visit. See \"dimensionHelper\".\n   * @type {Object}\n   * @private\n   */\n\n  this._dimensionsSummary = summarizeDimensions(this);\n  /**\n   * @type {Object.<Array|TypedArray>}\n   * @private\n   */\n\n  this._invertedIndicesMap = invertedIndicesMap;\n  /**\n   * @type {Object}\n   * @private\n   */\n\n  this._calculationInfo = {};\n};\n\nvar listProto = List.prototype;\nlistProto.type = 'list';\n/**\n * If each data item has it's own option\n * @type {boolean}\n */\n\nlistProto.hasItemOption = true;\n/**\n * Get dimension name\n * @param {string|number} dim\n *        Dimension can be concrete names like x, y, z, lng, lat, angle, radius\n *        Or a ordinal number. For example getDimensionInfo(0) will return 'x' or 'lng' or 'radius'\n * @return {string} Concrete dim name.\n */\n\nlistProto.getDimension = function (dim) {\n  if (!isNaN(dim)) {\n    dim = this.dimensions[dim] || dim;\n  }\n\n  return dim;\n};\n/**\n * Get type and calculation info of particular dimension\n * @param {string|number} dim\n *        Dimension can be concrete names like x, y, z, lng, lat, angle, radius\n *        Or a ordinal number. For example getDimensionInfo(0) will return 'x' or 'lng' or 'radius'\n */\n\n\nlistProto.getDimensionInfo = function (dim) {\n  // Do not clone, because there may be categories in dimInfo.\n  return this._dimensionInfos[this.getDimension(dim)];\n};\n/**\n * @return {Array.<string>} concrete dimension name list on coord.\n */\n\n\nlistProto.getDimensionsOnCoord = function () {\n  return this._dimensionsSummary.dataDimsOnCoord.slice();\n};\n/**\n * @param {string} coordDim\n * @param {number} [idx] A coordDim may map to more than one data dim.\n *        If idx is `true`, return a array of all mapped dims.\n *        If idx is not specified, return the first dim not extra.\n * @return {string|Array.<string>} concrete data dim.\n *        If idx is number, and not found, return null/undefined.\n *        If idx is `true`, and not found, return empty array (always return array).\n */\n\n\nlistProto.mapDimension = function (coordDim, idx) {\n  var dimensionsSummary = this._dimensionsSummary;\n\n  if (idx == null) {\n    return dimensionsSummary.encodeFirstDimNotExtra[coordDim];\n  }\n\n  var dims = dimensionsSummary.encode[coordDim];\n  return idx === true // always return array if idx is `true`\n  ? (dims || []).slice() : dims && dims[idx];\n};\n/**\n * Initialize from data\n * @param {Array.<Object|number|Array>} data source or data or data provider.\n * @param {Array.<string>} [nameLIst] The name of a datum is used on data diff and\n *        defualt label/tooltip.\n *        A name can be specified in encode.itemName,\n *        or dataItem.name (only for series option data),\n *        or provided in nameList from outside.\n * @param {Function} [dimValueGetter] (dataItem, dimName, dataIndex, dimIndex) => number\n */\n\n\nlistProto.initData = function (data, nameList, dimValueGetter) {\n  var notProvider = Source.isInstance(data) || zrUtil.isArrayLike(data);\n\n  if (notProvider) {\n    data = new DefaultDataProvider(data, this.dimensions.length);\n  }\n\n  this._rawData = data; // Clear\n\n  this._storage = {};\n  this._indices = null;\n  this._nameList = nameList || [];\n  this._idList = [];\n  this._nameRepeatCount = {};\n\n  if (!dimValueGetter) {\n    this.hasItemOption = false;\n  }\n  /**\n   * @readOnly\n   */\n\n\n  this.defaultDimValueGetter = defaultDimValueGetters[this._rawData.getSource().sourceFormat]; // Default dim value getter\n\n  this._dimValueGetter = dimValueGetter = dimValueGetter || this.defaultDimValueGetter;\n  this._dimValueGetterArrayRows = defaultDimValueGetters.arrayRows; // Reset raw extent.\n\n  this._rawExtent = {};\n\n  this._initDataFromProvider(0, data.count()); // If data has no item option.\n\n\n  if (data.pure) {\n    this.hasItemOption = false;\n  }\n};\n\nlistProto.getProvider = function () {\n  return this._rawData;\n};\n/**\n * Caution: Can be only called on raw data (before `this._indices` created).\n */\n\n\nlistProto.appendData = function (data) {\n  var rawData = this._rawData;\n  var start = this.count();\n  rawData.appendData(data);\n  var end = rawData.count();\n\n  if (!rawData.persistent) {\n    end += start;\n  }\n\n  this._initDataFromProvider(start, end);\n};\n/**\n * Caution: Can be only called on raw data (before `this._indices` created).\n * This method does not modify `rawData` (`dataProvider`), but only\n * add values to storage.\n *\n * The final count will be increased by `Math.max(values.length, names.length)`.\n *\n * @param {Array.<Array.<*>>} values That is the SourceType: 'arrayRows', like\n *        [\n *            [12, 33, 44],\n *            [NaN, 43, 1],\n *            ['-', 'asdf', 0]\n *        ]\n *        Each item is exaclty cooresponding to a dimension.\n * @param {Array.<string>} [names]\n */\n\n\nlistProto.appendValues = function (values, names) {\n  var chunkSize = this._chunkSize;\n  var storage = this._storage;\n  var dimensions = this.dimensions;\n  var dimLen = dimensions.length;\n  var rawExtent = this._rawExtent;\n  var start = this.count();\n  var end = start + Math.max(values.length, names ? names.length : 0);\n  var originalChunkCount = this._chunkCount;\n\n  for (var i = 0; i < dimLen; i++) {\n    var dim = dimensions[i];\n\n    if (!rawExtent[dim]) {\n      rawExtent[dim] = getInitialExtent();\n    }\n\n    if (!storage[dim]) {\n      storage[dim] = [];\n    }\n\n    prepareChunks(storage, this._dimensionInfos[dim], chunkSize, originalChunkCount, end);\n    this._chunkCount = storage[dim].length;\n  }\n\n  var emptyDataItem = new Array(dimLen);\n\n  for (var idx = start; idx < end; idx++) {\n    var sourceIdx = idx - start;\n    var chunkIndex = Math.floor(idx / chunkSize);\n    var chunkOffset = idx % chunkSize; // Store the data by dimensions\n\n    for (var k = 0; k < dimLen; k++) {\n      var dim = dimensions[k];\n\n      var val = this._dimValueGetterArrayRows(values[sourceIdx] || emptyDataItem, dim, sourceIdx, k);\n\n      storage[dim][chunkIndex][chunkOffset] = val;\n      var dimRawExtent = rawExtent[dim];\n      val < dimRawExtent[0] && (dimRawExtent[0] = val);\n      val > dimRawExtent[1] && (dimRawExtent[1] = val);\n    }\n\n    if (names) {\n      this._nameList[idx] = names[sourceIdx];\n    }\n  }\n\n  this._rawCount = this._count = end; // Reset data extent\n\n  this._extent = {};\n  prepareInvertedIndex(this);\n};\n\nlistProto._initDataFromProvider = function (start, end) {\n  // Optimize.\n  if (start >= end) {\n    return;\n  }\n\n  var chunkSize = this._chunkSize;\n  var rawData = this._rawData;\n  var storage = this._storage;\n  var dimensions = this.dimensions;\n  var dimLen = dimensions.length;\n  var dimensionInfoMap = this._dimensionInfos;\n  var nameList = this._nameList;\n  var idList = this._idList;\n  var rawExtent = this._rawExtent;\n  var nameRepeatCount = this._nameRepeatCount = {};\n  var nameDimIdx;\n  var originalChunkCount = this._chunkCount;\n\n  for (var i = 0; i < dimLen; i++) {\n    var dim = dimensions[i];\n\n    if (!rawExtent[dim]) {\n      rawExtent[dim] = getInitialExtent();\n    }\n\n    var dimInfo = dimensionInfoMap[dim];\n\n    if (dimInfo.otherDims.itemName === 0) {\n      nameDimIdx = this._nameDimIdx = i;\n    }\n\n    if (dimInfo.otherDims.itemId === 0) {\n      this._idDimIdx = i;\n    }\n\n    if (!storage[dim]) {\n      storage[dim] = [];\n    }\n\n    prepareChunks(storage, dimInfo, chunkSize, originalChunkCount, end);\n    this._chunkCount = storage[dim].length;\n  }\n\n  var dataItem = new Array(dimLen);\n\n  for (var idx = start; idx < end; idx++) {\n    // NOTICE: Try not to write things into dataItem\n    dataItem = rawData.getItem(idx, dataItem); // Each data item is value\n    // [1, 2]\n    // 2\n    // Bar chart, line chart which uses category axis\n    // only gives the 'y' value. 'x' value is the indices of category\n    // Use a tempValue to normalize the value to be a (x, y) value\n\n    var chunkIndex = Math.floor(idx / chunkSize);\n    var chunkOffset = idx % chunkSize; // Store the data by dimensions\n\n    for (var k = 0; k < dimLen; k++) {\n      var dim = dimensions[k];\n      var dimStorage = storage[dim][chunkIndex]; // PENDING NULL is empty or zero\n\n      var val = this._dimValueGetter(dataItem, dim, idx, k);\n\n      dimStorage[chunkOffset] = val;\n      var dimRawExtent = rawExtent[dim];\n      val < dimRawExtent[0] && (dimRawExtent[0] = val);\n      val > dimRawExtent[1] && (dimRawExtent[1] = val);\n    } // ??? FIXME not check by pure but sourceFormat?\n    // TODO refactor these logic.\n\n\n    if (!rawData.pure) {\n      var name = nameList[idx];\n\n      if (dataItem && name == null) {\n        // If dataItem is {name: ...}, it has highest priority.\n        // That is appropriate for many common cases.\n        if (dataItem.name != null) {\n          // There is no other place to persistent dataItem.name,\n          // so save it to nameList.\n          nameList[idx] = name = dataItem.name;\n        } else if (nameDimIdx != null) {\n          var nameDim = dimensions[nameDimIdx];\n          var nameDimChunk = storage[nameDim][chunkIndex];\n\n          if (nameDimChunk) {\n            name = nameDimChunk[chunkOffset];\n            var ordinalMeta = dimensionInfoMap[nameDim].ordinalMeta;\n\n            if (ordinalMeta && ordinalMeta.categories.length) {\n              name = ordinalMeta.categories[name];\n            }\n          }\n        }\n      } // Try using the id in option\n      // id or name is used on dynamical data, mapping old and new items.\n\n\n      var id = dataItem == null ? null : dataItem.id;\n\n      if (id == null && name != null) {\n        // Use name as id and add counter to avoid same name\n        nameRepeatCount[name] = nameRepeatCount[name] || 0;\n        id = name;\n\n        if (nameRepeatCount[name] > 0) {\n          id += '__ec__' + nameRepeatCount[name];\n        }\n\n        nameRepeatCount[name]++;\n      }\n\n      id != null && (idList[idx] = id);\n    }\n  }\n\n  if (!rawData.persistent && rawData.clean) {\n    // Clean unused data if data source is typed array.\n    rawData.clean();\n  }\n\n  this._rawCount = this._count = end; // Reset data extent\n\n  this._extent = {};\n  prepareInvertedIndex(this);\n};\n\nfunction prepareChunks(storage, dimInfo, chunkSize, chunkCount, end) {\n  var DataCtor = dataCtors[dimInfo.type];\n  var lastChunkIndex = chunkCount - 1;\n  var dim = dimInfo.name;\n  var resizeChunkArray = storage[dim][lastChunkIndex];\n\n  if (resizeChunkArray && resizeChunkArray.length < chunkSize) {\n    var newStore = new DataCtor(Math.min(end - lastChunkIndex * chunkSize, chunkSize)); // The cost of the copy is probably inconsiderable\n    // within the initial chunkSize.\n\n    for (var j = 0; j < resizeChunkArray.length; j++) {\n      newStore[j] = resizeChunkArray[j];\n    }\n\n    storage[dim][lastChunkIndex] = newStore;\n  } // Create new chunks.\n\n\n  for (var k = chunkCount * chunkSize; k < end; k += chunkSize) {\n    storage[dim].push(new DataCtor(Math.min(end - k, chunkSize)));\n  }\n}\n\nfunction prepareInvertedIndex(list) {\n  var invertedIndicesMap = list._invertedIndicesMap;\n  zrUtil.each(invertedIndicesMap, function (invertedIndices, dim) {\n    var dimInfo = list._dimensionInfos[dim]; // Currently, only dimensions that has ordinalMeta can create inverted indices.\n\n    var ordinalMeta = dimInfo.ordinalMeta;\n\n    if (ordinalMeta) {\n      invertedIndices = invertedIndicesMap[dim] = new CtorInt32Array(ordinalMeta.categories.length); // The default value of TypedArray is 0. To avoid miss\n      // mapping to 0, we should set it as INDEX_NOT_FOUND.\n\n      for (var i = 0; i < invertedIndices.length; i++) {\n        invertedIndices[i] = INDEX_NOT_FOUND;\n      }\n\n      for (var i = 0; i < list._count; i++) {\n        // Only support the case that all values are distinct.\n        invertedIndices[list.get(dim, i)] = i;\n      }\n    }\n  });\n}\n\nfunction getRawValueFromStore(list, dimIndex, rawIndex) {\n  var val;\n\n  if (dimIndex != null) {\n    var chunkSize = list._chunkSize;\n    var chunkIndex = Math.floor(rawIndex / chunkSize);\n    var chunkOffset = rawIndex % chunkSize;\n    var dim = list.dimensions[dimIndex];\n    var chunk = list._storage[dim][chunkIndex];\n\n    if (chunk) {\n      val = chunk[chunkOffset];\n      var ordinalMeta = list._dimensionInfos[dim].ordinalMeta;\n\n      if (ordinalMeta && ordinalMeta.categories.length) {\n        val = ordinalMeta.categories[val];\n      }\n    }\n  }\n\n  return val;\n}\n/**\n * @return {number}\n */\n\n\nlistProto.count = function () {\n  return this._count;\n};\n\nlistProto.getIndices = function () {\n  var newIndices;\n  var indices = this._indices;\n\n  if (indices) {\n    var Ctor = indices.constructor;\n    var thisCount = this._count; // `new Array(a, b, c)` is different from `new Uint32Array(a, b, c)`.\n\n    if (Ctor === Array) {\n      newIndices = new Ctor(thisCount);\n\n      for (var i = 0; i < thisCount; i++) {\n        newIndices[i] = indices[i];\n      }\n    } else {\n      newIndices = new Ctor(indices.buffer, 0, thisCount);\n    }\n  } else {\n    var Ctor = getIndicesCtor(this);\n    var newIndices = new Ctor(this.count());\n\n    for (var i = 0; i < newIndices.length; i++) {\n      newIndices[i] = i;\n    }\n  }\n\n  return newIndices;\n};\n/**\n * Get value. Return NaN if idx is out of range.\n * @param {string} dim Dim must be concrete name.\n * @param {number} idx\n * @param {boolean} stack\n * @return {number}\n */\n\n\nlistProto.get = function (dim, idx\n/*, stack */\n) {\n  if (!(idx >= 0 && idx < this._count)) {\n    return NaN;\n  }\n\n  var storage = this._storage;\n\n  if (!storage[dim]) {\n    // TODO Warn ?\n    return NaN;\n  }\n\n  idx = this.getRawIndex(idx);\n  var chunkIndex = Math.floor(idx / this._chunkSize);\n  var chunkOffset = idx % this._chunkSize;\n  var chunkStore = storage[dim][chunkIndex];\n  var value = chunkStore[chunkOffset]; // FIXME ordinal data type is not stackable\n  // if (stack) {\n  //     var dimensionInfo = this._dimensionInfos[dim];\n  //     if (dimensionInfo && dimensionInfo.stackable) {\n  //         var stackedOn = this.stackedOn;\n  //         while (stackedOn) {\n  //             // Get no stacked data of stacked on\n  //             var stackedValue = stackedOn.get(dim, idx);\n  //             // Considering positive stack, negative stack and empty data\n  //             if ((value >= 0 && stackedValue > 0)  // Positive stack\n  //                 || (value <= 0 && stackedValue < 0) // Negative stack\n  //             ) {\n  //                 value += stackedValue;\n  //             }\n  //             stackedOn = stackedOn.stackedOn;\n  //         }\n  //     }\n  // }\n\n  return value;\n};\n/**\n * @param {string} dim concrete dim\n * @param {number} rawIndex\n * @return {number|string}\n */\n\n\nlistProto.getByRawIndex = function (dim, rawIdx) {\n  if (!(rawIdx >= 0 && rawIdx < this._rawCount)) {\n    return NaN;\n  }\n\n  var dimStore = this._storage[dim];\n\n  if (!dimStore) {\n    // TODO Warn ?\n    return NaN;\n  }\n\n  var chunkIndex = Math.floor(rawIdx / this._chunkSize);\n  var chunkOffset = rawIdx % this._chunkSize;\n  var chunkStore = dimStore[chunkIndex];\n  return chunkStore[chunkOffset];\n};\n/**\n * FIXME Use `get` on chrome maybe slow(in filterSelf and selectRange).\n * Hack a much simpler _getFast\n * @private\n */\n\n\nlistProto._getFast = function (dim, rawIdx) {\n  var chunkIndex = Math.floor(rawIdx / this._chunkSize);\n  var chunkOffset = rawIdx % this._chunkSize;\n  var chunkStore = this._storage[dim][chunkIndex];\n  return chunkStore[chunkOffset];\n};\n/**\n * Get value for multi dimensions.\n * @param {Array.<string>} [dimensions] If ignored, using all dimensions.\n * @param {number} idx\n * @return {number}\n */\n\n\nlistProto.getValues = function (dimensions, idx\n/*, stack */\n) {\n  var values = [];\n\n  if (!zrUtil.isArray(dimensions)) {\n    // stack = idx;\n    idx = dimensions;\n    dimensions = this.dimensions;\n  }\n\n  for (var i = 0, len = dimensions.length; i < len; i++) {\n    values.push(this.get(dimensions[i], idx\n    /*, stack */\n    ));\n  }\n\n  return values;\n};\n/**\n * If value is NaN. Inlcuding '-'\n * Only check the coord dimensions.\n * @param {string} dim\n * @param {number} idx\n * @return {number}\n */\n\n\nlistProto.hasValue = function (idx) {\n  var dataDimsOnCoord = this._dimensionsSummary.dataDimsOnCoord;\n  var dimensionInfos = this._dimensionInfos;\n\n  for (var i = 0, len = dataDimsOnCoord.length; i < len; i++) {\n    if ( // Ordinal type can be string or number\n    dimensionInfos[dataDimsOnCoord[i]].type !== 'ordinal' // FIXME check ordinal when using index?\n    && isNaN(this.get(dataDimsOnCoord[i], idx))) {\n      return false;\n    }\n  }\n\n  return true;\n};\n/**\n * Get extent of data in one dimension\n * @param {string} dim\n * @param {boolean} stack\n */\n\n\nlistProto.getDataExtent = function (dim\n/*, stack */\n) {\n  // Make sure use concrete dim as cache name.\n  dim = this.getDimension(dim);\n  var dimData = this._storage[dim];\n  var initialExtent = getInitialExtent(); // stack = !!((stack || false) && this.getCalculationInfo(dim));\n\n  if (!dimData) {\n    return initialExtent;\n  } // Make more strict checkings to ensure hitting cache.\n\n\n  var currEnd = this.count(); // var cacheName = [dim, !!stack].join('_');\n  // var cacheName = dim;\n  // Consider the most cases when using data zoom, `getDataExtent`\n  // happened before filtering. We cache raw extent, which is not\n  // necessary to be cleared and recalculated when restore data.\n\n  var useRaw = !this._indices; // && !stack;\n\n  var dimExtent;\n\n  if (useRaw) {\n    return this._rawExtent[dim].slice();\n  }\n\n  dimExtent = this._extent[dim];\n\n  if (dimExtent) {\n    return dimExtent.slice();\n  }\n\n  dimExtent = initialExtent;\n  var min = dimExtent[0];\n  var max = dimExtent[1];\n\n  for (var i = 0; i < currEnd; i++) {\n    // var value = stack ? this.get(dim, i, true) : this._getFast(dim, this.getRawIndex(i));\n    var value = this._getFast(dim, this.getRawIndex(i));\n\n    value < min && (min = value);\n    value > max && (max = value);\n  }\n\n  dimExtent = [min, max];\n  this._extent[dim] = dimExtent;\n  return dimExtent;\n};\n/**\n * Optimize for the scenario that data is filtered by a given extent.\n * Consider that if data amount is more than hundreds of thousand,\n * extent calculation will cost more than 10ms and the cache will\n * be erased because of the filtering.\n */\n\n\nlistProto.getApproximateExtent = function (dim\n/*, stack */\n) {\n  dim = this.getDimension(dim);\n  return this._approximateExtent[dim] || this.getDataExtent(dim\n  /*, stack */\n  );\n};\n\nlistProto.setApproximateExtent = function (extent, dim\n/*, stack */\n) {\n  dim = this.getDimension(dim);\n  this._approximateExtent[dim] = extent.slice();\n};\n/**\n * @param {string} key\n * @return {*}\n */\n\n\nlistProto.getCalculationInfo = function (key) {\n  return this._calculationInfo[key];\n};\n/**\n * @param {string|Object} key or k-v object\n * @param {*} [value]\n */\n\n\nlistProto.setCalculationInfo = function (key, value) {\n  isObject(key) ? zrUtil.extend(this._calculationInfo, key) : this._calculationInfo[key] = value;\n};\n/**\n * Get sum of data in one dimension\n * @param {string} dim\n */\n\n\nlistProto.getSum = function (dim\n/*, stack */\n) {\n  var dimData = this._storage[dim];\n  var sum = 0;\n\n  if (dimData) {\n    for (var i = 0, len = this.count(); i < len; i++) {\n      var value = this.get(dim, i\n      /*, stack */\n      );\n\n      if (!isNaN(value)) {\n        sum += value;\n      }\n    }\n  }\n\n  return sum;\n};\n/**\n * Get median of data in one dimension\n * @param {string} dim\n */\n\n\nlistProto.getMedian = function (dim\n/*, stack */\n) {\n  var dimDataArray = []; // map all data of one dimension\n\n  this.each(dim, function (val, idx) {\n    if (!isNaN(val)) {\n      dimDataArray.push(val);\n    }\n  }); // TODO\n  // Use quick select?\n  // immutability & sort\n\n  var sortedDimDataArray = [].concat(dimDataArray).sort(function (a, b) {\n    return a - b;\n  });\n  var len = this.count(); // calculate median\n\n  return len === 0 ? 0 : len % 2 === 1 ? sortedDimDataArray[(len - 1) / 2] : (sortedDimDataArray[len / 2] + sortedDimDataArray[len / 2 - 1]) / 2;\n}; // /**\n//  * Retreive the index with given value\n//  * @param {string} dim Concrete dimension.\n//  * @param {number} value\n//  * @return {number}\n//  */\n// Currently incorrect: should return dataIndex but not rawIndex.\n// Do not fix it until this method is to be used somewhere.\n// FIXME Precision of float value\n// listProto.indexOf = function (dim, value) {\n//     var storage = this._storage;\n//     var dimData = storage[dim];\n//     var chunkSize = this._chunkSize;\n//     if (dimData) {\n//         for (var i = 0, len = this.count(); i < len; i++) {\n//             var chunkIndex = Math.floor(i / chunkSize);\n//             var chunkOffset = i % chunkSize;\n//             if (dimData[chunkIndex][chunkOffset] === value) {\n//                 return i;\n//             }\n//         }\n//     }\n//     return -1;\n// };\n\n/**\n * Only support the dimension which inverted index created.\n * Do not support other cases until required.\n * @param {string} concrete dim\n * @param {number|string} value\n * @return {number} rawIndex\n */\n\n\nlistProto.rawIndexOf = function (dim, value) {\n  var invertedIndices = dim && this._invertedIndicesMap[dim];\n  var rawIndex = invertedIndices[value];\n\n  if (rawIndex == null || isNaN(rawIndex)) {\n    return INDEX_NOT_FOUND;\n  }\n\n  return rawIndex;\n};\n/**\n * Retreive the index with given name\n * @param {number} idx\n * @param {number} name\n * @return {number}\n */\n\n\nlistProto.indexOfName = function (name) {\n  for (var i = 0, len = this.count(); i < len; i++) {\n    if (this.getName(i) === name) {\n      return i;\n    }\n  }\n\n  return -1;\n};\n/**\n * Retreive the index with given raw data index\n * @param {number} idx\n * @param {number} name\n * @return {number}\n */\n\n\nlistProto.indexOfRawIndex = function (rawIndex) {\n  if (!this._indices) {\n    return rawIndex;\n  }\n\n  if (rawIndex >= this._rawCount || rawIndex < 0) {\n    return -1;\n  } // Indices are ascending\n\n\n  var indices = this._indices; // If rawIndex === dataIndex\n\n  var rawDataIndex = indices[rawIndex];\n\n  if (rawDataIndex != null && rawDataIndex < this._count && rawDataIndex === rawIndex) {\n    return rawIndex;\n  }\n\n  var left = 0;\n  var right = this._count - 1;\n\n  while (left <= right) {\n    var mid = (left + right) / 2 | 0;\n\n    if (indices[mid] < rawIndex) {\n      left = mid + 1;\n    } else if (indices[mid] > rawIndex) {\n      right = mid - 1;\n    } else {\n      return mid;\n    }\n  }\n\n  return -1;\n};\n/**\n * Retreive the index of nearest value\n * @param {string} dim\n * @param {number} value\n * @param {number} [maxDistance=Infinity]\n * @return {Array.<number>} Considere multiple points has the same value.\n */\n\n\nlistProto.indicesOfNearest = function (dim, value, maxDistance) {\n  var storage = this._storage;\n  var dimData = storage[dim];\n  var nearestIndices = [];\n\n  if (!dimData) {\n    return nearestIndices;\n  }\n\n  if (maxDistance == null) {\n    maxDistance = Infinity;\n  }\n\n  var minDist = Number.MAX_VALUE;\n  var minDiff = -1;\n\n  for (var i = 0, len = this.count(); i < len; i++) {\n    var diff = value - this.get(dim, i\n    /*, stack */\n    );\n    var dist = Math.abs(diff);\n\n    if (diff <= maxDistance && dist <= minDist) {\n      // For the case of two data are same on xAxis, which has sequence data.\n      // Show the nearest index\n      // https://github.com/ecomfe/echarts/issues/2869\n      if (dist < minDist || diff >= 0 && minDiff < 0) {\n        minDist = dist;\n        minDiff = diff;\n        nearestIndices.length = 0;\n      }\n\n      nearestIndices.push(i);\n    }\n  }\n\n  return nearestIndices;\n};\n/**\n * Get raw data index\n * @param {number} idx\n * @return {number}\n */\n\n\nlistProto.getRawIndex = getRawIndexWithoutIndices;\n\nfunction getRawIndexWithoutIndices(idx) {\n  return idx;\n}\n\nfunction getRawIndexWithIndices(idx) {\n  if (idx < this._count && idx >= 0) {\n    return this._indices[idx];\n  }\n\n  return -1;\n}\n/**\n * Get raw data item\n * @param {number} idx\n * @return {number}\n */\n\n\nlistProto.getRawDataItem = function (idx) {\n  if (!this._rawData.persistent) {\n    var val = [];\n\n    for (var i = 0; i < this.dimensions.length; i++) {\n      var dim = this.dimensions[i];\n      val.push(this.get(dim, idx));\n    }\n\n    return val;\n  } else {\n    return this._rawData.getItem(this.getRawIndex(idx));\n  }\n};\n/**\n * @param {number} idx\n * @param {boolean} [notDefaultIdx=false]\n * @return {string}\n */\n\n\nlistProto.getName = function (idx) {\n  var rawIndex = this.getRawIndex(idx);\n  return this._nameList[rawIndex] || getRawValueFromStore(this, this._nameDimIdx, rawIndex) || '';\n};\n/**\n * @param {number} idx\n * @param {boolean} [notDefaultIdx=false]\n * @return {string}\n */\n\n\nlistProto.getId = function (idx) {\n  return getId(this, this.getRawIndex(idx));\n};\n\nfunction getId(list, rawIndex) {\n  var id = list._idList[rawIndex];\n\n  if (id == null) {\n    id = getRawValueFromStore(list, list._idDimIdx, rawIndex);\n  }\n\n  if (id == null) {\n    // FIXME Check the usage in graph, should not use prefix.\n    id = ID_PREFIX + rawIndex;\n  }\n\n  return id;\n}\n\nfunction normalizeDimensions(dimensions) {\n  if (!zrUtil.isArray(dimensions)) {\n    dimensions = [dimensions];\n  }\n\n  return dimensions;\n}\n\nfunction validateDimensions(list, dims) {\n  for (var i = 0; i < dims.length; i++) {\n    // stroage may be empty when no data, so use\n    // dimensionInfos to check.\n    if (!list._dimensionInfos[dims[i]]) {\n      console.error('Unkown dimension ' + dims[i]);\n    }\n  }\n}\n/**\n * Data iteration\n * @param {string|Array.<string>}\n * @param {Function} cb\n * @param {*} [context=this]\n *\n * @example\n *  list.each('x', function (x, idx) {});\n *  list.each(['x', 'y'], function (x, y, idx) {});\n *  list.each(function (idx) {})\n */\n\n\nlistProto.each = function (dims, cb, context, contextCompat) {\n  'use strict';\n\n  if (!this._count) {\n    return;\n  }\n\n  if (typeof dims === 'function') {\n    contextCompat = context;\n    context = cb;\n    cb = dims;\n    dims = [];\n  } // contextCompat just for compat echarts3\n\n\n  context = context || contextCompat || this;\n  dims = zrUtil.map(normalizeDimensions(dims), this.getDimension, this);\n  var dimSize = dims.length;\n\n  for (var i = 0; i < this.count(); i++) {\n    // Simple optimization\n    switch (dimSize) {\n      case 0:\n        cb.call(context, i);\n        break;\n\n      case 1:\n        cb.call(context, this.get(dims[0], i), i);\n        break;\n\n      case 2:\n        cb.call(context, this.get(dims[0], i), this.get(dims[1], i), i);\n        break;\n\n      default:\n        var k = 0;\n        var value = [];\n\n        for (; k < dimSize; k++) {\n          value[k] = this.get(dims[k], i);\n        } // Index\n\n\n        value[k] = i;\n        cb.apply(context, value);\n    }\n  }\n};\n/**\n * Data filter\n * @param {string|Array.<string>}\n * @param {Function} cb\n * @param {*} [context=this]\n */\n\n\nlistProto.filterSelf = function (dimensions, cb, context, contextCompat) {\n  'use strict';\n\n  if (!this._count) {\n    return;\n  }\n\n  if (typeof dimensions === 'function') {\n    contextCompat = context;\n    context = cb;\n    cb = dimensions;\n    dimensions = [];\n  } // contextCompat just for compat echarts3\n\n\n  context = context || contextCompat || this;\n  dimensions = zrUtil.map(normalizeDimensions(dimensions), this.getDimension, this);\n  var count = this.count();\n  var Ctor = getIndicesCtor(this);\n  var newIndices = new Ctor(count);\n  var value = [];\n  var dimSize = dimensions.length;\n  var offset = 0;\n  var dim0 = dimensions[0];\n\n  for (var i = 0; i < count; i++) {\n    var keep;\n    var rawIdx = this.getRawIndex(i); // Simple optimization\n\n    if (dimSize === 0) {\n      keep = cb.call(context, i);\n    } else if (dimSize === 1) {\n      var val = this._getFast(dim0, rawIdx);\n\n      keep = cb.call(context, val, i);\n    } else {\n      for (var k = 0; k < dimSize; k++) {\n        value[k] = this._getFast(dim0, rawIdx);\n      }\n\n      value[k] = i;\n      keep = cb.apply(context, value);\n    }\n\n    if (keep) {\n      newIndices[offset++] = rawIdx;\n    }\n  } // Set indices after filtered.\n\n\n  if (offset < count) {\n    this._indices = newIndices;\n  }\n\n  this._count = offset; // Reset data extent\n\n  this._extent = {};\n  this.getRawIndex = this._indices ? getRawIndexWithIndices : getRawIndexWithoutIndices;\n  return this;\n};\n/**\n * Select data in range. (For optimization of filter)\n * (Manually inline code, support 5 million data filtering in data zoom.)\n */\n\n\nlistProto.selectRange = function (range) {\n  'use strict';\n\n  if (!this._count) {\n    return;\n  }\n\n  var dimensions = [];\n\n  for (var dim in range) {\n    if (range.hasOwnProperty(dim)) {\n      dimensions.push(dim);\n    }\n  }\n\n  var dimSize = dimensions.length;\n\n  if (!dimSize) {\n    return;\n  }\n\n  var originalCount = this.count();\n  var Ctor = getIndicesCtor(this);\n  var newIndices = new Ctor(originalCount);\n  var offset = 0;\n  var dim0 = dimensions[0];\n  var min = range[dim0][0];\n  var max = range[dim0][1];\n  var quickFinished = false;\n\n  if (!this._indices) {\n    // Extreme optimization for common case. About 2x faster in chrome.\n    var idx = 0;\n\n    if (dimSize === 1) {\n      var dimStorage = this._storage[dimensions[0]];\n\n      for (var k = 0; k < this._chunkCount; k++) {\n        var chunkStorage = dimStorage[k];\n        var len = Math.min(this._count - k * this._chunkSize, this._chunkSize);\n\n        for (var i = 0; i < len; i++) {\n          var val = chunkStorage[i]; // NaN will not be filtered. Consider the case, in line chart, empty\n          // value indicates the line should be broken. But for the case like\n          // scatter plot, a data item with empty value will not be rendered,\n          // but the axis extent may be effected if some other dim of the data\n          // item has value. Fortunately it is not a significant negative effect.\n\n          if (val >= min && val <= max || isNaN(val)) {\n            newIndices[offset++] = idx;\n          }\n\n          idx++;\n        }\n      }\n\n      quickFinished = true;\n    } else if (dimSize === 2) {\n      var dimStorage = this._storage[dim0];\n      var dimStorage2 = this._storage[dimensions[1]];\n      var min2 = range[dimensions[1]][0];\n      var max2 = range[dimensions[1]][1];\n\n      for (var k = 0; k < this._chunkCount; k++) {\n        var chunkStorage = dimStorage[k];\n        var chunkStorage2 = dimStorage2[k];\n        var len = Math.min(this._count - k * this._chunkSize, this._chunkSize);\n\n        for (var i = 0; i < len; i++) {\n          var val = chunkStorage[i];\n          var val2 = chunkStorage2[i]; // Do not filter NaN, see comment above.\n\n          if ((val >= min && val <= max || isNaN(val)) && (val2 >= min2 && val2 <= max2 || isNaN(val2))) {\n            newIndices[offset++] = idx;\n          }\n\n          idx++;\n        }\n      }\n\n      quickFinished = true;\n    }\n  }\n\n  if (!quickFinished) {\n    if (dimSize === 1) {\n      for (var i = 0; i < originalCount; i++) {\n        var rawIndex = this.getRawIndex(i);\n\n        var val = this._getFast(dim0, rawIndex); // Do not filter NaN, see comment above.\n\n\n        if (val >= min && val <= max || isNaN(val)) {\n          newIndices[offset++] = rawIndex;\n        }\n      }\n    } else {\n      for (var i = 0; i < originalCount; i++) {\n        var keep = true;\n        var rawIndex = this.getRawIndex(i);\n\n        for (var k = 0; k < dimSize; k++) {\n          var dimk = dimensions[k];\n\n          var val = this._getFast(dim, rawIndex); // Do not filter NaN, see comment above.\n\n\n          if (val < range[dimk][0] || val > range[dimk][1]) {\n            keep = false;\n          }\n        }\n\n        if (keep) {\n          newIndices[offset++] = this.getRawIndex(i);\n        }\n      }\n    }\n  } // Set indices after filtered.\n\n\n  if (offset < originalCount) {\n    this._indices = newIndices;\n  }\n\n  this._count = offset; // Reset data extent\n\n  this._extent = {};\n  this.getRawIndex = this._indices ? getRawIndexWithIndices : getRawIndexWithoutIndices;\n  return this;\n};\n/**\n * Data mapping to a plain array\n * @param {string|Array.<string>} [dimensions]\n * @param {Function} cb\n * @param {*} [context=this]\n * @return {Array}\n */\n\n\nlistProto.mapArray = function (dimensions, cb, context, contextCompat) {\n  'use strict';\n\n  if (typeof dimensions === 'function') {\n    contextCompat = context;\n    context = cb;\n    cb = dimensions;\n    dimensions = [];\n  } // contextCompat just for compat echarts3\n\n\n  context = context || contextCompat || this;\n  var result = [];\n  this.each(dimensions, function () {\n    result.push(cb && cb.apply(this, arguments));\n  }, context);\n  return result;\n}; // Data in excludeDimensions is copied, otherwise transfered.\n\n\nfunction cloneListForMapAndSample(original, excludeDimensions) {\n  var allDimensions = original.dimensions;\n  var list = new List(zrUtil.map(allDimensions, original.getDimensionInfo, original), original.hostModel); // FIXME If needs stackedOn, value may already been stacked\n\n  transferProperties(list, original);\n  var storage = list._storage = {};\n  var originalStorage = original._storage; // Init storage\n\n  for (var i = 0; i < allDimensions.length; i++) {\n    var dim = allDimensions[i];\n\n    if (originalStorage[dim]) {\n      // Notice that we do not reset invertedIndicesMap here, becuase\n      // there is no scenario of mapping or sampling ordinal dimension.\n      if (zrUtil.indexOf(excludeDimensions, dim) >= 0) {\n        storage[dim] = cloneDimStore(originalStorage[dim]);\n        list._rawExtent[dim] = getInitialExtent();\n        list._extent[dim] = null;\n      } else {\n        // Direct reference for other dimensions\n        storage[dim] = originalStorage[dim];\n      }\n    }\n  }\n\n  return list;\n}\n\nfunction cloneDimStore(originalDimStore) {\n  var newDimStore = new Array(originalDimStore.length);\n\n  for (var j = 0; j < originalDimStore.length; j++) {\n    newDimStore[j] = cloneChunk(originalDimStore[j]);\n  }\n\n  return newDimStore;\n}\n\nfunction getInitialExtent() {\n  return [Infinity, -Infinity];\n}\n/**\n * Data mapping to a new List with given dimensions\n * @param {string|Array.<string>} dimensions\n * @param {Function} cb\n * @param {*} [context=this]\n * @return {Array}\n */\n\n\nlistProto.map = function (dimensions, cb, context, contextCompat) {\n  'use strict'; // contextCompat just for compat echarts3\n\n  context = context || contextCompat || this;\n  dimensions = zrUtil.map(normalizeDimensions(dimensions), this.getDimension, this);\n  var list = cloneListForMapAndSample(this, dimensions); // Following properties are all immutable.\n  // So we can reference to the same value\n\n  list._indices = this._indices;\n  list.getRawIndex = list._indices ? getRawIndexWithIndices : getRawIndexWithoutIndices;\n  var storage = list._storage;\n  var tmpRetValue = [];\n  var chunkSize = this._chunkSize;\n  var dimSize = dimensions.length;\n  var dataCount = this.count();\n  var values = [];\n  var rawExtent = list._rawExtent;\n\n  for (var dataIndex = 0; dataIndex < dataCount; dataIndex++) {\n    for (var dimIndex = 0; dimIndex < dimSize; dimIndex++) {\n      values[dimIndex] = this.get(dimensions[dimIndex], dataIndex\n      /*, stack */\n      );\n    }\n\n    values[dimSize] = dataIndex;\n    var retValue = cb && cb.apply(context, values);\n\n    if (retValue != null) {\n      // a number or string (in oridinal dimension)?\n      if (typeof retValue !== 'object') {\n        tmpRetValue[0] = retValue;\n        retValue = tmpRetValue;\n      }\n\n      var rawIndex = this.getRawIndex(dataIndex);\n      var chunkIndex = Math.floor(rawIndex / chunkSize);\n      var chunkOffset = rawIndex % chunkSize;\n\n      for (var i = 0; i < retValue.length; i++) {\n        var dim = dimensions[i];\n        var val = retValue[i];\n        var rawExtentOnDim = rawExtent[dim];\n        var dimStore = storage[dim];\n\n        if (dimStore) {\n          dimStore[chunkIndex][chunkOffset] = val;\n        }\n\n        if (val < rawExtentOnDim[0]) {\n          rawExtentOnDim[0] = val;\n        }\n\n        if (val > rawExtentOnDim[1]) {\n          rawExtentOnDim[1] = val;\n        }\n      }\n    }\n  }\n\n  return list;\n};\n/**\n * Large data down sampling on given dimension\n * @param {string} dimension\n * @param {number} rate\n * @param {Function} sampleValue\n * @param {Function} sampleIndex Sample index for name and id\n */\n\n\nlistProto.downSample = function (dimension, rate, sampleValue, sampleIndex) {\n  var list = cloneListForMapAndSample(this, [dimension]);\n  var targetStorage = list._storage;\n  var frameValues = [];\n  var frameSize = Math.floor(1 / rate);\n  var dimStore = targetStorage[dimension];\n  var len = this.count();\n  var chunkSize = this._chunkSize;\n  var rawExtentOnDim = list._rawExtent[dimension];\n  var newIndices = new (getIndicesCtor(this))(len);\n  var offset = 0;\n\n  for (var i = 0; i < len; i += frameSize) {\n    // Last frame\n    if (frameSize > len - i) {\n      frameSize = len - i;\n      frameValues.length = frameSize;\n    }\n\n    for (var k = 0; k < frameSize; k++) {\n      var dataIdx = this.getRawIndex(i + k);\n      var originalChunkIndex = Math.floor(dataIdx / chunkSize);\n      var originalChunkOffset = dataIdx % chunkSize;\n      frameValues[k] = dimStore[originalChunkIndex][originalChunkOffset];\n    }\n\n    var value = sampleValue(frameValues);\n    var sampleFrameIdx = this.getRawIndex(Math.min(i + sampleIndex(frameValues, value) || 0, len - 1));\n    var sampleChunkIndex = Math.floor(sampleFrameIdx / chunkSize);\n    var sampleChunkOffset = sampleFrameIdx % chunkSize; // Only write value on the filtered data\n\n    dimStore[sampleChunkIndex][sampleChunkOffset] = value;\n\n    if (value < rawExtentOnDim[0]) {\n      rawExtentOnDim[0] = value;\n    }\n\n    if (value > rawExtentOnDim[1]) {\n      rawExtentOnDim[1] = value;\n    }\n\n    newIndices[offset++] = sampleFrameIdx;\n  }\n\n  list._count = offset;\n  list._indices = newIndices;\n  list.getRawIndex = getRawIndexWithIndices;\n  return list;\n};\n/**\n * Get model of one data item.\n *\n * @param {number} idx\n */\n// FIXME Model proxy ?\n\n\nlistProto.getItemModel = function (idx) {\n  var hostModel = this.hostModel;\n  return new Model(this.getRawDataItem(idx), hostModel, hostModel && hostModel.ecModel);\n};\n/**\n * Create a data differ\n * @param {module:echarts/data/List} otherList\n * @return {module:echarts/data/DataDiffer}\n */\n\n\nlistProto.diff = function (otherList) {\n  var thisList = this;\n  return new DataDiffer(otherList ? otherList.getIndices() : [], this.getIndices(), function (idx) {\n    return getId(otherList, idx);\n  }, function (idx) {\n    return getId(thisList, idx);\n  });\n};\n/**\n * Get visual property.\n * @param {string} key\n */\n\n\nlistProto.getVisual = function (key) {\n  var visual = this._visual;\n  return visual && visual[key];\n};\n/**\n * Set visual property\n * @param {string|Object} key\n * @param {*} [value]\n *\n * @example\n *  setVisual('color', color);\n *  setVisual({\n *      'color': color\n *  });\n */\n\n\nlistProto.setVisual = function (key, val) {\n  if (isObject(key)) {\n    for (var name in key) {\n      if (key.hasOwnProperty(name)) {\n        this.setVisual(name, key[name]);\n      }\n    }\n\n    return;\n  }\n\n  this._visual = this._visual || {};\n  this._visual[key] = val;\n};\n/**\n * Set layout property.\n * @param {string|Object} key\n * @param {*} [val]\n */\n\n\nlistProto.setLayout = function (key, val) {\n  if (isObject(key)) {\n    for (var name in key) {\n      if (key.hasOwnProperty(name)) {\n        this.setLayout(name, key[name]);\n      }\n    }\n\n    return;\n  }\n\n  this._layout[key] = val;\n};\n/**\n * Get layout property.\n * @param  {string} key.\n * @return {*}\n */\n\n\nlistProto.getLayout = function (key) {\n  return this._layout[key];\n};\n/**\n * Get layout of single data item\n * @param {number} idx\n */\n\n\nlistProto.getItemLayout = function (idx) {\n  return this._itemLayouts[idx];\n};\n/**\n * Set layout of single data item\n * @param {number} idx\n * @param {Object} layout\n * @param {boolean=} [merge=false]\n */\n\n\nlistProto.setItemLayout = function (idx, layout, merge) {\n  this._itemLayouts[idx] = merge ? zrUtil.extend(this._itemLayouts[idx] || {}, layout) : layout;\n};\n/**\n * Clear all layout of single data item\n */\n\n\nlistProto.clearItemLayouts = function () {\n  this._itemLayouts.length = 0;\n};\n/**\n * Get visual property of single data item\n * @param {number} idx\n * @param {string} key\n * @param {boolean} [ignoreParent=false]\n */\n\n\nlistProto.getItemVisual = function (idx, key, ignoreParent) {\n  var itemVisual = this._itemVisuals[idx];\n  var val = itemVisual && itemVisual[key];\n\n  if (val == null && !ignoreParent) {\n    // Use global visual property\n    return this.getVisual(key);\n  }\n\n  return val;\n};\n/**\n * Set visual property of single data item\n *\n * @param {number} idx\n * @param {string|Object} key\n * @param {*} [value]\n *\n * @example\n *  setItemVisual(0, 'color', color);\n *  setItemVisual(0, {\n *      'color': color\n *  });\n */\n\n\nlistProto.setItemVisual = function (idx, key, value) {\n  var itemVisual = this._itemVisuals[idx] || {};\n  var hasItemVisual = this.hasItemVisual;\n  this._itemVisuals[idx] = itemVisual;\n\n  if (isObject(key)) {\n    for (var name in key) {\n      if (key.hasOwnProperty(name)) {\n        itemVisual[name] = key[name];\n        hasItemVisual[name] = true;\n      }\n    }\n\n    return;\n  }\n\n  itemVisual[key] = value;\n  hasItemVisual[key] = true;\n};\n/**\n * Clear itemVisuals and list visual.\n */\n\n\nlistProto.clearAllVisual = function () {\n  this._visual = {};\n  this._itemVisuals = [];\n  this.hasItemVisual = {};\n};\n\nvar setItemDataAndSeriesIndex = function (child) {\n  child.seriesIndex = this.seriesIndex;\n  child.dataIndex = this.dataIndex;\n  child.dataType = this.dataType;\n};\n/**\n * Set graphic element relative to data. It can be set as null\n * @param {number} idx\n * @param {module:zrender/Element} [el]\n */\n\n\nlistProto.setItemGraphicEl = function (idx, el) {\n  var hostModel = this.hostModel;\n\n  if (el) {\n    // Add data index and series index for indexing the data by element\n    // Useful in tooltip\n    el.dataIndex = idx;\n    el.dataType = this.dataType;\n    el.seriesIndex = hostModel && hostModel.seriesIndex;\n\n    if (el.type === 'group') {\n      el.traverse(setItemDataAndSeriesIndex, el);\n    }\n  }\n\n  this._graphicEls[idx] = el;\n};\n/**\n * @param {number} idx\n * @return {module:zrender/Element}\n */\n\n\nlistProto.getItemGraphicEl = function (idx) {\n  return this._graphicEls[idx];\n};\n/**\n * @param {Function} cb\n * @param {*} context\n */\n\n\nlistProto.eachItemGraphicEl = function (cb, context) {\n  zrUtil.each(this._graphicEls, function (el, idx) {\n    if (el) {\n      cb && cb.call(context, el, idx);\n    }\n  });\n};\n/**\n * Shallow clone a new list except visual and layout properties, and graph elements.\n * New list only change the indices.\n */\n\n\nlistProto.cloneShallow = function (list) {\n  if (!list) {\n    var dimensionInfoList = zrUtil.map(this.dimensions, this.getDimensionInfo, this);\n    list = new List(dimensionInfoList, this.hostModel);\n  } // FIXME\n\n\n  list._storage = this._storage;\n  transferProperties(list, this); // Clone will not change the data extent and indices\n\n  if (this._indices) {\n    var Ctor = this._indices.constructor;\n    list._indices = new Ctor(this._indices);\n  } else {\n    list._indices = null;\n  }\n\n  list.getRawIndex = list._indices ? getRawIndexWithIndices : getRawIndexWithoutIndices;\n  return list;\n};\n/**\n * Wrap some method to add more feature\n * @param {string} methodName\n * @param {Function} injectFunction\n */\n\n\nlistProto.wrapMethod = function (methodName, injectFunction) {\n  var originalMethod = this[methodName];\n\n  if (typeof originalMethod !== 'function') {\n    return;\n  }\n\n  this.__wrappedMethods = this.__wrappedMethods || [];\n\n  this.__wrappedMethods.push(methodName);\n\n  this[methodName] = function () {\n    var res = originalMethod.apply(this, arguments);\n    return injectFunction.apply(this, [res].concat(zrUtil.slice(arguments)));\n  };\n}; // Methods that create a new list based on this list should be listed here.\n// Notice that those method should `RETURN` the new list.\n\n\nlistProto.TRANSFERABLE_METHODS = ['cloneShallow', 'downSample', 'map']; // Methods that change indices of this list should be listed here.\n\nlistProto.CHANGABLE_METHODS = ['filterSelf', 'selectRange'];\nvar _default = List;\nmodule.exports = _default;"]},"metadata":{},"sourceType":"script"}