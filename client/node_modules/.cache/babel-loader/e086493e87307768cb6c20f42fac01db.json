{"ast":null,"code":"/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar numberUtil = require(\"../../util/number\");\n\nvar helper = require(\"./helper\");\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\nvar each = zrUtil.each;\nvar asc = numberUtil.asc;\n/**\n * Operate single axis.\n * One axis can only operated by one axis operator.\n * Different dataZoomModels may be defined to operate the same axis.\n * (i.e. 'inside' data zoom and 'slider' data zoom components)\n * So dataZoomModels share one axisProxy in that case.\n *\n * @class\n */\n\nvar AxisProxy = function AxisProxy(dimName, axisIndex, dataZoomModel, ecModel) {\n  /**\n   * @private\n   * @type {string}\n   */\n  this._dimName = dimName;\n  /**\n   * @private\n   */\n\n  this._axisIndex = axisIndex;\n  /**\n   * @private\n   * @type {Array.<number>}\n   */\n\n  this._valueWindow;\n  /**\n   * @private\n   * @type {Array.<number>}\n   */\n\n  this._percentWindow;\n  /**\n   * @private\n   * @type {Array.<number>}\n   */\n\n  this._dataExtent;\n  /**\n   * {minSpan, maxSpan, minValueSpan, maxValueSpan}\n   * @private\n   * @type {Object}\n   */\n\n  this._minMaxSpan;\n  /**\n   * @readOnly\n   * @type {module: echarts/model/Global}\n   */\n\n  this.ecModel = ecModel;\n  /**\n   * @private\n   * @type {module: echarts/component/dataZoom/DataZoomModel}\n   */\n\n  this._dataZoomModel = dataZoomModel; // /**\n  //  * @readOnly\n  //  * @private\n  //  */\n  // this.hasSeriesStacked;\n};\n\nAxisProxy.prototype = {\n  constructor: AxisProxy,\n\n  /**\n   * Whether the axisProxy is hosted by dataZoomModel.\n   *\n   * @public\n   * @param {module: echarts/component/dataZoom/DataZoomModel} dataZoomModel\n   * @return {boolean}\n   */\n  hostedBy: function hostedBy(dataZoomModel) {\n    return this._dataZoomModel === dataZoomModel;\n  },\n\n  /**\n   * @return {Array.<number>} Value can only be NaN or finite value.\n   */\n  getDataValueWindow: function getDataValueWindow() {\n    return this._valueWindow.slice();\n  },\n\n  /**\n   * @return {Array.<number>}\n   */\n  getDataPercentWindow: function getDataPercentWindow() {\n    return this._percentWindow.slice();\n  },\n\n  /**\n   * @public\n   * @param {number} axisIndex\n   * @return {Array} seriesModels\n   */\n  getTargetSeriesModels: function getTargetSeriesModels() {\n    var seriesModels = [];\n    var ecModel = this.ecModel;\n    ecModel.eachSeries(function (seriesModel) {\n      if (helper.isCoordSupported(seriesModel.get('coordinateSystem'))) {\n        var dimName = this._dimName;\n        var axisModel = ecModel.queryComponents({\n          mainType: dimName + 'Axis',\n          index: seriesModel.get(dimName + 'AxisIndex'),\n          id: seriesModel.get(dimName + 'AxisId')\n        })[0];\n\n        if (this._axisIndex === (axisModel && axisModel.componentIndex)) {\n          seriesModels.push(seriesModel);\n        }\n      }\n    }, this);\n    return seriesModels;\n  },\n  getAxisModel: function getAxisModel() {\n    return this.ecModel.getComponent(this._dimName + 'Axis', this._axisIndex);\n  },\n  getOtherAxisModel: function getOtherAxisModel() {\n    var axisDim = this._dimName;\n    var ecModel = this.ecModel;\n    var axisModel = this.getAxisModel();\n    var isCartesian = axisDim === 'x' || axisDim === 'y';\n    var otherAxisDim;\n    var coordSysIndexName;\n\n    if (isCartesian) {\n      coordSysIndexName = 'gridIndex';\n      otherAxisDim = axisDim === 'x' ? 'y' : 'x';\n    } else {\n      coordSysIndexName = 'polarIndex';\n      otherAxisDim = axisDim === 'angle' ? 'radius' : 'angle';\n    }\n\n    var foundOtherAxisModel;\n    ecModel.eachComponent(otherAxisDim + 'Axis', function (otherAxisModel) {\n      if ((otherAxisModel.get(coordSysIndexName) || 0) === (axisModel.get(coordSysIndexName) || 0)) {\n        foundOtherAxisModel = otherAxisModel;\n      }\n    });\n    return foundOtherAxisModel;\n  },\n  getMinMaxSpan: function getMinMaxSpan() {\n    return zrUtil.clone(this._minMaxSpan);\n  },\n\n  /**\n   * Only calculate by given range and this._dataExtent, do not change anything.\n   *\n   * @param {Object} opt\n   * @param {number} [opt.start]\n   * @param {number} [opt.end]\n   * @param {number} [opt.startValue]\n   * @param {number} [opt.endValue]\n   */\n  calculateDataWindow: function calculateDataWindow(opt) {\n    var dataExtent = this._dataExtent;\n    var axisModel = this.getAxisModel();\n    var scale = axisModel.axis.scale;\n\n    var rangePropMode = this._dataZoomModel.getRangePropMode();\n\n    var percentExtent = [0, 100];\n    var percentWindow = [opt.start, opt.end];\n    var valueWindow = [];\n    each(['startValue', 'endValue'], function (prop) {\n      valueWindow.push(opt[prop] != null ? scale.parse(opt[prop]) : null);\n    }); // Normalize bound.\n\n    each([0, 1], function (idx) {\n      var boundValue = valueWindow[idx];\n      var boundPercent = percentWindow[idx]; // Notice: dataZoom is based either on `percentProp` ('start', 'end') or\n      // on `valueProp` ('startValue', 'endValue'). The former one is suitable\n      // for cases that a dataZoom component controls multiple axes with different\n      // unit or extent, and the latter one is suitable for accurate zoom by pixel\n      // (e.g., in dataZoomSelect). `valueProp` can be calculated from `percentProp`,\n      // but it is awkward that `percentProp` can not be obtained from `valueProp`\n      // accurately (because all of values that are overflow the `dataExtent` will\n      // be calculated to percent '100%'). So we have to use\n      // `dataZoom.getRangePropMode()` to mark which prop is used.\n      // `rangePropMode` is updated only when setOption or dispatchAction, otherwise\n      // it remains its original value.\n\n      if (rangePropMode[idx] === 'percent') {\n        if (boundPercent == null) {\n          boundPercent = percentExtent[idx];\n        } // Use scale.parse to math round for category or time axis.\n\n\n        boundValue = scale.parse(numberUtil.linearMap(boundPercent, percentExtent, dataExtent, true));\n      } else {\n        // Calculating `percent` from `value` may be not accurate, because\n        // This calculation can not be inversed, because all of values that\n        // are overflow the `dataExtent` will be calculated to percent '100%'\n        boundPercent = numberUtil.linearMap(boundValue, dataExtent, percentExtent, true);\n      } // valueWindow[idx] = round(boundValue);\n      // percentWindow[idx] = round(boundPercent);\n\n\n      valueWindow[idx] = boundValue;\n      percentWindow[idx] = boundPercent;\n    });\n    return {\n      valueWindow: asc(valueWindow),\n      percentWindow: asc(percentWindow)\n    };\n  },\n\n  /**\n   * Notice: reset should not be called before series.restoreData() called,\n   * so it is recommanded to be called in \"process stage\" but not \"model init\n   * stage\".\n   *\n   * @param {module: echarts/component/dataZoom/DataZoomModel} dataZoomModel\n   */\n  reset: function reset(dataZoomModel) {\n    if (dataZoomModel !== this._dataZoomModel) {\n      return;\n    }\n\n    var targetSeries = this.getTargetSeriesModels(); // Culculate data window and data extent, and record them.\n\n    this._dataExtent = calculateDataExtent(this, this._dimName, targetSeries); // this.hasSeriesStacked = false;\n    // each(targetSeries, function (series) {\n    // var data = series.getData();\n    // var dataDim = data.mapDimension(this._dimName);\n    // var stackedDimension = data.getCalculationInfo('stackedDimension');\n    // if (stackedDimension && stackedDimension === dataDim) {\n    // this.hasSeriesStacked = true;\n    // }\n    // }, this);\n\n    var dataWindow = this.calculateDataWindow(dataZoomModel.option);\n    this._valueWindow = dataWindow.valueWindow;\n    this._percentWindow = dataWindow.percentWindow;\n    setMinMaxSpan(this); // Update axis setting then.\n\n    setAxisModel(this);\n  },\n\n  /**\n   * @param {module: echarts/component/dataZoom/DataZoomModel} dataZoomModel\n   */\n  restore: function restore(dataZoomModel) {\n    if (dataZoomModel !== this._dataZoomModel) {\n      return;\n    }\n\n    this._valueWindow = this._percentWindow = null;\n    setAxisModel(this, true);\n  },\n\n  /**\n   * @param {module: echarts/component/dataZoom/DataZoomModel} dataZoomModel\n   */\n  filterData: function filterData(dataZoomModel, api) {\n    if (dataZoomModel !== this._dataZoomModel) {\n      return;\n    }\n\n    var axisDim = this._dimName;\n    var seriesModels = this.getTargetSeriesModels();\n    var filterMode = dataZoomModel.get('filterMode');\n    var valueWindow = this._valueWindow;\n\n    if (filterMode === 'none') {\n      return;\n    } // FIXME\n    // Toolbox may has dataZoom injected. And if there are stacked bar chart\n    // with NaN data, NaN will be filtered and stack will be wrong.\n    // So we need to force the mode to be set empty.\n    // In fect, it is not a big deal that do not support filterMode-'filter'\n    // when using toolbox#dataZoom, utill tooltip#dataZoom support \"single axis\n    // selection\" some day, which might need \"adapt to data extent on the\n    // otherAxis\", which is disabled by filterMode-'empty'.\n    // But currently, stack has been fixed to based on value but not index,\n    // so this is not an issue any more.\n    // var otherAxisModel = this.getOtherAxisModel();\n    // if (dataZoomModel.get('$fromToolbox')\n    //     && otherAxisModel\n    //     && otherAxisModel.hasSeriesStacked\n    // ) {\n    //     filterMode = 'empty';\n    // }\n    // TODO\n    // filterMode 'weakFilter' and 'empty' is not optimized for huge data yet.\n\n\n    each(seriesModels, function (seriesModel) {\n      var seriesData = seriesModel.getData();\n      var dataDims = seriesData.mapDimension(axisDim, true);\n\n      if (!dataDims.length) {\n        return;\n      }\n\n      if (filterMode === 'weakFilter') {\n        seriesData.filterSelf(function (dataIndex) {\n          var leftOut;\n          var rightOut;\n          var hasValue;\n\n          for (var i = 0; i < dataDims.length; i++) {\n            var value = seriesData.get(dataDims[i], dataIndex);\n            var thisHasValue = !isNaN(value);\n            var thisLeftOut = value < valueWindow[0];\n            var thisRightOut = value > valueWindow[1];\n\n            if (thisHasValue && !thisLeftOut && !thisRightOut) {\n              return true;\n            }\n\n            thisHasValue && (hasValue = true);\n            thisLeftOut && (leftOut = true);\n            thisRightOut && (rightOut = true);\n          } // If both left out and right out, do not filter.\n\n\n          return hasValue && leftOut && rightOut;\n        });\n      } else {\n        each(dataDims, function (dim) {\n          if (filterMode === 'empty') {\n            seriesModel.setData(seriesData.map(dim, function (value) {\n              return !isInWindow(value) ? NaN : value;\n            }));\n          } else {\n            var range = {};\n            range[dim] = valueWindow; // console.time('select');\n\n            seriesData.selectRange(range); // console.timeEnd('select');\n          }\n        });\n      }\n\n      each(dataDims, function (dim) {\n        seriesData.setApproximateExtent(valueWindow, dim);\n      });\n    });\n\n    function isInWindow(value) {\n      return value >= valueWindow[0] && value <= valueWindow[1];\n    }\n  }\n};\n\nfunction calculateDataExtent(axisProxy, axisDim, seriesModels) {\n  var dataExtent = [Infinity, -Infinity];\n  each(seriesModels, function (seriesModel) {\n    var seriesData = seriesModel.getData();\n\n    if (seriesData) {\n      each(seriesData.mapDimension(axisDim, true), function (dim) {\n        var seriesExtent = seriesData.getApproximateExtent(dim);\n        seriesExtent[0] < dataExtent[0] && (dataExtent[0] = seriesExtent[0]);\n        seriesExtent[1] > dataExtent[1] && (dataExtent[1] = seriesExtent[1]);\n      });\n    }\n  });\n\n  if (dataExtent[1] < dataExtent[0]) {\n    dataExtent = [NaN, NaN];\n  } // It is important to get \"consistent\" extent when more then one axes is\n  // controlled by a `dataZoom`, otherwise those axes will not be synchronized\n  // when zooming. But it is difficult to know what is \"consistent\", considering\n  // axes have different type or even different meanings (For example, two\n  // time axes are used to compare data of the same date in different years).\n  // So basically dataZoom just obtains extent by series.data (in category axis\n  // extent can be obtained from axis.data).\n  // Nevertheless, user can set min/max/scale on axes to make extent of axes\n  // consistent.\n\n\n  fixExtentByAxis(axisProxy, dataExtent);\n  return dataExtent;\n}\n\nfunction fixExtentByAxis(axisProxy, dataExtent) {\n  var axisModel = axisProxy.getAxisModel();\n  var min = axisModel.getMin(true); // For category axis, if min/max/scale are not set, extent is determined\n  // by axis.data by default.\n\n  var isCategoryAxis = axisModel.get('type') === 'category';\n  var axisDataLen = isCategoryAxis && axisModel.getCategories().length;\n\n  if (min != null && min !== 'dataMin' && typeof min !== 'function') {\n    dataExtent[0] = min;\n  } else if (isCategoryAxis) {\n    dataExtent[0] = axisDataLen > 0 ? 0 : NaN;\n  }\n\n  var max = axisModel.getMax(true);\n\n  if (max != null && max !== 'dataMax' && typeof max !== 'function') {\n    dataExtent[1] = max;\n  } else if (isCategoryAxis) {\n    dataExtent[1] = axisDataLen > 0 ? axisDataLen - 1 : NaN;\n  }\n\n  if (!axisModel.get('scale', true)) {\n    dataExtent[0] > 0 && (dataExtent[0] = 0);\n    dataExtent[1] < 0 && (dataExtent[1] = 0);\n  } // For value axis, if min/max/scale are not set, we just use the extent obtained\n  // by series data, which may be a little different from the extent calculated by\n  // `axisHelper.getScaleExtent`. But the different just affects the experience a\n  // little when zooming. So it will not be fixed until some users require it strongly.\n\n\n  return dataExtent;\n}\n\nfunction setAxisModel(axisProxy, isRestore) {\n  var axisModel = axisProxy.getAxisModel();\n  var percentWindow = axisProxy._percentWindow;\n  var valueWindow = axisProxy._valueWindow;\n\n  if (!percentWindow) {\n    return;\n  } // [0, 500]: arbitrary value, guess axis extent.\n\n\n  var precision = numberUtil.getPixelPrecision(valueWindow, [0, 500]);\n  precision = Math.min(precision, 20); // isRestore or isFull\n\n  var useOrigin = isRestore || percentWindow[0] === 0 && percentWindow[1] === 100;\n  axisModel.setRange(useOrigin ? null : +valueWindow[0].toFixed(precision), useOrigin ? null : +valueWindow[1].toFixed(precision));\n}\n\nfunction setMinMaxSpan(axisProxy) {\n  var minMaxSpan = axisProxy._minMaxSpan = {};\n  var dataZoomModel = axisProxy._dataZoomModel;\n  each(['min', 'max'], function (minMax) {\n    minMaxSpan[minMax + 'Span'] = dataZoomModel.get(minMax + 'Span'); // minValueSpan and maxValueSpan has higher priority than minSpan and maxSpan\n\n    var valueSpan = dataZoomModel.get(minMax + 'ValueSpan');\n\n    if (valueSpan != null) {\n      minMaxSpan[minMax + 'ValueSpan'] = valueSpan;\n      valueSpan = axisProxy.getAxisModel().axis.scale.parse(valueSpan);\n\n      if (valueSpan != null) {\n        var dataExtent = axisProxy._dataExtent;\n        minMaxSpan[minMax + 'Span'] = numberUtil.linearMap(dataExtent[0] + valueSpan, dataExtent, [0, 100], true);\n      }\n    }\n  });\n}\n\nvar _default = AxisProxy;\nmodule.exports = _default;","map":{"version":3,"sources":["/Users/eduardjacobs/Desktop/files/inHouse-website/client/node_modules/echarts/lib/component/dataZoom/AxisProxy.js"],"names":["zrUtil","require","numberUtil","helper","each","asc","AxisProxy","dimName","axisIndex","dataZoomModel","ecModel","_dimName","_axisIndex","_valueWindow","_percentWindow","_dataExtent","_minMaxSpan","_dataZoomModel","prototype","constructor","hostedBy","getDataValueWindow","slice","getDataPercentWindow","getTargetSeriesModels","seriesModels","eachSeries","seriesModel","isCoordSupported","get","axisModel","queryComponents","mainType","index","id","componentIndex","push","getAxisModel","getComponent","getOtherAxisModel","axisDim","isCartesian","otherAxisDim","coordSysIndexName","foundOtherAxisModel","eachComponent","otherAxisModel","getMinMaxSpan","clone","calculateDataWindow","opt","dataExtent","scale","axis","rangePropMode","getRangePropMode","percentExtent","percentWindow","start","end","valueWindow","prop","parse","idx","boundValue","boundPercent","linearMap","reset","targetSeries","calculateDataExtent","dataWindow","option","setMinMaxSpan","setAxisModel","restore","filterData","api","filterMode","seriesData","getData","dataDims","mapDimension","length","filterSelf","dataIndex","leftOut","rightOut","hasValue","i","value","thisHasValue","isNaN","thisLeftOut","thisRightOut","dim","setData","map","isInWindow","NaN","range","selectRange","setApproximateExtent","axisProxy","Infinity","seriesExtent","getApproximateExtent","fixExtentByAxis","min","getMin","isCategoryAxis","axisDataLen","getCategories","max","getMax","isRestore","precision","getPixelPrecision","Math","useOrigin","setRange","toFixed","minMaxSpan","minMax","valueSpan","_default","module","exports"],"mappings":"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","sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar numberUtil = require(\"../../util/number\");\n\nvar helper = require(\"./helper\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar each = zrUtil.each;\nvar asc = numberUtil.asc;\n/**\n * Operate single axis.\n * One axis can only operated by one axis operator.\n * Different dataZoomModels may be defined to operate the same axis.\n * (i.e. 'inside' data zoom and 'slider' data zoom components)\n * So dataZoomModels share one axisProxy in that case.\n *\n * @class\n */\n\nvar AxisProxy = function (dimName, axisIndex, dataZoomModel, ecModel) {\n  /**\n   * @private\n   * @type {string}\n   */\n  this._dimName = dimName;\n  /**\n   * @private\n   */\n\n  this._axisIndex = axisIndex;\n  /**\n   * @private\n   * @type {Array.<number>}\n   */\n\n  this._valueWindow;\n  /**\n   * @private\n   * @type {Array.<number>}\n   */\n\n  this._percentWindow;\n  /**\n   * @private\n   * @type {Array.<number>}\n   */\n\n  this._dataExtent;\n  /**\n   * {minSpan, maxSpan, minValueSpan, maxValueSpan}\n   * @private\n   * @type {Object}\n   */\n\n  this._minMaxSpan;\n  /**\n   * @readOnly\n   * @type {module: echarts/model/Global}\n   */\n\n  this.ecModel = ecModel;\n  /**\n   * @private\n   * @type {module: echarts/component/dataZoom/DataZoomModel}\n   */\n\n  this._dataZoomModel = dataZoomModel; // /**\n  //  * @readOnly\n  //  * @private\n  //  */\n  // this.hasSeriesStacked;\n};\n\nAxisProxy.prototype = {\n  constructor: AxisProxy,\n\n  /**\n   * Whether the axisProxy is hosted by dataZoomModel.\n   *\n   * @public\n   * @param {module: echarts/component/dataZoom/DataZoomModel} dataZoomModel\n   * @return {boolean}\n   */\n  hostedBy: function (dataZoomModel) {\n    return this._dataZoomModel === dataZoomModel;\n  },\n\n  /**\n   * @return {Array.<number>} Value can only be NaN or finite value.\n   */\n  getDataValueWindow: function () {\n    return this._valueWindow.slice();\n  },\n\n  /**\n   * @return {Array.<number>}\n   */\n  getDataPercentWindow: function () {\n    return this._percentWindow.slice();\n  },\n\n  /**\n   * @public\n   * @param {number} axisIndex\n   * @return {Array} seriesModels\n   */\n  getTargetSeriesModels: function () {\n    var seriesModels = [];\n    var ecModel = this.ecModel;\n    ecModel.eachSeries(function (seriesModel) {\n      if (helper.isCoordSupported(seriesModel.get('coordinateSystem'))) {\n        var dimName = this._dimName;\n        var axisModel = ecModel.queryComponents({\n          mainType: dimName + 'Axis',\n          index: seriesModel.get(dimName + 'AxisIndex'),\n          id: seriesModel.get(dimName + 'AxisId')\n        })[0];\n\n        if (this._axisIndex === (axisModel && axisModel.componentIndex)) {\n          seriesModels.push(seriesModel);\n        }\n      }\n    }, this);\n    return seriesModels;\n  },\n  getAxisModel: function () {\n    return this.ecModel.getComponent(this._dimName + 'Axis', this._axisIndex);\n  },\n  getOtherAxisModel: function () {\n    var axisDim = this._dimName;\n    var ecModel = this.ecModel;\n    var axisModel = this.getAxisModel();\n    var isCartesian = axisDim === 'x' || axisDim === 'y';\n    var otherAxisDim;\n    var coordSysIndexName;\n\n    if (isCartesian) {\n      coordSysIndexName = 'gridIndex';\n      otherAxisDim = axisDim === 'x' ? 'y' : 'x';\n    } else {\n      coordSysIndexName = 'polarIndex';\n      otherAxisDim = axisDim === 'angle' ? 'radius' : 'angle';\n    }\n\n    var foundOtherAxisModel;\n    ecModel.eachComponent(otherAxisDim + 'Axis', function (otherAxisModel) {\n      if ((otherAxisModel.get(coordSysIndexName) || 0) === (axisModel.get(coordSysIndexName) || 0)) {\n        foundOtherAxisModel = otherAxisModel;\n      }\n    });\n    return foundOtherAxisModel;\n  },\n  getMinMaxSpan: function () {\n    return zrUtil.clone(this._minMaxSpan);\n  },\n\n  /**\n   * Only calculate by given range and this._dataExtent, do not change anything.\n   *\n   * @param {Object} opt\n   * @param {number} [opt.start]\n   * @param {number} [opt.end]\n   * @param {number} [opt.startValue]\n   * @param {number} [opt.endValue]\n   */\n  calculateDataWindow: function (opt) {\n    var dataExtent = this._dataExtent;\n    var axisModel = this.getAxisModel();\n    var scale = axisModel.axis.scale;\n\n    var rangePropMode = this._dataZoomModel.getRangePropMode();\n\n    var percentExtent = [0, 100];\n    var percentWindow = [opt.start, opt.end];\n    var valueWindow = [];\n    each(['startValue', 'endValue'], function (prop) {\n      valueWindow.push(opt[prop] != null ? scale.parse(opt[prop]) : null);\n    }); // Normalize bound.\n\n    each([0, 1], function (idx) {\n      var boundValue = valueWindow[idx];\n      var boundPercent = percentWindow[idx]; // Notice: dataZoom is based either on `percentProp` ('start', 'end') or\n      // on `valueProp` ('startValue', 'endValue'). The former one is suitable\n      // for cases that a dataZoom component controls multiple axes with different\n      // unit or extent, and the latter one is suitable for accurate zoom by pixel\n      // (e.g., in dataZoomSelect). `valueProp` can be calculated from `percentProp`,\n      // but it is awkward that `percentProp` can not be obtained from `valueProp`\n      // accurately (because all of values that are overflow the `dataExtent` will\n      // be calculated to percent '100%'). So we have to use\n      // `dataZoom.getRangePropMode()` to mark which prop is used.\n      // `rangePropMode` is updated only when setOption or dispatchAction, otherwise\n      // it remains its original value.\n\n      if (rangePropMode[idx] === 'percent') {\n        if (boundPercent == null) {\n          boundPercent = percentExtent[idx];\n        } // Use scale.parse to math round for category or time axis.\n\n\n        boundValue = scale.parse(numberUtil.linearMap(boundPercent, percentExtent, dataExtent, true));\n      } else {\n        // Calculating `percent` from `value` may be not accurate, because\n        // This calculation can not be inversed, because all of values that\n        // are overflow the `dataExtent` will be calculated to percent '100%'\n        boundPercent = numberUtil.linearMap(boundValue, dataExtent, percentExtent, true);\n      } // valueWindow[idx] = round(boundValue);\n      // percentWindow[idx] = round(boundPercent);\n\n\n      valueWindow[idx] = boundValue;\n      percentWindow[idx] = boundPercent;\n    });\n    return {\n      valueWindow: asc(valueWindow),\n      percentWindow: asc(percentWindow)\n    };\n  },\n\n  /**\n   * Notice: reset should not be called before series.restoreData() called,\n   * so it is recommanded to be called in \"process stage\" but not \"model init\n   * stage\".\n   *\n   * @param {module: echarts/component/dataZoom/DataZoomModel} dataZoomModel\n   */\n  reset: function (dataZoomModel) {\n    if (dataZoomModel !== this._dataZoomModel) {\n      return;\n    }\n\n    var targetSeries = this.getTargetSeriesModels(); // Culculate data window and data extent, and record them.\n\n    this._dataExtent = calculateDataExtent(this, this._dimName, targetSeries); // this.hasSeriesStacked = false;\n    // each(targetSeries, function (series) {\n    // var data = series.getData();\n    // var dataDim = data.mapDimension(this._dimName);\n    // var stackedDimension = data.getCalculationInfo('stackedDimension');\n    // if (stackedDimension && stackedDimension === dataDim) {\n    // this.hasSeriesStacked = true;\n    // }\n    // }, this);\n\n    var dataWindow = this.calculateDataWindow(dataZoomModel.option);\n    this._valueWindow = dataWindow.valueWindow;\n    this._percentWindow = dataWindow.percentWindow;\n    setMinMaxSpan(this); // Update axis setting then.\n\n    setAxisModel(this);\n  },\n\n  /**\n   * @param {module: echarts/component/dataZoom/DataZoomModel} dataZoomModel\n   */\n  restore: function (dataZoomModel) {\n    if (dataZoomModel !== this._dataZoomModel) {\n      return;\n    }\n\n    this._valueWindow = this._percentWindow = null;\n    setAxisModel(this, true);\n  },\n\n  /**\n   * @param {module: echarts/component/dataZoom/DataZoomModel} dataZoomModel\n   */\n  filterData: function (dataZoomModel, api) {\n    if (dataZoomModel !== this._dataZoomModel) {\n      return;\n    }\n\n    var axisDim = this._dimName;\n    var seriesModels = this.getTargetSeriesModels();\n    var filterMode = dataZoomModel.get('filterMode');\n    var valueWindow = this._valueWindow;\n\n    if (filterMode === 'none') {\n      return;\n    } // FIXME\n    // Toolbox may has dataZoom injected. And if there are stacked bar chart\n    // with NaN data, NaN will be filtered and stack will be wrong.\n    // So we need to force the mode to be set empty.\n    // In fect, it is not a big deal that do not support filterMode-'filter'\n    // when using toolbox#dataZoom, utill tooltip#dataZoom support \"single axis\n    // selection\" some day, which might need \"adapt to data extent on the\n    // otherAxis\", which is disabled by filterMode-'empty'.\n    // But currently, stack has been fixed to based on value but not index,\n    // so this is not an issue any more.\n    // var otherAxisModel = this.getOtherAxisModel();\n    // if (dataZoomModel.get('$fromToolbox')\n    //     && otherAxisModel\n    //     && otherAxisModel.hasSeriesStacked\n    // ) {\n    //     filterMode = 'empty';\n    // }\n    // TODO\n    // filterMode 'weakFilter' and 'empty' is not optimized for huge data yet.\n\n\n    each(seriesModels, function (seriesModel) {\n      var seriesData = seriesModel.getData();\n      var dataDims = seriesData.mapDimension(axisDim, true);\n\n      if (!dataDims.length) {\n        return;\n      }\n\n      if (filterMode === 'weakFilter') {\n        seriesData.filterSelf(function (dataIndex) {\n          var leftOut;\n          var rightOut;\n          var hasValue;\n\n          for (var i = 0; i < dataDims.length; i++) {\n            var value = seriesData.get(dataDims[i], dataIndex);\n            var thisHasValue = !isNaN(value);\n            var thisLeftOut = value < valueWindow[0];\n            var thisRightOut = value > valueWindow[1];\n\n            if (thisHasValue && !thisLeftOut && !thisRightOut) {\n              return true;\n            }\n\n            thisHasValue && (hasValue = true);\n            thisLeftOut && (leftOut = true);\n            thisRightOut && (rightOut = true);\n          } // If both left out and right out, do not filter.\n\n\n          return hasValue && leftOut && rightOut;\n        });\n      } else {\n        each(dataDims, function (dim) {\n          if (filterMode === 'empty') {\n            seriesModel.setData(seriesData.map(dim, function (value) {\n              return !isInWindow(value) ? NaN : value;\n            }));\n          } else {\n            var range = {};\n            range[dim] = valueWindow; // console.time('select');\n\n            seriesData.selectRange(range); // console.timeEnd('select');\n          }\n        });\n      }\n\n      each(dataDims, function (dim) {\n        seriesData.setApproximateExtent(valueWindow, dim);\n      });\n    });\n\n    function isInWindow(value) {\n      return value >= valueWindow[0] && value <= valueWindow[1];\n    }\n  }\n};\n\nfunction calculateDataExtent(axisProxy, axisDim, seriesModels) {\n  var dataExtent = [Infinity, -Infinity];\n  each(seriesModels, function (seriesModel) {\n    var seriesData = seriesModel.getData();\n\n    if (seriesData) {\n      each(seriesData.mapDimension(axisDim, true), function (dim) {\n        var seriesExtent = seriesData.getApproximateExtent(dim);\n        seriesExtent[0] < dataExtent[0] && (dataExtent[0] = seriesExtent[0]);\n        seriesExtent[1] > dataExtent[1] && (dataExtent[1] = seriesExtent[1]);\n      });\n    }\n  });\n\n  if (dataExtent[1] < dataExtent[0]) {\n    dataExtent = [NaN, NaN];\n  } // It is important to get \"consistent\" extent when more then one axes is\n  // controlled by a `dataZoom`, otherwise those axes will not be synchronized\n  // when zooming. But it is difficult to know what is \"consistent\", considering\n  // axes have different type or even different meanings (For example, two\n  // time axes are used to compare data of the same date in different years).\n  // So basically dataZoom just obtains extent by series.data (in category axis\n  // extent can be obtained from axis.data).\n  // Nevertheless, user can set min/max/scale on axes to make extent of axes\n  // consistent.\n\n\n  fixExtentByAxis(axisProxy, dataExtent);\n  return dataExtent;\n}\n\nfunction fixExtentByAxis(axisProxy, dataExtent) {\n  var axisModel = axisProxy.getAxisModel();\n  var min = axisModel.getMin(true); // For category axis, if min/max/scale are not set, extent is determined\n  // by axis.data by default.\n\n  var isCategoryAxis = axisModel.get('type') === 'category';\n  var axisDataLen = isCategoryAxis && axisModel.getCategories().length;\n\n  if (min != null && min !== 'dataMin' && typeof min !== 'function') {\n    dataExtent[0] = min;\n  } else if (isCategoryAxis) {\n    dataExtent[0] = axisDataLen > 0 ? 0 : NaN;\n  }\n\n  var max = axisModel.getMax(true);\n\n  if (max != null && max !== 'dataMax' && typeof max !== 'function') {\n    dataExtent[1] = max;\n  } else if (isCategoryAxis) {\n    dataExtent[1] = axisDataLen > 0 ? axisDataLen - 1 : NaN;\n  }\n\n  if (!axisModel.get('scale', true)) {\n    dataExtent[0] > 0 && (dataExtent[0] = 0);\n    dataExtent[1] < 0 && (dataExtent[1] = 0);\n  } // For value axis, if min/max/scale are not set, we just use the extent obtained\n  // by series data, which may be a little different from the extent calculated by\n  // `axisHelper.getScaleExtent`. But the different just affects the experience a\n  // little when zooming. So it will not be fixed until some users require it strongly.\n\n\n  return dataExtent;\n}\n\nfunction setAxisModel(axisProxy, isRestore) {\n  var axisModel = axisProxy.getAxisModel();\n  var percentWindow = axisProxy._percentWindow;\n  var valueWindow = axisProxy._valueWindow;\n\n  if (!percentWindow) {\n    return;\n  } // [0, 500]: arbitrary value, guess axis extent.\n\n\n  var precision = numberUtil.getPixelPrecision(valueWindow, [0, 500]);\n  precision = Math.min(precision, 20); // isRestore or isFull\n\n  var useOrigin = isRestore || percentWindow[0] === 0 && percentWindow[1] === 100;\n  axisModel.setRange(useOrigin ? null : +valueWindow[0].toFixed(precision), useOrigin ? null : +valueWindow[1].toFixed(precision));\n}\n\nfunction setMinMaxSpan(axisProxy) {\n  var minMaxSpan = axisProxy._minMaxSpan = {};\n  var dataZoomModel = axisProxy._dataZoomModel;\n  each(['min', 'max'], function (minMax) {\n    minMaxSpan[minMax + 'Span'] = dataZoomModel.get(minMax + 'Span'); // minValueSpan and maxValueSpan has higher priority than minSpan and maxSpan\n\n    var valueSpan = dataZoomModel.get(minMax + 'ValueSpan');\n\n    if (valueSpan != null) {\n      minMaxSpan[minMax + 'ValueSpan'] = valueSpan;\n      valueSpan = axisProxy.getAxisModel().axis.scale.parse(valueSpan);\n\n      if (valueSpan != null) {\n        var dataExtent = axisProxy._dataExtent;\n        minMaxSpan[minMax + 'Span'] = numberUtil.linearMap(dataExtent[0] + valueSpan, dataExtent, [0, 100], true);\n      }\n    }\n  });\n}\n\nvar _default = AxisProxy;\nmodule.exports = _default;"]},"metadata":{},"sourceType":"script"}