{"ast":null,"code":"/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar graphic = require(\"../../util/graphic\");\n\nvar layoutUtil = require(\"../../util/layout\");\n\nvar LegendView = require(\"./LegendView\");\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * Separate legend and scrollable legend to reduce package size.\n */\n\n\nvar Group = graphic.Group;\nvar WH = ['width', 'height'];\nvar XY = ['x', 'y'];\nvar ScrollableLegendView = LegendView.extend({\n  type: 'legend.scroll',\n  newlineDisabled: true,\n  init: function init() {\n    ScrollableLegendView.superCall(this, 'init');\n    /**\n     * @private\n     * @type {number} For `scroll`.\n     */\n\n    this._currentIndex = 0;\n    /**\n     * @private\n     * @type {module:zrender/container/Group}\n     */\n\n    this.group.add(this._containerGroup = new Group());\n\n    this._containerGroup.add(this.getContentGroup());\n    /**\n     * @private\n     * @type {module:zrender/container/Group}\n     */\n\n\n    this.group.add(this._controllerGroup = new Group());\n    /**\n     *\n     * @private\n     */\n\n    this._showController;\n  },\n\n  /**\n   * @override\n   */\n  resetInner: function resetInner() {\n    ScrollableLegendView.superCall(this, 'resetInner');\n\n    this._controllerGroup.removeAll();\n\n    this._containerGroup.removeClipPath();\n\n    this._containerGroup.__rectSize = null;\n  },\n\n  /**\n   * @override\n   */\n  renderInner: function renderInner(itemAlign, legendModel, ecModel, api) {\n    var me = this; // Render content items.\n\n    ScrollableLegendView.superCall(this, 'renderInner', itemAlign, legendModel, ecModel, api);\n    var controllerGroup = this._controllerGroup; // FIXME: support be 'auto' adapt to size number text length,\n    // e.g., '3/12345' should not overlap with the control arrow button.\n\n    var pageIconSize = legendModel.get('pageIconSize', true);\n\n    if (!zrUtil.isArray(pageIconSize)) {\n      pageIconSize = [pageIconSize, pageIconSize];\n    }\n\n    createPageButton('pagePrev', 0);\n    var pageTextStyleModel = legendModel.getModel('pageTextStyle');\n    controllerGroup.add(new graphic.Text({\n      name: 'pageText',\n      style: {\n        textFill: pageTextStyleModel.getTextColor(),\n        font: pageTextStyleModel.getFont(),\n        textVerticalAlign: 'middle',\n        textAlign: 'center'\n      },\n      silent: true\n    }));\n    createPageButton('pageNext', 1);\n\n    function createPageButton(name, iconIdx) {\n      var pageDataIndexName = name + 'DataIndex';\n      var icon = graphic.createIcon(legendModel.get('pageIcons', true)[legendModel.getOrient().name][iconIdx], {\n        // Buttons will be created in each render, so we do not need\n        // to worry about avoiding using legendModel kept in scope.\n        onclick: zrUtil.bind(me._pageGo, me, pageDataIndexName, legendModel, api)\n      }, {\n        x: -pageIconSize[0] / 2,\n        y: -pageIconSize[1] / 2,\n        width: pageIconSize[0],\n        height: pageIconSize[1]\n      });\n      icon.name = name;\n      controllerGroup.add(icon);\n    }\n  },\n\n  /**\n   * @override\n   */\n  layoutInner: function layoutInner(legendModel, itemAlign, maxSize, isFirstRender) {\n    var contentGroup = this.getContentGroup();\n    var containerGroup = this._containerGroup;\n    var controllerGroup = this._controllerGroup;\n    var orientIdx = legendModel.getOrient().index;\n    var wh = WH[orientIdx];\n    var hw = WH[1 - orientIdx];\n    var yx = XY[1 - orientIdx]; // Place items in contentGroup.\n\n    layoutUtil.box(legendModel.get('orient'), contentGroup, legendModel.get('itemGap'), !orientIdx ? null : maxSize.width, orientIdx ? null : maxSize.height);\n    layoutUtil.box( // Buttons in controller are layout always horizontally.\n    'horizontal', controllerGroup, legendModel.get('pageButtonItemGap', true));\n    var contentRect = contentGroup.getBoundingRect();\n    var controllerRect = controllerGroup.getBoundingRect();\n    var showController = this._showController = contentRect[wh] > maxSize[wh];\n    var contentPos = [-contentRect.x, -contentRect.y]; // Remain contentPos when scroll animation perfroming.\n    // If first rendering, `contentGroup.position` is [0, 0], which\n    // does not make sense and may cause unexepcted animation if adopted.\n\n    if (!isFirstRender) {\n      contentPos[orientIdx] = contentGroup.position[orientIdx];\n    } // Layout container group based on 0.\n\n\n    var containerPos = [0, 0];\n    var controllerPos = [-controllerRect.x, -controllerRect.y];\n    var pageButtonGap = zrUtil.retrieve2(legendModel.get('pageButtonGap', true), legendModel.get('itemGap', true)); // Place containerGroup and controllerGroup and contentGroup.\n\n    if (showController) {\n      var pageButtonPosition = legendModel.get('pageButtonPosition', true); // controller is on the right / bottom.\n\n      if (pageButtonPosition === 'end') {\n        controllerPos[orientIdx] += maxSize[wh] - controllerRect[wh];\n      } // controller is on the left / top.\n      else {\n          containerPos[orientIdx] += controllerRect[wh] + pageButtonGap;\n        }\n    } // Always align controller to content as 'middle'.\n\n\n    controllerPos[1 - orientIdx] += contentRect[hw] / 2 - controllerRect[hw] / 2;\n    contentGroup.attr('position', contentPos);\n    containerGroup.attr('position', containerPos);\n    controllerGroup.attr('position', controllerPos); // Calculate `mainRect` and set `clipPath`.\n    // mainRect should not be calculated by `this.group.getBoundingRect()`\n    // for sake of the overflow.\n\n    var mainRect = this.group.getBoundingRect();\n    var mainRect = {\n      x: 0,\n      y: 0\n    }; // Consider content may be overflow (should be clipped).\n\n    mainRect[wh] = showController ? maxSize[wh] : contentRect[wh];\n    mainRect[hw] = Math.max(contentRect[hw], controllerRect[hw]); // `containerRect[yx] + containerPos[1 - orientIdx]` is 0.\n\n    mainRect[yx] = Math.min(0, controllerRect[yx] + controllerPos[1 - orientIdx]);\n    containerGroup.__rectSize = maxSize[wh];\n\n    if (showController) {\n      var clipShape = {\n        x: 0,\n        y: 0\n      };\n      clipShape[wh] = Math.max(maxSize[wh] - controllerRect[wh] - pageButtonGap, 0);\n      clipShape[hw] = mainRect[hw];\n      containerGroup.setClipPath(new graphic.Rect({\n        shape: clipShape\n      })); // Consider content may be larger than container, container rect\n      // can not be obtained from `containerGroup.getBoundingRect()`.\n\n      containerGroup.__rectSize = clipShape[wh];\n    } else {\n      // Do not remove or ignore controller. Keep them set as place holders.\n      controllerGroup.eachChild(function (child) {\n        child.attr({\n          invisible: true,\n          silent: true\n        });\n      });\n    } // Content translate animation.\n\n\n    var pageInfo = this._getPageInfo(legendModel);\n\n    pageInfo.pageIndex != null && graphic.updateProps(contentGroup, {\n      position: pageInfo.contentPosition\n    }, // When switch from \"show controller\" to \"not show controller\", view should be\n    // updated immediately without animation, otherwise causes weird efffect.\n    showController ? legendModel : false);\n\n    this._updatePageInfoView(legendModel, pageInfo);\n\n    return mainRect;\n  },\n  _pageGo: function _pageGo(to, legendModel, api) {\n    var scrollDataIndex = this._getPageInfo(legendModel)[to];\n\n    scrollDataIndex != null && api.dispatchAction({\n      type: 'legendScroll',\n      scrollDataIndex: scrollDataIndex,\n      legendId: legendModel.id\n    });\n  },\n  _updatePageInfoView: function _updatePageInfoView(legendModel, pageInfo) {\n    var controllerGroup = this._controllerGroup;\n    zrUtil.each(['pagePrev', 'pageNext'], function (name) {\n      var canJump = pageInfo[name + 'DataIndex'] != null;\n      var icon = controllerGroup.childOfName(name);\n\n      if (icon) {\n        icon.setStyle('fill', canJump ? legendModel.get('pageIconColor', true) : legendModel.get('pageIconInactiveColor', true));\n        icon.cursor = canJump ? 'pointer' : 'default';\n      }\n    });\n    var pageText = controllerGroup.childOfName('pageText');\n    var pageFormatter = legendModel.get('pageFormatter');\n    var pageIndex = pageInfo.pageIndex;\n    var current = pageIndex != null ? pageIndex + 1 : 0;\n    var total = pageInfo.pageCount;\n    pageText && pageFormatter && pageText.setStyle('text', zrUtil.isString(pageFormatter) ? pageFormatter.replace('{current}', current).replace('{total}', total) : pageFormatter({\n      current: current,\n      total: total\n    }));\n  },\n\n  /**\n   * @param {module:echarts/model/Model} legendModel\n   * @return {Object} {\n   *  contentPosition: Array.<number>, null when data item not found.\n   *  pageIndex: number, null when data item not found.\n   *  pageCount: number, always be a number, can be 0.\n   *  pagePrevDataIndex: number, null when no next page.\n   *  pageNextDataIndex: number, null when no previous page.\n   * }\n   */\n  _getPageInfo: function _getPageInfo(legendModel) {\n    var scrollDataIndex = legendModel.get('scrollDataIndex', true);\n    var contentGroup = this.getContentGroup();\n    var containerRectSize = this._containerGroup.__rectSize;\n    var orientIdx = legendModel.getOrient().index;\n    var wh = WH[orientIdx];\n    var xy = XY[orientIdx];\n\n    var targetItemIndex = this._findTargetItemIndex(scrollDataIndex);\n\n    var children = contentGroup.children();\n    var targetItem = children[targetItemIndex];\n    var itemCount = children.length;\n    var pCount = !itemCount ? 0 : 1;\n    var result = {\n      contentPosition: contentGroup.position.slice(),\n      pageCount: pCount,\n      pageIndex: pCount - 1,\n      pagePrevDataIndex: null,\n      pageNextDataIndex: null\n    };\n\n    if (!targetItem) {\n      return result;\n    }\n\n    var targetItemInfo = getItemInfo(targetItem);\n    result.contentPosition[orientIdx] = -targetItemInfo.s; // Strategy:\n    // (1) Always align based on the left/top most item.\n    // (2) It is user-friendly that the last item shown in the\n    // current window is shown at the begining of next window.\n    // Otherwise if half of the last item is cut by the window,\n    // it will have no chance to display entirely.\n    // (3) Consider that item size probably be different, we\n    // have calculate pageIndex by size rather than item index,\n    // and we can not get page index directly by division.\n    // (4) The window is to narrow to contain more than\n    // one item, we should make sure that the page can be fliped.\n\n    for (var i = targetItemIndex + 1, winStartItemInfo = targetItemInfo, winEndItemInfo = targetItemInfo, currItemInfo = null; i <= itemCount; ++i) {\n      currItemInfo = getItemInfo(children[i]);\n\n      if ( // Half of the last item is out of the window.\n      !currItemInfo && winEndItemInfo.e > winStartItemInfo.s + containerRectSize || // If the current item does not intersect with the window, the new page\n      // can be started at the current item or the last item.\n      currItemInfo && !intersect(currItemInfo, winStartItemInfo.s)) {\n        if (winEndItemInfo.i > winStartItemInfo.i) {\n          winStartItemInfo = winEndItemInfo;\n        } else {\n          // e.g., when page size is smaller than item size.\n          winStartItemInfo = currItemInfo;\n        }\n\n        if (winStartItemInfo) {\n          if (result.pageNextDataIndex == null) {\n            result.pageNextDataIndex = winStartItemInfo.i;\n          }\n\n          ++result.pageCount;\n        }\n      }\n\n      winEndItemInfo = currItemInfo;\n    }\n\n    for (var i = targetItemIndex - 1, winStartItemInfo = targetItemInfo, winEndItemInfo = targetItemInfo, currItemInfo = null; i >= -1; --i) {\n      currItemInfo = getItemInfo(children[i]);\n\n      if ( // If the the end item does not intersect with the window started\n      // from the current item, a page can be settled.\n      (!currItemInfo || !intersect(winEndItemInfo, currItemInfo.s)) && // e.g., when page size is smaller than item size.\n      winStartItemInfo.i < winEndItemInfo.i) {\n        winEndItemInfo = winStartItemInfo;\n\n        if (result.pagePrevDataIndex == null) {\n          result.pagePrevDataIndex = winStartItemInfo.i;\n        }\n\n        ++result.pageCount;\n        ++result.pageIndex;\n      }\n\n      winStartItemInfo = currItemInfo;\n    }\n\n    return result;\n\n    function getItemInfo(el) {\n      if (el) {\n        var itemRect = el.getBoundingRect();\n        var start = itemRect[xy] + el.position[orientIdx];\n        return {\n          s: start,\n          e: start + itemRect[wh],\n          i: el.__legendDataIndex\n        };\n      }\n    }\n\n    function intersect(itemInfo, winStart) {\n      return itemInfo.e >= winStart && itemInfo.s <= winStart + containerRectSize;\n    }\n  },\n  _findTargetItemIndex: function _findTargetItemIndex(targetDataIndex) {\n    var index;\n    var contentGroup = this.getContentGroup();\n\n    if (this._showController) {\n      contentGroup.eachChild(function (child, idx) {\n        if (child.__legendDataIndex === targetDataIndex) {\n          index = idx;\n        }\n      });\n    } else {\n      index = 0;\n    }\n\n    return index;\n  }\n});\nvar _default = ScrollableLegendView;\nmodule.exports = _default;","map":{"version":3,"sources":["/Users/eduardjacobs/Desktop/files/inHouse-website/client/node_modules/echarts/lib/component/legend/ScrollableLegendView.js"],"names":["zrUtil","require","graphic","layoutUtil","LegendView","Group","WH","XY","ScrollableLegendView","extend","type","newlineDisabled","init","superCall","_currentIndex","group","add","_containerGroup","getContentGroup","_controllerGroup","_showController","resetInner","removeAll","removeClipPath","__rectSize","renderInner","itemAlign","legendModel","ecModel","api","me","controllerGroup","pageIconSize","get","isArray","createPageButton","pageTextStyleModel","getModel","Text","name","style","textFill","getTextColor","font","getFont","textVerticalAlign","textAlign","silent","iconIdx","pageDataIndexName","icon","createIcon","getOrient","onclick","bind","_pageGo","x","y","width","height","layoutInner","maxSize","isFirstRender","contentGroup","containerGroup","orientIdx","index","wh","hw","yx","box","contentRect","getBoundingRect","controllerRect","showController","contentPos","position","containerPos","controllerPos","pageButtonGap","retrieve2","pageButtonPosition","attr","mainRect","Math","max","min","clipShape","setClipPath","Rect","shape","eachChild","child","invisible","pageInfo","_getPageInfo","pageIndex","updateProps","contentPosition","_updatePageInfoView","to","scrollDataIndex","dispatchAction","legendId","id","each","canJump","childOfName","setStyle","cursor","pageText","pageFormatter","current","total","pageCount","isString","replace","containerRectSize","xy","targetItemIndex","_findTargetItemIndex","children","targetItem","itemCount","length","pCount","result","slice","pagePrevDataIndex","pageNextDataIndex","targetItemInfo","getItemInfo","s","i","winStartItemInfo","winEndItemInfo","currItemInfo","e","intersect","el","itemRect","start","__legendDataIndex","itemInfo","winStart","targetDataIndex","idx","_default","module","exports"],"mappings":"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","sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar graphic = require(\"../../util/graphic\");\n\nvar layoutUtil = require(\"../../util/layout\");\n\nvar LegendView = require(\"./LegendView\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * Separate legend and scrollable legend to reduce package size.\n */\nvar Group = graphic.Group;\nvar WH = ['width', 'height'];\nvar XY = ['x', 'y'];\nvar ScrollableLegendView = LegendView.extend({\n  type: 'legend.scroll',\n  newlineDisabled: true,\n  init: function () {\n    ScrollableLegendView.superCall(this, 'init');\n    /**\n     * @private\n     * @type {number} For `scroll`.\n     */\n\n    this._currentIndex = 0;\n    /**\n     * @private\n     * @type {module:zrender/container/Group}\n     */\n\n    this.group.add(this._containerGroup = new Group());\n\n    this._containerGroup.add(this.getContentGroup());\n    /**\n     * @private\n     * @type {module:zrender/container/Group}\n     */\n\n\n    this.group.add(this._controllerGroup = new Group());\n    /**\n     *\n     * @private\n     */\n\n    this._showController;\n  },\n\n  /**\n   * @override\n   */\n  resetInner: function () {\n    ScrollableLegendView.superCall(this, 'resetInner');\n\n    this._controllerGroup.removeAll();\n\n    this._containerGroup.removeClipPath();\n\n    this._containerGroup.__rectSize = null;\n  },\n\n  /**\n   * @override\n   */\n  renderInner: function (itemAlign, legendModel, ecModel, api) {\n    var me = this; // Render content items.\n\n    ScrollableLegendView.superCall(this, 'renderInner', itemAlign, legendModel, ecModel, api);\n    var controllerGroup = this._controllerGroup; // FIXME: support be 'auto' adapt to size number text length,\n    // e.g., '3/12345' should not overlap with the control arrow button.\n\n    var pageIconSize = legendModel.get('pageIconSize', true);\n\n    if (!zrUtil.isArray(pageIconSize)) {\n      pageIconSize = [pageIconSize, pageIconSize];\n    }\n\n    createPageButton('pagePrev', 0);\n    var pageTextStyleModel = legendModel.getModel('pageTextStyle');\n    controllerGroup.add(new graphic.Text({\n      name: 'pageText',\n      style: {\n        textFill: pageTextStyleModel.getTextColor(),\n        font: pageTextStyleModel.getFont(),\n        textVerticalAlign: 'middle',\n        textAlign: 'center'\n      },\n      silent: true\n    }));\n    createPageButton('pageNext', 1);\n\n    function createPageButton(name, iconIdx) {\n      var pageDataIndexName = name + 'DataIndex';\n      var icon = graphic.createIcon(legendModel.get('pageIcons', true)[legendModel.getOrient().name][iconIdx], {\n        // Buttons will be created in each render, so we do not need\n        // to worry about avoiding using legendModel kept in scope.\n        onclick: zrUtil.bind(me._pageGo, me, pageDataIndexName, legendModel, api)\n      }, {\n        x: -pageIconSize[0] / 2,\n        y: -pageIconSize[1] / 2,\n        width: pageIconSize[0],\n        height: pageIconSize[1]\n      });\n      icon.name = name;\n      controllerGroup.add(icon);\n    }\n  },\n\n  /**\n   * @override\n   */\n  layoutInner: function (legendModel, itemAlign, maxSize, isFirstRender) {\n    var contentGroup = this.getContentGroup();\n    var containerGroup = this._containerGroup;\n    var controllerGroup = this._controllerGroup;\n    var orientIdx = legendModel.getOrient().index;\n    var wh = WH[orientIdx];\n    var hw = WH[1 - orientIdx];\n    var yx = XY[1 - orientIdx]; // Place items in contentGroup.\n\n    layoutUtil.box(legendModel.get('orient'), contentGroup, legendModel.get('itemGap'), !orientIdx ? null : maxSize.width, orientIdx ? null : maxSize.height);\n    layoutUtil.box( // Buttons in controller are layout always horizontally.\n    'horizontal', controllerGroup, legendModel.get('pageButtonItemGap', true));\n    var contentRect = contentGroup.getBoundingRect();\n    var controllerRect = controllerGroup.getBoundingRect();\n    var showController = this._showController = contentRect[wh] > maxSize[wh];\n    var contentPos = [-contentRect.x, -contentRect.y]; // Remain contentPos when scroll animation perfroming.\n    // If first rendering, `contentGroup.position` is [0, 0], which\n    // does not make sense and may cause unexepcted animation if adopted.\n\n    if (!isFirstRender) {\n      contentPos[orientIdx] = contentGroup.position[orientIdx];\n    } // Layout container group based on 0.\n\n\n    var containerPos = [0, 0];\n    var controllerPos = [-controllerRect.x, -controllerRect.y];\n    var pageButtonGap = zrUtil.retrieve2(legendModel.get('pageButtonGap', true), legendModel.get('itemGap', true)); // Place containerGroup and controllerGroup and contentGroup.\n\n    if (showController) {\n      var pageButtonPosition = legendModel.get('pageButtonPosition', true); // controller is on the right / bottom.\n\n      if (pageButtonPosition === 'end') {\n        controllerPos[orientIdx] += maxSize[wh] - controllerRect[wh];\n      } // controller is on the left / top.\n      else {\n          containerPos[orientIdx] += controllerRect[wh] + pageButtonGap;\n        }\n    } // Always align controller to content as 'middle'.\n\n\n    controllerPos[1 - orientIdx] += contentRect[hw] / 2 - controllerRect[hw] / 2;\n    contentGroup.attr('position', contentPos);\n    containerGroup.attr('position', containerPos);\n    controllerGroup.attr('position', controllerPos); // Calculate `mainRect` and set `clipPath`.\n    // mainRect should not be calculated by `this.group.getBoundingRect()`\n    // for sake of the overflow.\n\n    var mainRect = this.group.getBoundingRect();\n    var mainRect = {\n      x: 0,\n      y: 0\n    }; // Consider content may be overflow (should be clipped).\n\n    mainRect[wh] = showController ? maxSize[wh] : contentRect[wh];\n    mainRect[hw] = Math.max(contentRect[hw], controllerRect[hw]); // `containerRect[yx] + containerPos[1 - orientIdx]` is 0.\n\n    mainRect[yx] = Math.min(0, controllerRect[yx] + controllerPos[1 - orientIdx]);\n    containerGroup.__rectSize = maxSize[wh];\n\n    if (showController) {\n      var clipShape = {\n        x: 0,\n        y: 0\n      };\n      clipShape[wh] = Math.max(maxSize[wh] - controllerRect[wh] - pageButtonGap, 0);\n      clipShape[hw] = mainRect[hw];\n      containerGroup.setClipPath(new graphic.Rect({\n        shape: clipShape\n      })); // Consider content may be larger than container, container rect\n      // can not be obtained from `containerGroup.getBoundingRect()`.\n\n      containerGroup.__rectSize = clipShape[wh];\n    } else {\n      // Do not remove or ignore controller. Keep them set as place holders.\n      controllerGroup.eachChild(function (child) {\n        child.attr({\n          invisible: true,\n          silent: true\n        });\n      });\n    } // Content translate animation.\n\n\n    var pageInfo = this._getPageInfo(legendModel);\n\n    pageInfo.pageIndex != null && graphic.updateProps(contentGroup, {\n      position: pageInfo.contentPosition\n    }, // When switch from \"show controller\" to \"not show controller\", view should be\n    // updated immediately without animation, otherwise causes weird efffect.\n    showController ? legendModel : false);\n\n    this._updatePageInfoView(legendModel, pageInfo);\n\n    return mainRect;\n  },\n  _pageGo: function (to, legendModel, api) {\n    var scrollDataIndex = this._getPageInfo(legendModel)[to];\n\n    scrollDataIndex != null && api.dispatchAction({\n      type: 'legendScroll',\n      scrollDataIndex: scrollDataIndex,\n      legendId: legendModel.id\n    });\n  },\n  _updatePageInfoView: function (legendModel, pageInfo) {\n    var controllerGroup = this._controllerGroup;\n    zrUtil.each(['pagePrev', 'pageNext'], function (name) {\n      var canJump = pageInfo[name + 'DataIndex'] != null;\n      var icon = controllerGroup.childOfName(name);\n\n      if (icon) {\n        icon.setStyle('fill', canJump ? legendModel.get('pageIconColor', true) : legendModel.get('pageIconInactiveColor', true));\n        icon.cursor = canJump ? 'pointer' : 'default';\n      }\n    });\n    var pageText = controllerGroup.childOfName('pageText');\n    var pageFormatter = legendModel.get('pageFormatter');\n    var pageIndex = pageInfo.pageIndex;\n    var current = pageIndex != null ? pageIndex + 1 : 0;\n    var total = pageInfo.pageCount;\n    pageText && pageFormatter && pageText.setStyle('text', zrUtil.isString(pageFormatter) ? pageFormatter.replace('{current}', current).replace('{total}', total) : pageFormatter({\n      current: current,\n      total: total\n    }));\n  },\n\n  /**\n   * @param {module:echarts/model/Model} legendModel\n   * @return {Object} {\n   *  contentPosition: Array.<number>, null when data item not found.\n   *  pageIndex: number, null when data item not found.\n   *  pageCount: number, always be a number, can be 0.\n   *  pagePrevDataIndex: number, null when no next page.\n   *  pageNextDataIndex: number, null when no previous page.\n   * }\n   */\n  _getPageInfo: function (legendModel) {\n    var scrollDataIndex = legendModel.get('scrollDataIndex', true);\n    var contentGroup = this.getContentGroup();\n    var containerRectSize = this._containerGroup.__rectSize;\n    var orientIdx = legendModel.getOrient().index;\n    var wh = WH[orientIdx];\n    var xy = XY[orientIdx];\n\n    var targetItemIndex = this._findTargetItemIndex(scrollDataIndex);\n\n    var children = contentGroup.children();\n    var targetItem = children[targetItemIndex];\n    var itemCount = children.length;\n    var pCount = !itemCount ? 0 : 1;\n    var result = {\n      contentPosition: contentGroup.position.slice(),\n      pageCount: pCount,\n      pageIndex: pCount - 1,\n      pagePrevDataIndex: null,\n      pageNextDataIndex: null\n    };\n\n    if (!targetItem) {\n      return result;\n    }\n\n    var targetItemInfo = getItemInfo(targetItem);\n    result.contentPosition[orientIdx] = -targetItemInfo.s; // Strategy:\n    // (1) Always align based on the left/top most item.\n    // (2) It is user-friendly that the last item shown in the\n    // current window is shown at the begining of next window.\n    // Otherwise if half of the last item is cut by the window,\n    // it will have no chance to display entirely.\n    // (3) Consider that item size probably be different, we\n    // have calculate pageIndex by size rather than item index,\n    // and we can not get page index directly by division.\n    // (4) The window is to narrow to contain more than\n    // one item, we should make sure that the page can be fliped.\n\n    for (var i = targetItemIndex + 1, winStartItemInfo = targetItemInfo, winEndItemInfo = targetItemInfo, currItemInfo = null; i <= itemCount; ++i) {\n      currItemInfo = getItemInfo(children[i]);\n\n      if ( // Half of the last item is out of the window.\n      !currItemInfo && winEndItemInfo.e > winStartItemInfo.s + containerRectSize || // If the current item does not intersect with the window, the new page\n      // can be started at the current item or the last item.\n      currItemInfo && !intersect(currItemInfo, winStartItemInfo.s)) {\n        if (winEndItemInfo.i > winStartItemInfo.i) {\n          winStartItemInfo = winEndItemInfo;\n        } else {\n          // e.g., when page size is smaller than item size.\n          winStartItemInfo = currItemInfo;\n        }\n\n        if (winStartItemInfo) {\n          if (result.pageNextDataIndex == null) {\n            result.pageNextDataIndex = winStartItemInfo.i;\n          }\n\n          ++result.pageCount;\n        }\n      }\n\n      winEndItemInfo = currItemInfo;\n    }\n\n    for (var i = targetItemIndex - 1, winStartItemInfo = targetItemInfo, winEndItemInfo = targetItemInfo, currItemInfo = null; i >= -1; --i) {\n      currItemInfo = getItemInfo(children[i]);\n\n      if ( // If the the end item does not intersect with the window started\n      // from the current item, a page can be settled.\n      (!currItemInfo || !intersect(winEndItemInfo, currItemInfo.s)) && // e.g., when page size is smaller than item size.\n      winStartItemInfo.i < winEndItemInfo.i) {\n        winEndItemInfo = winStartItemInfo;\n\n        if (result.pagePrevDataIndex == null) {\n          result.pagePrevDataIndex = winStartItemInfo.i;\n        }\n\n        ++result.pageCount;\n        ++result.pageIndex;\n      }\n\n      winStartItemInfo = currItemInfo;\n    }\n\n    return result;\n\n    function getItemInfo(el) {\n      if (el) {\n        var itemRect = el.getBoundingRect();\n        var start = itemRect[xy] + el.position[orientIdx];\n        return {\n          s: start,\n          e: start + itemRect[wh],\n          i: el.__legendDataIndex\n        };\n      }\n    }\n\n    function intersect(itemInfo, winStart) {\n      return itemInfo.e >= winStart && itemInfo.s <= winStart + containerRectSize;\n    }\n  },\n  _findTargetItemIndex: function (targetDataIndex) {\n    var index;\n    var contentGroup = this.getContentGroup();\n\n    if (this._showController) {\n      contentGroup.eachChild(function (child, idx) {\n        if (child.__legendDataIndex === targetDataIndex) {\n          index = idx;\n        }\n      });\n    } else {\n      index = 0;\n    }\n\n    return index;\n  }\n});\nvar _default = ScrollableLegendView;\nmodule.exports = _default;"]},"metadata":{},"sourceType":"script"}