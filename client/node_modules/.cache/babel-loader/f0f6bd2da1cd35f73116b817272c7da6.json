{"ast":null,"code":"/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar graphic = require(\"../../util/graphic\");\n\nvar AxisBuilder = require(\"./AxisBuilder\");\n\nvar AxisView = require(\"./AxisView\");\n\nvar cartesianAxisHelper = require(\"../../coord/cartesian/cartesianAxisHelper\");\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\nvar axisBuilderAttrs = ['axisLine', 'axisTickLabel', 'axisName'];\nvar selfBuilderAttrs = ['splitArea', 'splitLine']; // function getAlignWithLabel(model, axisModel) {\n//     var alignWithLabel = model.get('alignWithLabel');\n//     if (alignWithLabel === 'auto') {\n//         alignWithLabel = axisModel.get('axisTick.alignWithLabel');\n//     }\n//     return alignWithLabel;\n// }\n\nvar CartesianAxisView = AxisView.extend({\n  type: 'cartesianAxis',\n  axisPointerClass: 'CartesianAxisPointer',\n\n  /**\n   * @override\n   */\n  render: function render(axisModel, ecModel, api, payload) {\n    this.group.removeAll();\n    var oldAxisGroup = this._axisGroup;\n    this._axisGroup = new graphic.Group();\n    this.group.add(this._axisGroup);\n\n    if (!axisModel.get('show')) {\n      return;\n    }\n\n    var gridModel = axisModel.getCoordSysModel();\n    var layout = cartesianAxisHelper.layout(gridModel, axisModel);\n    var axisBuilder = new AxisBuilder(axisModel, layout);\n    zrUtil.each(axisBuilderAttrs, axisBuilder.add, axisBuilder);\n\n    this._axisGroup.add(axisBuilder.getGroup());\n\n    zrUtil.each(selfBuilderAttrs, function (name) {\n      if (axisModel.get(name + '.show')) {\n        this['_' + name](axisModel, gridModel);\n      }\n    }, this);\n    graphic.groupTransition(oldAxisGroup, this._axisGroup, axisModel);\n    CartesianAxisView.superCall(this, 'render', axisModel, ecModel, api, payload);\n  },\n  remove: function remove() {\n    this._splitAreaColors = null;\n  },\n\n  /**\n   * @param {module:echarts/coord/cartesian/AxisModel} axisModel\n   * @param {module:echarts/coord/cartesian/GridModel} gridModel\n   * @private\n   */\n  _splitLine: function _splitLine(axisModel, gridModel) {\n    var axis = axisModel.axis;\n\n    if (axis.scale.isBlank()) {\n      return;\n    }\n\n    var splitLineModel = axisModel.getModel('splitLine');\n    var lineStyleModel = splitLineModel.getModel('lineStyle');\n    var lineColors = lineStyleModel.get('color');\n    lineColors = zrUtil.isArray(lineColors) ? lineColors : [lineColors];\n    var gridRect = gridModel.coordinateSystem.getRect();\n    var isHorizontal = axis.isHorizontal();\n    var lineCount = 0;\n    var ticksCoords = axis.getTicksCoords({\n      tickModel: splitLineModel\n    });\n    var p1 = [];\n    var p2 = []; // Simple optimization\n    // Batching the lines if color are the same\n\n    var lineStyle = lineStyleModel.getLineStyle();\n\n    for (var i = 0; i < ticksCoords.length; i++) {\n      var tickCoord = axis.toGlobalCoord(ticksCoords[i].coord);\n\n      if (isHorizontal) {\n        p1[0] = tickCoord;\n        p1[1] = gridRect.y;\n        p2[0] = tickCoord;\n        p2[1] = gridRect.y + gridRect.height;\n      } else {\n        p1[0] = gridRect.x;\n        p1[1] = tickCoord;\n        p2[0] = gridRect.x + gridRect.width;\n        p2[1] = tickCoord;\n      }\n\n      var colorIndex = lineCount++ % lineColors.length;\n      var tickValue = ticksCoords[i].tickValue;\n\n      this._axisGroup.add(new graphic.Line(graphic.subPixelOptimizeLine({\n        anid: tickValue != null ? 'line_' + ticksCoords[i].tickValue : null,\n        shape: {\n          x1: p1[0],\n          y1: p1[1],\n          x2: p2[0],\n          y2: p2[1]\n        },\n        style: zrUtil.defaults({\n          stroke: lineColors[colorIndex]\n        }, lineStyle),\n        silent: true\n      })));\n    }\n  },\n\n  /**\n   * @param {module:echarts/coord/cartesian/AxisModel} axisModel\n   * @param {module:echarts/coord/cartesian/GridModel} gridModel\n   * @private\n   */\n  _splitArea: function _splitArea(axisModel, gridModel) {\n    var axis = axisModel.axis;\n\n    if (axis.scale.isBlank()) {\n      return;\n    }\n\n    var splitAreaModel = axisModel.getModel('splitArea');\n    var areaStyleModel = splitAreaModel.getModel('areaStyle');\n    var areaColors = areaStyleModel.get('color');\n    var gridRect = gridModel.coordinateSystem.getRect();\n    var ticksCoords = axis.getTicksCoords({\n      tickModel: splitAreaModel,\n      clamp: true\n    });\n\n    if (!ticksCoords.length) {\n      return;\n    } // For Making appropriate splitArea animation, the color and anid\n    // should be corresponding to previous one if possible.\n\n\n    var areaColorsLen = areaColors.length;\n    var lastSplitAreaColors = this._splitAreaColors;\n    var newSplitAreaColors = zrUtil.createHashMap();\n    var colorIndex = 0;\n\n    if (lastSplitAreaColors) {\n      for (var i = 0; i < ticksCoords.length; i++) {\n        var cIndex = lastSplitAreaColors.get(ticksCoords[i].tickValue);\n\n        if (cIndex != null) {\n          colorIndex = (cIndex + (areaColorsLen - 1) * i) % areaColorsLen;\n          break;\n        }\n      }\n    }\n\n    var prev = axis.toGlobalCoord(ticksCoords[0].coord);\n    var areaStyle = areaStyleModel.getAreaStyle();\n    areaColors = zrUtil.isArray(areaColors) ? areaColors : [areaColors];\n\n    for (var i = 1; i < ticksCoords.length; i++) {\n      var tickCoord = axis.toGlobalCoord(ticksCoords[i].coord);\n      var x;\n      var y;\n      var width;\n      var height;\n\n      if (axis.isHorizontal()) {\n        x = prev;\n        y = gridRect.y;\n        width = tickCoord - x;\n        height = gridRect.height;\n        prev = x + width;\n      } else {\n        x = gridRect.x;\n        y = prev;\n        width = gridRect.width;\n        height = tickCoord - y;\n        prev = y + height;\n      }\n\n      var tickValue = ticksCoords[i - 1].tickValue;\n      tickValue != null && newSplitAreaColors.set(tickValue, colorIndex);\n\n      this._axisGroup.add(new graphic.Rect({\n        anid: tickValue != null ? 'area_' + tickValue : null,\n        shape: {\n          x: x,\n          y: y,\n          width: width,\n          height: height\n        },\n        style: zrUtil.defaults({\n          fill: areaColors[colorIndex]\n        }, areaStyle),\n        silent: true\n      }));\n\n      colorIndex = (colorIndex + 1) % areaColorsLen;\n    }\n\n    this._splitAreaColors = newSplitAreaColors;\n  }\n});\nCartesianAxisView.extend({\n  type: 'xAxis'\n});\nCartesianAxisView.extend({\n  type: 'yAxis'\n});","map":{"version":3,"sources":["/Users/eduardjacobs/Desktop/files/inHouse-website/client/node_modules/echarts/lib/component/axis/CartesianAxisView.js"],"names":["zrUtil","require","graphic","AxisBuilder","AxisView","cartesianAxisHelper","axisBuilderAttrs","selfBuilderAttrs","CartesianAxisView","extend","type","axisPointerClass","render","axisModel","ecModel","api","payload","group","removeAll","oldAxisGroup","_axisGroup","Group","add","get","gridModel","getCoordSysModel","layout","axisBuilder","each","getGroup","name","groupTransition","superCall","remove","_splitAreaColors","_splitLine","axis","scale","isBlank","splitLineModel","getModel","lineStyleModel","lineColors","isArray","gridRect","coordinateSystem","getRect","isHorizontal","lineCount","ticksCoords","getTicksCoords","tickModel","p1","p2","lineStyle","getLineStyle","i","length","tickCoord","toGlobalCoord","coord","y","height","x","width","colorIndex","tickValue","Line","subPixelOptimizeLine","anid","shape","x1","y1","x2","y2","style","defaults","stroke","silent","_splitArea","splitAreaModel","areaStyleModel","areaColors","clamp","areaColorsLen","lastSplitAreaColors","newSplitAreaColors","createHashMap","cIndex","prev","areaStyle","getAreaStyle","set","Rect","fill"],"mappings":"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","sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar graphic = require(\"../../util/graphic\");\n\nvar AxisBuilder = require(\"./AxisBuilder\");\n\nvar AxisView = require(\"./AxisView\");\n\nvar cartesianAxisHelper = require(\"../../coord/cartesian/cartesianAxisHelper\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar axisBuilderAttrs = ['axisLine', 'axisTickLabel', 'axisName'];\nvar selfBuilderAttrs = ['splitArea', 'splitLine']; // function getAlignWithLabel(model, axisModel) {\n//     var alignWithLabel = model.get('alignWithLabel');\n//     if (alignWithLabel === 'auto') {\n//         alignWithLabel = axisModel.get('axisTick.alignWithLabel');\n//     }\n//     return alignWithLabel;\n// }\n\nvar CartesianAxisView = AxisView.extend({\n  type: 'cartesianAxis',\n  axisPointerClass: 'CartesianAxisPointer',\n\n  /**\n   * @override\n   */\n  render: function (axisModel, ecModel, api, payload) {\n    this.group.removeAll();\n    var oldAxisGroup = this._axisGroup;\n    this._axisGroup = new graphic.Group();\n    this.group.add(this._axisGroup);\n\n    if (!axisModel.get('show')) {\n      return;\n    }\n\n    var gridModel = axisModel.getCoordSysModel();\n    var layout = cartesianAxisHelper.layout(gridModel, axisModel);\n    var axisBuilder = new AxisBuilder(axisModel, layout);\n    zrUtil.each(axisBuilderAttrs, axisBuilder.add, axisBuilder);\n\n    this._axisGroup.add(axisBuilder.getGroup());\n\n    zrUtil.each(selfBuilderAttrs, function (name) {\n      if (axisModel.get(name + '.show')) {\n        this['_' + name](axisModel, gridModel);\n      }\n    }, this);\n    graphic.groupTransition(oldAxisGroup, this._axisGroup, axisModel);\n    CartesianAxisView.superCall(this, 'render', axisModel, ecModel, api, payload);\n  },\n  remove: function () {\n    this._splitAreaColors = null;\n  },\n\n  /**\n   * @param {module:echarts/coord/cartesian/AxisModel} axisModel\n   * @param {module:echarts/coord/cartesian/GridModel} gridModel\n   * @private\n   */\n  _splitLine: function (axisModel, gridModel) {\n    var axis = axisModel.axis;\n\n    if (axis.scale.isBlank()) {\n      return;\n    }\n\n    var splitLineModel = axisModel.getModel('splitLine');\n    var lineStyleModel = splitLineModel.getModel('lineStyle');\n    var lineColors = lineStyleModel.get('color');\n    lineColors = zrUtil.isArray(lineColors) ? lineColors : [lineColors];\n    var gridRect = gridModel.coordinateSystem.getRect();\n    var isHorizontal = axis.isHorizontal();\n    var lineCount = 0;\n    var ticksCoords = axis.getTicksCoords({\n      tickModel: splitLineModel\n    });\n    var p1 = [];\n    var p2 = []; // Simple optimization\n    // Batching the lines if color are the same\n\n    var lineStyle = lineStyleModel.getLineStyle();\n\n    for (var i = 0; i < ticksCoords.length; i++) {\n      var tickCoord = axis.toGlobalCoord(ticksCoords[i].coord);\n\n      if (isHorizontal) {\n        p1[0] = tickCoord;\n        p1[1] = gridRect.y;\n        p2[0] = tickCoord;\n        p2[1] = gridRect.y + gridRect.height;\n      } else {\n        p1[0] = gridRect.x;\n        p1[1] = tickCoord;\n        p2[0] = gridRect.x + gridRect.width;\n        p2[1] = tickCoord;\n      }\n\n      var colorIndex = lineCount++ % lineColors.length;\n      var tickValue = ticksCoords[i].tickValue;\n\n      this._axisGroup.add(new graphic.Line(graphic.subPixelOptimizeLine({\n        anid: tickValue != null ? 'line_' + ticksCoords[i].tickValue : null,\n        shape: {\n          x1: p1[0],\n          y1: p1[1],\n          x2: p2[0],\n          y2: p2[1]\n        },\n        style: zrUtil.defaults({\n          stroke: lineColors[colorIndex]\n        }, lineStyle),\n        silent: true\n      })));\n    }\n  },\n\n  /**\n   * @param {module:echarts/coord/cartesian/AxisModel} axisModel\n   * @param {module:echarts/coord/cartesian/GridModel} gridModel\n   * @private\n   */\n  _splitArea: function (axisModel, gridModel) {\n    var axis = axisModel.axis;\n\n    if (axis.scale.isBlank()) {\n      return;\n    }\n\n    var splitAreaModel = axisModel.getModel('splitArea');\n    var areaStyleModel = splitAreaModel.getModel('areaStyle');\n    var areaColors = areaStyleModel.get('color');\n    var gridRect = gridModel.coordinateSystem.getRect();\n    var ticksCoords = axis.getTicksCoords({\n      tickModel: splitAreaModel,\n      clamp: true\n    });\n\n    if (!ticksCoords.length) {\n      return;\n    } // For Making appropriate splitArea animation, the color and anid\n    // should be corresponding to previous one if possible.\n\n\n    var areaColorsLen = areaColors.length;\n    var lastSplitAreaColors = this._splitAreaColors;\n    var newSplitAreaColors = zrUtil.createHashMap();\n    var colorIndex = 0;\n\n    if (lastSplitAreaColors) {\n      for (var i = 0; i < ticksCoords.length; i++) {\n        var cIndex = lastSplitAreaColors.get(ticksCoords[i].tickValue);\n\n        if (cIndex != null) {\n          colorIndex = (cIndex + (areaColorsLen - 1) * i) % areaColorsLen;\n          break;\n        }\n      }\n    }\n\n    var prev = axis.toGlobalCoord(ticksCoords[0].coord);\n    var areaStyle = areaStyleModel.getAreaStyle();\n    areaColors = zrUtil.isArray(areaColors) ? areaColors : [areaColors];\n\n    for (var i = 1; i < ticksCoords.length; i++) {\n      var tickCoord = axis.toGlobalCoord(ticksCoords[i].coord);\n      var x;\n      var y;\n      var width;\n      var height;\n\n      if (axis.isHorizontal()) {\n        x = prev;\n        y = gridRect.y;\n        width = tickCoord - x;\n        height = gridRect.height;\n        prev = x + width;\n      } else {\n        x = gridRect.x;\n        y = prev;\n        width = gridRect.width;\n        height = tickCoord - y;\n        prev = y + height;\n      }\n\n      var tickValue = ticksCoords[i - 1].tickValue;\n      tickValue != null && newSplitAreaColors.set(tickValue, colorIndex);\n\n      this._axisGroup.add(new graphic.Rect({\n        anid: tickValue != null ? 'area_' + tickValue : null,\n        shape: {\n          x: x,\n          y: y,\n          width: width,\n          height: height\n        },\n        style: zrUtil.defaults({\n          fill: areaColors[colorIndex]\n        }, areaStyle),\n        silent: true\n      }));\n\n      colorIndex = (colorIndex + 1) % areaColorsLen;\n    }\n\n    this._splitAreaColors = newSplitAreaColors;\n  }\n});\nCartesianAxisView.extend({\n  type: 'xAxis'\n});\nCartesianAxisView.extend({\n  type: 'yAxis'\n});"]},"metadata":{},"sourceType":"script"}