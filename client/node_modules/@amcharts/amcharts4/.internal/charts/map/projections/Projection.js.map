{"version":3,"file":"Projection.js","sourceRoot":"","sources":["../../../../../../src/.internal/charts/map/projections/Projection.ts"],"names":[],"mappings":"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","sourcesContent":["/**\r\n * This module contains funcitonality related to geographical projections\r\n */\r\n\r\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\r\nimport { IGeoPoint } from \"../../../core/defs/IGeoPoint\";\r\n//import { IGeoRectangle } from \"../../../core/defs/IGeoRectangle\";\r\nimport { IPoint, IOrientationPoint } from \"../../../core/defs/IPoint\";\r\nimport { registry } from \"../../../core/Registry\";\r\nimport * as $math from \"../../../core/utils/Math\";\r\nimport * as d3geo from \"d3-geo\";\r\n\r\n\r\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * This is a base class for a geographical projection.\r\n */\r\nexport class Projection {\r\n\r\n\tpublic deltaLongitude: number = 0;\r\n\r\n\tpublic deltaLatitude: number = 0;\r\n\r\n\tpublic deltaGama: number = 0;\r\n\r\n\tprotected _d3Projection: d3geo.GeoProjection;\r\n\r\n\tprotected _d3Path: d3geo.GeoPath;\r\n\r\n\tconstructor() {\r\n\t\tthis.d3Projection = d3geo.geoEquirectangular();\r\n\t}\r\n\r\n\tpublic set d3Projection(projection: d3geo.GeoProjection) {\r\n\t\tthis._d3Projection = projection;\r\n\t\tprojection.precision(0.1);\r\n\t\tthis._d3Path = d3geo.geoPath().projection(projection);\r\n\t}\r\n\r\n\tpublic get d3Projection(): d3geo.GeoProjection {\r\n\t\treturn this._d3Projection;\r\n\t}\r\n\r\n\tpublic get d3Path(): d3geo.GeoPath {\r\n\t\treturn this._d3Path;\r\n\t}\r\n\r\n\tpublic get scale(): number {\r\n\t\treturn this.d3Projection.scale() / 100;\r\n\t}\r\n\r\n\t/*\r\n\t\tpublic projectGeoArea(geoArea: IGeoPoint[][][]): IPoint[][][] {\r\n\t\r\n\t\t\tlet clippedGeoArea: IGeoPoint[][][] = this.clipGeoArea(geoArea);\r\n\t\t\tlet convertedPoints: IPoint[][][] = this.convertGeoArea(clippedGeoArea);\r\n\t\r\n\t\t\treturn convertedPoints;\r\n\t\t}\r\n\t\r\n\t\tpublic projectGeoLine(geoLine: IGeoPoint[][]): IPoint[][] {\r\n\t\t\treturn this.convertGeoLine(this.clipGeoLine(geoLine));\r\n\t\t}\r\n\t\r\n\t\tpublic getClipRectangle1(): IGeoPoint[] {\r\n\t\t\tlet longitude = $geo.wrapAngleTo180(180 - this.deltaLongitude);\r\n\t\t\tlet latitude = $geo.wrapAngleTo180(this.deltaLatitude);\r\n\t\r\n\t\t\tlet smallNum = 0.00001;\r\n\t\t\treturn [{ longitude: -180, latitude: latitude - 90 }, { longitude: longitude - smallNum, latitude: latitude - 90 }, { longitude: longitude - smallNum, latitude: latitude + 90 }, { longitude: -180, latitude: latitude + 90 }];\r\n\t\t}\r\n\t\r\n\t\tpublic getClipRectangle2(): IGeoPoint[] {\r\n\t\t\tlet longitude = $geo.wrapAngleTo180(180 - this.deltaLongitude);\r\n\t\t\t//let latitude = $geo.wrapAngleTo180(this.deltaLatitude);\r\n\t\r\n\t\t\tlet smallNum = 0.00001;\r\n\t\t\treturn [{ longitude: longitude + smallNum, latitude: -90 }, { longitude: 180, latitude: -90 }, { longitude: 180, latitude: 90 }, { longitude: longitude + smallNum, latitude: 90 }];\r\n\t\t}\r\n\t\r\n\t\tpublic getRect1(): IGeoRectangle {\r\n\t\t\tlet longitude = $geo.wrapAngleTo180(180 - this.deltaLongitude);\r\n\t\t\tlet latitude = $geo.wrapAngleTo180(this.deltaLatitude);\r\n\t\r\n\t\t\treturn { north: latitude + 90, south: latitude - 90, west: longitude - 180, east: longitude };\r\n\t\t}\r\n\t\r\n\t\tpublic getRect2(): IGeoRectangle {\r\n\t\t\tlet longitude = $geo.wrapAngleTo180(180 - this.deltaLongitude);\r\n\t\t\tlet latitude = $geo.wrapAngleTo180(this.deltaLatitude);\r\n\t\r\n\t\t\treturn { north: latitude + 90, south: latitude - 90, west: longitude, east: (longitude + 180) };\r\n\t\t}\r\n\t\r\n\t\r\n\t\r\n\t\tprotected clipGeoLine(geoLine: IGeoPoint[][]): IGeoPoint[][] {\r\n\t\t\tif (!geoLine) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\r\n\t\t\tlet clippedLine: IGeoPoint[][] = [];\r\n\t\r\n\t\t\tlet clipRectangle1 = this.getClipRectangle1();\r\n\t\t\tlet clipRectangle2 = this.getClipRectangle2();\r\n\t\r\n\t\t\tfor (let i = 0, len = geoLine.length; i < len; i++) {\r\n\t\t\t\tlet segment: IGeoPoint[] = geoLine[i];\r\n\t\r\n\t\t\t\tif (segment) {\r\n\t\t\t\t\tlet clippedSegments: IGeoPoint[][] = this.clipLine(segment, clipRectangle1);\r\n\t\t\t\t\tclippedLine = clippedLine.concat(clippedSegments);\r\n\t\r\n\t\t\t\t\tif (this.deltaLongitude != 0) {\r\n\t\t\t\t\t\tlet clippedSegments2: IGeoPoint[][] = this.clipLine(segment, clipRectangle2);\r\n\t\t\t\t\t\tclippedLine = clippedLine.concat(clippedSegments2);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\r\n\t\t\treturn clippedLine;\r\n\t\t}\r\n\t\r\n\t\r\n\t\tprotected clipGeoArea(geoArea: IGeoPoint[][][]): IGeoPoint[][][] {\r\n\t\r\n\t\t\tif (!geoArea) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\r\n\t\t\tlet clippedArea: IGeoPoint[][][] = [];\r\n\t\r\n\t\t\tlet clipRectangle1 = this.getClipRectangle1();\r\n\t\t\tlet clipRectangle2 = this.getClipRectangle2();\r\n\t\r\n\t\t\tlet rect1 = this.getRect1();\r\n\t\t\tlet rect2 = this.getRect2();\r\n\t\r\n\t\t\tfor (let i = 0, len = geoArea.length; i < len; i++) {\r\n\t\r\n\t\t\t\tlet surface: IGeoPoint[] = geoArea[i][0];\r\n\t\t\t\tlet hole: IGeoPoint[] = geoArea[i][1];\r\n\t\r\n\t\t\t\tlet clippedAreas: IGeoPoint[][][] = [];\r\n\t\r\n\t\t\t\tif (surface) {\r\n\t\r\n\t\t\t\t\tlet surfaceRect = this.getExtremes(surface);\r\n\t\r\n\t\t\t\t\tif (!this.isInside(surfaceRect, rect1) && !this.isOutside(surfaceRect, rect1)) {\r\n\t\t\t\t\t\tlet clippedSurface1: IGeoPoint[] = this.clip(surface, clipRectangle1);\r\n\t\t\t\t\t\tlet clippedHole1: IGeoPoint[] = this.clip(hole, clipRectangle1);\r\n\t\t\t\t\t\tclippedAreas.push([clippedSurface1, clippedHole1]);\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tclippedAreas.push([surface, hole]);\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tif (!this.isInside(surfaceRect, rect2) && !this.isOutside(surfaceRect, rect2)) {\r\n\t\t\t\t\t\tlet clippedSurface2: IGeoPoint[] = this.clip(surface, clipRectangle2);\r\n\t\t\t\t\t\tlet clippedHole2: IGeoPoint[] = this.clip(hole, clipRectangle2);\r\n\t\t\t\t\t\tclippedAreas.push([clippedSurface2, clippedHole2]);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tfor (let area of clippedAreas) {\r\n\t\t\t\t\tclippedArea.push(area);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\r\n\t\t\treturn clippedArea;\r\n\t\t}\r\n\t\r\n\t\tprotected convertGeoArea(geoArea: IGeoPoint[][][]): IPoint[][][] {\r\n\t\r\n\t\t\tif (!geoArea) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\r\n\t\t\tlet convertedPoints: IPoint[][][] = [];\r\n\t\r\n\t\t\tfor (let i = 0, len = geoArea.length; i < len; i++) {\r\n\t\r\n\t\t\t\tlet surface: IGeoPoint[] = geoArea[i][0];\r\n\t\t\t\tlet hole: IGeoPoint[] = geoArea[i][1];\r\n\t\r\n\t\t\t\tlet convertedAreaPoints: IPoint[][] = [];\r\n\t\r\n\t\t\t\tif (surface) {\r\n\t\t\t\t\tlet convertedSurface: IPoint[] = [];\r\n\t\r\n\t\t\t\t\tfor (let s = 0, slen = surface.length; s < slen; s++) {\r\n\t\t\t\t\t\tlet point: IPoint = this.convert(surface[s]);\r\n\t\r\n\t\t\t\t\t\tconvertedSurface.push(point);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tconvertedAreaPoints.push(convertedSurface);\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif (hole) {\r\n\t\t\t\t\tlet convertedHole: IPoint[] = [];\r\n\t\t\t\t\tfor (let s = 0, hlen = hole.length; s < hlen; s++) {\r\n\t\t\t\t\t\tlet point: IPoint = this.convert(hole[s]);\r\n\t\r\n\t\t\t\t\t\tconvertedHole.push(point);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tconvertedAreaPoints.push(convertedHole);\r\n\t\t\t\t}\r\n\t\t\t\tconvertedPoints.push(convertedAreaPoints);\r\n\t\t\t}\r\n\t\t\treturn convertedPoints;\r\n\t\t}\r\n\t\r\n\t\tprotected convertGeoLine(geoLine: IGeoPoint[][]): IPoint[][] {\r\n\t\t\tif (!geoLine) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tlet convertedPoints: IPoint[][] = [];\r\n\t\r\n\t\t\tfor (let i = 0, len = geoLine.length; i < len; i++) {\r\n\t\r\n\t\t\t\tlet segment: IGeoPoint[] = geoLine[i];\r\n\t\r\n\t\t\t\tlet convertedSegmentPoints: IPoint[] = [];\r\n\t\r\n\t\t\t\tfor (let s = 0, slen = segment.length; s < slen; s++) {\r\n\t\t\t\t\tlet geoPoint: IGeoPoint = segment[s];\r\n\t\r\n\t\t\t\t\tlet point: IPoint = this.convert(geoPoint);\r\n\t\t\t\t\tconvertedSegmentPoints.push(point);\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tconvertedPoints.push(convertedSegmentPoints);\r\n\t\t\t}\r\n\t\t\treturn convertedPoints;\r\n\t\t}\r\n\t*/\r\n\r\n\t/**\r\n\t * Converts a geographical point (lat/long) to a screen point (x/y)\r\n\t * @param geoPoint Geo point (lat/long)\r\n\t * @return Screen point (x/y)\r\n\t */\r\n\tpublic convert(geoPoint: IGeoPoint): IPoint {\r\n\t\t/*\r\n\t\tgeoPoint = $geo.normalizePoint(geoPoint);\r\n\t\tgeoPoint = this.rotate(geoPoint, this.deltaLongitude, this.deltaLatitude, this.deltaGama);\r\n\t\tlet pointInRadians: IPoint = this.project(geoPoint.longitude * $math.RADIANS, geoPoint.latitude * $math.RADIANS);\r\n\t\treturn {\r\n\t\t\tx: $math.round(pointInRadians.x * $math.DEGREES - this.centerPoint.x, 4) * this.scale,\r\n\t\t\ty: $math.round(-pointInRadians.y * $math.DEGREES - this.centerPoint.y, 4) * this.scale\r\n\t\t};*/\r\n\r\n\t\tlet p = this.d3Projection([geoPoint.longitude, geoPoint.latitude]);\r\n\t\treturn { x: p[0], y: p[1] };\r\n\t}\r\n\r\n\t/**\r\n\t * Converts a screen point (x/y) to a geographical point (lat/long)\r\n\t * @param point Screen point (x/y)\r\n\t * @return Geo point (lat/long)\r\n\t */\r\n\tpublic invert(point: IPoint): IGeoPoint {\r\n\t\t/*\r\n\t\tlet pointInRadians: IGeoPoint = this.unproject((point.x / this.scale + this.centerPoint.x) * $math.RADIANS, (-point.y / this.scale - this.centerPoint.y) * $math.RADIANS);\r\n\r\n\t\tlet geoPoint = { longitude: pointInRadians.longitude * $math.DEGREES, latitude: pointInRadians.latitude * $math.DEGREES };\r\n\r\n\t\tgeoPoint = this.unrotate(geoPoint, this.deltaLongitude, this.deltaLatitude, this.deltaGama);\r\n\t\t*/\r\n\t\tlet p = this.d3Projection.invert([point.x, point.y]);\r\n\r\n\t\treturn { longitude: p[0], latitude: p[1] };\r\n\t}\r\n\r\n\t/**\r\n\t * Returns X/Y coordinates.\r\n\t * Individual projections will override this method to apply their own\r\n\t * projection logic.\r\n\t * @deprecated\r\n\t * @param lambda [description]\r\n\t * @param phi    [description]\r\n\t * @return X/Y coordinates\r\n\t * @todo Needs description\r\n\t */\r\n\tpublic project(lambda: number, phi: number): IPoint {\r\n\t\treturn this.convert({ longitude: lambda * $math.DEGREES, latitude: phi * $math.DEGREES });\r\n\t}\r\n\r\n\t/**\r\n\t * Returns geographical coordinates (lat/long).\r\n\t * Individual projections will override this method to apply their own\r\n\t * projection logic.\r\n\t * @deprecated\r\n\t * @param x X coordinate\r\n\t * @param y Y coordinate\r\n\t * @return Geographical point\r\n\t * @todo Needs description\r\n\t */\r\n\tpublic unproject(x: number, y: number): IGeoPoint {\r\n\t\treturn this.invert({ x: x, y: y });\r\n\t}\r\n\r\n\r\n\tpublic rotate(geoPoint: IGeoPoint, deltaLongitude: number, deltaLatitude: number, deltaGamma?: number): IGeoPoint {\r\n\r\n\t\tlet deltaLambda = deltaLongitude * $math.RADIANS;\r\n\t\tlet deltaPhi = deltaLatitude * $math.RADIANS;\r\n\t\tdeltaGamma = deltaGamma * $math.RADIANS;\r\n\r\n\t\tlet lambda = geoPoint.longitude * $math.RADIANS + deltaLambda;\r\n\t\tlet phi = geoPoint.latitude * $math.RADIANS;\r\n\r\n\t\tlet cosDeltaPhi = Math.cos(deltaPhi);\r\n\t\tlet sinDeltaPhi = Math.sin(deltaPhi);\r\n\t\tlet cosDeltaGamma = Math.cos(deltaGamma);\r\n\t\tlet sinDeltaGamma = Math.sin(deltaGamma);\r\n\r\n\t\tlet cosPhi = Math.cos(phi);\r\n\r\n\t\tlet x = Math.cos(lambda) * cosPhi;\r\n\t\tlet y = Math.sin(lambda) * cosPhi;\r\n\t\tlet z = Math.sin(phi);\r\n\t\tlet k = z * cosDeltaPhi + x * sinDeltaPhi;\r\n\r\n\t\treturn { longitude: $math.DEGREES * Math.atan2(y * cosDeltaGamma - k * sinDeltaGamma, x * cosDeltaPhi - z * sinDeltaPhi), latitude: $math.DEGREES * Math.asin(k * cosDeltaGamma + y * sinDeltaGamma) };\r\n\t}\r\n\r\n\tpublic unrotate(geoPoint: IGeoPoint, deltaLongitude: number, deltaLatitude: number, deltaGamma?: number): IGeoPoint {\r\n\r\n\t\tlet deltaLambda = deltaLongitude * $math.RADIANS;\r\n\t\tlet deltaPhi = deltaLatitude * $math.RADIANS;\r\n\t\tdeltaGamma = deltaGamma * $math.RADIANS;\r\n\r\n\t\tlet lambda = geoPoint.longitude * $math.RADIANS - deltaLambda;\r\n\t\tlet phi = geoPoint.latitude * $math.RADIANS;\r\n\r\n\t\tlet cosDeltaPhi = Math.cos(deltaPhi);\r\n\t\tlet sinDeltaPhi = Math.sin(deltaPhi);\r\n\t\tlet cosDeltaGamma = Math.cos(deltaGamma);\r\n\t\tlet sinDeltaGamma = Math.sin(deltaGamma);\r\n\r\n\t\tlet cosPhi = Math.cos(phi);\r\n\r\n\t\tlet x = Math.cos(lambda) * cosPhi;\r\n\t\tlet y = Math.sin(lambda) * cosPhi;\r\n\t\tlet z = Math.sin(phi);\r\n\t\tlet k = z * cosDeltaGamma - y * sinDeltaGamma;\r\n\r\n\t\treturn { longitude: $math.DEGREES * Math.atan2(y * cosDeltaGamma + z * sinDeltaGamma, x * cosDeltaPhi + k * sinDeltaPhi), latitude: $math.DEGREES * Math.asin(k * cosDeltaPhi - x * sinDeltaPhi) };\r\n\t}\r\n\r\n\r\n\t/*\t\r\n\t\t\tclipLine(subjectPolyline: IGeoPoint[], clipPolygon: IGeoPoint[]): IGeoPoint[][] {\r\n\t\t\r\n\t\t\t\tif (!subjectPolyline || subjectPolyline.length == 0) {\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\r\n\t\t\t\tlet cp1: IGeoPoint;\r\n\t\t\t\tlet cp2: IGeoPoint;\r\n\t\t\r\n\t\t\t\tvar inside = function(p: IGeoPoint) {\r\n\t\t\t\t\treturn (cp2.longitude - cp1.longitude) * (p.latitude - cp1.latitude) > (cp2.latitude - cp1.latitude) * (p.longitude - cp1.longitude);\r\n\t\t\t\t};\r\n\t\t\r\n\t\t\t\tlet s: IGeoPoint;\r\n\t\t\t\tlet e: IGeoPoint;\r\n\t\t\r\n\t\t\t\t//@todo: make a separate function\r\n\t\t\t\tvar intersection = function() {\r\n\t\t\t\t\tlet dc = { longitude: cp1.longitude - cp2.longitude, latitude: cp1.latitude - cp2.latitude };\r\n\t\t\t\t\tlet dp = { longitude: s.longitude - e.longitude, latitude: s.latitude - e.latitude };\r\n\t\t\t\t\tlet n1 = cp1.longitude * cp2.latitude - cp1.latitude * cp2.longitude;\r\n\t\t\t\t\tlet n2 = s.longitude * e.latitude - s.latitude * e.longitude;\r\n\t\t\t\t\tlet n3 = 1.0 / (dc.longitude * dp.latitude - dc.latitude * dp.longitude);\r\n\t\t\r\n\t\t\t\t\treturn { longitude: (n1 * dp.longitude - n2 * dc.longitude) * n3, latitude: (n1 * dp.latitude - n2 * dc.latitude) * n3 };\r\n\t\t\t\t};\r\n\t\t\r\n\t\t\t\tvar segment: IGeoPoint[] = subjectPolyline;\r\n\t\t\r\n\t\t\t\tcp1 = clipPolygon[clipPolygon.length - 1];\r\n\t\t\r\n\t\t\t\tfor (let j = 0; j < clipPolygon.length; ++j) {\r\n\t\t\t\t\tcp2 = clipPolygon[j];\r\n\t\t\t\t\tlet inputList = segment;\r\n\t\t\t\t\tsegment = [];\r\n\t\t\t\t\ts = inputList[0];\r\n\t\t\t\t\tfor (let i = 0, len = inputList.length; i < len; i++) {\r\n\t\t\t\t\t\te = inputList[i];\r\n\t\t\r\n\t\t\t\t\t\tif (inside(e)) {\r\n\t\t\t\t\t\t\tif (!inside(s)) {\r\n\t\t\t\t\t\t\t\tsegment.push(intersection());\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tsegment.push(e);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse if (inside(s)) {\r\n\t\t\t\t\t\t\tsegment.push(intersection());\r\n\t\t\t\t\t\t}\r\n\t\t\r\n\t\t\t\t\t\ts = e;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tcp1 = cp2;\r\n\t\t\t\t}\r\n\t\t\r\n\t\t\t\treturn [segment];\r\n\t\t\t}\r\n\t\t\r\n\t\t\r\n\t\t\r\n\t\t\r\n\t\t\t//@todo add credits to roseta code\r\n\t\t\t//@todo: someday make it better\r\n\t\t\tclip(subjectPolygon: IGeoPoint[], clipPolygon: IGeoPoint[]) {\r\n\t\t\r\n\t\t\t\tif (!subjectPolygon || subjectPolygon.length == 0) {\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\r\n\t\t\t\tlet cp1: IGeoPoint;\r\n\t\t\t\tlet cp2: IGeoPoint;\r\n\t\t\r\n\t\t\t\tvar inside = function(p: IGeoPoint) {\r\n\t\t\t\t\treturn (cp2.longitude - cp1.longitude) * (p.latitude - cp1.latitude) > (cp2.latitude - cp1.latitude) * (p.longitude - cp1.longitude);\r\n\t\t\t\t};\r\n\t\t\r\n\t\t\t\tlet s: IGeoPoint;\r\n\t\t\t\tlet e: IGeoPoint;\r\n\t\t\t\t//@todo: make a separate function\r\n\t\t\t\tvar intersection = function() {\r\n\t\t\t\t\tlet dc = { longitude: cp1.longitude - cp2.longitude, latitude: cp1.latitude - cp2.latitude };\r\n\t\t\t\t\tlet dp = { longitude: s.longitude - e.longitude, latitude: s.latitude - e.latitude };\r\n\t\t\t\t\tlet n1 = cp1.longitude * cp2.latitude - cp1.latitude * cp2.longitude;\r\n\t\t\t\t\tlet n2 = s.longitude * e.latitude - s.latitude * e.longitude;\r\n\t\t\t\t\tlet n3 = 1.0 / (dc.longitude * dp.latitude - dc.latitude * dp.longitude);\r\n\t\t\r\n\t\t\t\t\treturn { longitude: (n1 * dp.longitude - n2 * dc.longitude) * n3, latitude: (n1 * dp.latitude - n2 * dc.latitude) * n3 };\r\n\t\t\t\t};\r\n\t\t\r\n\t\t\t\tvar outputList = subjectPolygon;\r\n\t\t\r\n\t\t\t\tcp1 = clipPolygon[clipPolygon.length - 1];\r\n\t\t\r\n\t\t\t\tfor (let j = 0; j < clipPolygon.length; ++j) {\r\n\t\t\t\t\tcp2 = clipPolygon[j];\r\n\t\t\t\t\tlet inputList = outputList;\r\n\t\t\t\t\toutputList = [];\r\n\t\t\t\t\ts = inputList[inputList.length - 1]; //last on the input list\r\n\t\t\r\n\t\t\t\t\tfor (let i = 0, len = inputList.length; i < len; ++i) {\r\n\t\t\t\t\t\te = inputList[i];\r\n\t\t\r\n\t\t\t\t\t\tif (inside(e)) {\r\n\t\t\t\t\t\t\tif (!inside(s)) {\r\n\t\t\t\t\t\t\t\toutputList.push(intersection());\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\toutputList.push(e);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse if (inside(s)) {\r\n\t\t\t\t\t\t\toutputList.push(intersection());\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\ts = e;\r\n\t\t\t\t\t}\r\n\t\t\r\n\t\t\t\t\tcp1 = cp2;\r\n\t\t\t\t}\r\n\t\t\t\treturn outputList;\r\n\t\t\t}\r\n\t\t*/\r\n\t//@todo: move to some utils?\r\n\t/*\r\n\tpublic getExtremes(geoPoints: IGeoPoint[]): IGeoRectangle {\r\n\r\n\t\tlet west: number = geoPoints[0].longitude;\r\n\t\tlet east: number = geoPoints[0].longitude;\r\n\t\tlet north: number = geoPoints[0].latitude;\r\n\t\tlet south: number = geoPoints[0].latitude;\r\n\r\n\t\tfor (let s: number = 0; s < geoPoints.length; s++) {\r\n\t\t\tlet longitude: number = geoPoints[s].longitude;\r\n\t\t\tlet latitude: number = geoPoints[s].latitude;\r\n\r\n\t\t\tif ((west > longitude)) {\r\n\t\t\t\twest = longitude;\r\n\t\t\t}\r\n\t\t\tif ((east < longitude)) {\r\n\t\t\t\teast = longitude;\r\n\t\t\t}\r\n\r\n\t\t\tif ((north < latitude)) {\r\n\t\t\t\tnorth = latitude;\r\n\t\t\t}\r\n\t\t\tif ((south > latitude)) {\r\n\t\t\t\tsouth = latitude;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn { north: north, east: east, south: south, west: west };\r\n\t}*/\r\n\t/*\r\n\t\t//@todo: move to some utils?\r\n\t\tpublic isInside(r1: IGeoRectangle, r2: IGeoRectangle) {\r\n\t\t\tif (r1.north < r2.north && r1.south > r2.south && r1.west > r2.west && r1.east < r2.east) {\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\r\n\t\t//@todo: move to some utils?\r\n\t\tpublic isOutside(r1: IGeoRectangle, r2: IGeoRectangle) {\r\n\t\t\tif (r1.south > r2.north || r1.north < r2.south || r1.west > r2.east || r1.east < r2.west) {\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t\treturn false;\r\n\t\t}\r\n\t*/\r\n\r\n\t//@todo: move to some utils?\r\n\t//@todo: add credits to: https://www.movable-type.co.uk/scripts/latlong.html\r\n\tpublic intermediatePoint(pointA: IGeoPoint, pointB: IGeoPoint, position: number): IGeoPoint {\r\n\t\tlet p = d3geo.geoInterpolate([pointA.longitude, pointA.latitude], [pointB.longitude, pointB.latitude])(position);\r\n\t\treturn { longitude: p[0], latitude: p[1] };\r\n\t};\r\n\r\n\t// returns radians\r\n\tpublic multiDistance(multiGeoLine: IGeoPoint[][]): number {\r\n\t\tlet distance = 0;\r\n\t\tfor (let s = 0; s < multiGeoLine.length; s++) {\r\n\t\t\tlet points: IGeoPoint[] = multiGeoLine[s];\r\n\t\t\tif (points.length > 1) {\r\n\t\t\t\tfor (let p = 1; p < points.length; p++) {\r\n\t\t\t\t\tlet pointA = points[p - 1];\r\n\t\t\t\t\tlet pointB = points[p];\r\n\t\t\t\t\tdistance += this.distance(pointA, pointB);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn distance;\r\n\t}\r\n\r\n\t// returns radians\r\n\tpublic distance(pointA: IGeoPoint, pointB: IGeoPoint): number {\r\n\t\treturn d3geo.geoDistance([pointA.longitude, pointA.latitude], [pointB.longitude, pointB.latitude]);\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Converts relative position along the line (0-1) into pixel coordinates.\r\n\t *\r\n\t * @param position  Position (0-1)\r\n\t * @return Coordinates\r\n\t */\r\n\tpublic positionToPoint(multiGeoLine: IGeoPoint[][], position: number): IOrientationPoint {\r\n\r\n\t\tif (multiGeoLine) {\r\n\t\t\tlet intermediatePoint = this.positionToGeoPoint(multiGeoLine, position);\r\n\t\t\tlet intermediatePointA = this.positionToGeoPoint(multiGeoLine, position - 0.01);\r\n\t\t\tlet intermediatePointB = this.positionToGeoPoint(multiGeoLine, position + 0.01);\r\n\r\n\t\t\tif (intermediatePointA && intermediatePointB) {\r\n\r\n\t\t\t\tlet point = this.convert(intermediatePoint);\r\n\r\n\t\t\t\tlet pa = this.convert(intermediatePointA);\r\n\t\t\t\tlet pb = this.convert(intermediatePointB);\r\n\r\n\t\t\t\treturn { x: point.x, y: point.y, angle: $math.getAngle(pa, pb) };\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn { x: 0, y: 0, angle: 0 };\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Converts relative position along the line (0-1) into pixel coordinates.\r\n\t *\r\n\t * @param position  Position (0-1)\r\n\t * @return Coordinates\r\n\t */\r\n\tpublic positionToGeoPoint(multiGeoLine: IGeoPoint[][], position: number): IGeoPoint {\r\n\r\n\t\tif (multiGeoLine) {\r\n\t\t\tlet totalDistance: number = this.multiDistance(multiGeoLine);\r\n\t\t\tlet currentDistance: number = 0;\r\n\r\n\t\t\tlet distanceAB: number;\r\n\t\t\tlet positionA: number = 0;\r\n\t\t\tlet positionB: number = 0;\r\n\t\t\tlet pointA: IGeoPoint;\r\n\t\t\tlet pointB: IGeoPoint;\r\n\r\n\t\t\tfor (let s = 0; s < multiGeoLine.length; s++) {\r\n\t\t\t\tlet points: IGeoPoint[] = multiGeoLine[s];\r\n\t\t\t\tif (points.length > 1) {\r\n\t\t\t\t\tfor (let p = 1; p < points.length; p++) {\r\n\t\t\t\t\t\tpointA = points[p - 1];\r\n\t\t\t\t\t\tpointB = points[p];\r\n\r\n\t\t\t\t\t\tpositionA = currentDistance / totalDistance;\r\n\t\t\t\t\t\tdistanceAB = this.distance(pointA, pointB);\r\n\t\t\t\t\t\tcurrentDistance += distanceAB;\r\n\t\t\t\t\t\tpositionB = currentDistance / totalDistance;\r\n\r\n\t\t\t\t\t\tif (positionA <= position && positionB > position) {\r\n\t\t\t\t\t\t\ts = multiGeoLine.length;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\telse if (points.length == 1) {\r\n\t\t\t\t\tpointA = points[0];\r\n\t\t\t\t\tpointB = points[0];\r\n\t\t\t\t\tpositionA = 0;\r\n\t\t\t\t\tpositionB = 1;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif (pointA && pointB) {\r\n\t\t\t\tlet positionAB: number = (position - positionA) / (positionB - positionA);\r\n\t\t\t\treturn this.intermediatePoint(pointA, pointB, positionAB);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn { longitude: 0, latitude: 0 };\r\n\t}\r\n}\r\n\r\n\r\n\r\n/**\r\n * Register class in system, so that it can be instantiated using its name from\r\n * anywhere.\r\n *\r\n * @ignore\r\n */\r\nregistry.registeredClasses[\"Projection\"] = Projection;\r\n"]}